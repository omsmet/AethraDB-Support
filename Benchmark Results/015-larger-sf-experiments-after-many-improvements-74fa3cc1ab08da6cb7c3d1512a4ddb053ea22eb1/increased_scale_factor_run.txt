# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2)

# Run progress: 0.00% complete, ETA 08:46:40
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

337.432 ±(99.9%) 17.736 ms/op
# Warmup Iteration   2: 333.395 ±(99.9%) 3.292 ms/op
# Warmup Iteration   3: 335.142 ±(99.9%) 3.687 ms/op
# Warmup Iteration   4: 333.832 ±(99.9%) 4.711 ms/op
# Warmup Iteration   5: 333.797 ±(99.9%) 5.242 ms/op
Iteration   1: 340.438 ±(99.9%) 27.687 ms/op
                 executeQuery·p0.00:   328.204 ms/op
                 executeQuery·p0.50:   331.350 ms/op
                 executeQuery·p0.90:   339.948 ms/op
                 executeQuery·p0.95:   455.108 ms/op
                 executeQuery·p0.99:   555.745 ms/op
                 executeQuery·p0.999:  555.745 ms/op
                 executeQuery·p0.9999: 555.745 ms/op
                 executeQuery·p1.00:   555.745 ms/op

Iteration   2: 349.772 ±(99.9%) 52.098 ms/op
                 executeQuery·p0.00:   328.204 ms/op
                 executeQuery·p0.50:   331.874 ms/op
                 executeQuery·p0.90:   358.089 ms/op
                 executeQuery·p0.95:   555.483 ms/op
                 executeQuery·p0.99:   743.440 ms/op
                 executeQuery·p0.999:  743.440 ms/op
                 executeQuery·p0.9999: 743.440 ms/op
                 executeQuery·p1.00:   743.440 ms/op

Iteration   3: 331.181 ±(99.9%) 1.731 ms/op
                 executeQuery·p0.00:   327.156 ms/op
                 executeQuery·p0.50:   331.350 ms/op
                 executeQuery·p0.90:   334.705 ms/op
                 executeQuery·p0.95:   336.907 ms/op
                 executeQuery·p0.99:   339.739 ms/op
                 executeQuery·p0.999:  339.739 ms/op
                 executeQuery·p0.9999: 339.739 ms/op
                 executeQuery·p1.00:   339.739 ms/op

Iteration   4: 331.638 ±(99.9%) 1.755 ms/op
                 executeQuery·p0.00:   327.680 ms/op
                 executeQuery·p0.50:   331.874 ms/op
                 executeQuery·p0.90:   333.971 ms/op
                 executeQuery·p0.95:   337.222 ms/op
                 executeQuery·p0.99:   341.311 ms/op
                 executeQuery·p0.999:  341.311 ms/op
                 executeQuery·p0.9999: 341.311 ms/op
                 executeQuery·p1.00:   341.311 ms/op

Iteration   5: 331.824 ±(99.9%) 2.137 ms/op
                 executeQuery·p0.00:   328.204 ms/op
                 executeQuery·p0.50:   331.350 ms/op
                 executeQuery·p0.90:   333.447 ms/op
                 executeQuery·p0.95:   342.255 ms/op
                 executeQuery·p0.99:   342.884 ms/op
                 executeQuery·p0.999:  342.884 ms/op
                 executeQuery·p0.9999: 342.884 ms/op
                 executeQuery·p1.00:   342.884 ms/op


# Run progress: 0.32% complete, ETA 09:03:07
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

337.117 ±(99.9%) 21.717 ms/op
# Warmup Iteration   2: 332.381 ±(99.9%) 3.897 ms/op
# Warmup Iteration   3: 333.867 ±(99.9%) 4.295 ms/op
# Warmup Iteration   4: 332.608 ±(99.9%) 3.579 ms/op
# Warmup Iteration   5: 331.435 ±(99.9%) 2.152 ms/op
Iteration   1: 332.534 ±(99.9%) 1.990 ms/op
                 executeQuery·p0.00:   328.204 ms/op
                 executeQuery·p0.50:   331.874 ms/op
                 executeQuery·p0.90:   334.810 ms/op
                 executeQuery·p0.95:   341.207 ms/op
                 executeQuery·p0.99:   344.982 ms/op
                 executeQuery·p0.999:  344.982 ms/op
                 executeQuery·p0.9999: 344.982 ms/op
                 executeQuery·p1.00:   344.982 ms/op

Iteration   2: 332.259 ±(99.9%) 2.507 ms/op
                 executeQuery·p0.00:   328.204 ms/op
                 executeQuery·p0.50:   331.874 ms/op
                 executeQuery·p0.90:   336.593 ms/op
                 executeQuery·p0.95:   342.150 ms/op
                 executeQuery·p0.99:   344.457 ms/op
                 executeQuery·p0.999:  344.457 ms/op
                 executeQuery·p0.9999: 344.457 ms/op
                 executeQuery·p1.00:   344.457 ms/op

Iteration   3: 330.893 ±(99.9%) 2.766 ms/op
                 executeQuery·p0.00:   327.156 ms/op
                 executeQuery·p0.50:   329.777 ms/op
                 executeQuery·p0.90:   333.342 ms/op
                 executeQuery·p0.95:   345.401 ms/op
                 executeQuery·p0.99:   346.030 ms/op
                 executeQuery·p0.999:  346.030 ms/op
                 executeQuery·p0.9999: 346.030 ms/op
                 executeQuery·p1.00:   346.030 ms/op

Iteration   4: 331.485 ±(99.9%) 1.576 ms/op
                 executeQuery·p0.00:   327.680 ms/op
                 executeQuery·p0.50:   331.874 ms/op
                 executeQuery·p0.90:   333.971 ms/op
                 executeQuery·p0.95:   336.803 ms/op
                 executeQuery·p0.99:   337.117 ms/op
                 executeQuery·p0.999:  337.117 ms/op
                 executeQuery·p0.9999: 337.117 ms/op
                 executeQuery·p1.00:   337.117 ms/op

Iteration   5: 334.076 ±(99.9%) 7.521 ms/op
                 executeQuery·p0.00:   327.680 ms/op
                 executeQuery·p0.50:   332.399 ms/op
                 executeQuery·p0.90:   337.379 ms/op
                 executeQuery·p0.95:   363.043 ms/op
                 executeQuery·p0.99:   392.167 ms/op
                 executeQuery·p0.999:  392.167 ms/op
                 executeQuery·p0.9999: 392.167 ms/op
                 executeQuery·p1.00:   392.167 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 305
  mean =    334.501 ±(99.9%) 5.216 ms/op

  Histogram, ms/op:
    [300.000, 350.000) = 298 
    [350.000, 400.000) = 5 
    [400.000, 450.000) = 0 
    [450.000, 500.000) = 0 
    [500.000, 550.000) = 0 
    [550.000, 600.000) = 1 
    [600.000, 650.000) = 0 
    [650.000, 700.000) = 0 
    [700.000, 750.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    327.156 ms/op
     p(50.0000) =    331.350 ms/op
     p(90.0000) =    336.069 ms/op
     p(95.0000) =    342.203 ms/op
     p(99.0000) =    391.004 ms/op
     p(99.9000) =    743.440 ms/op
     p(99.9900) =    743.440 ms/op
     p(99.9990) =    743.440 ms/op
     p(99.9999) =    743.440 ms/op
    p(100.0000) =    743.440 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16)

# Run progress: 0.63% complete, ETA 09:00:41
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

503.605 ±(99.9%) 90.311 ms/op
# Warmup Iteration   2: 480.697 ±(99.9%) 2.413 ms/op
# Warmup Iteration   3: 483.144 ±(99.9%) 3.283 ms/op
# Warmup Iteration   4: 481.970 ±(99.9%) 3.709 ms/op
# Warmup Iteration   5: 479.898 ±(99.9%) 3.805 ms/op
Iteration   1: 469.810 ±(99.9%) 0.940 ms/op
                 executeQuery·p0.00:   467.665 ms/op
                 executeQuery·p0.50:   469.762 ms/op
                 executeQuery·p0.90:   471.859 ms/op
                 executeQuery·p0.95:   471.859 ms/op
                 executeQuery·p0.99:   471.859 ms/op
                 executeQuery·p0.999:  471.859 ms/op
                 executeQuery·p0.9999: 471.859 ms/op
                 executeQuery·p1.00:   471.859 ms/op

Iteration   2: 470.811 ±(99.9%) 2.390 ms/op
                 executeQuery·p0.00:   467.665 ms/op
                 executeQuery·p0.50:   470.286 ms/op
                 executeQuery·p0.90:   474.061 ms/op
                 executeQuery·p0.95:   481.244 ms/op
                 executeQuery·p0.99:   482.345 ms/op
                 executeQuery·p0.999:  482.345 ms/op
                 executeQuery·p0.9999: 482.345 ms/op
                 executeQuery·p1.00:   482.345 ms/op

Iteration   3: 480.448 ±(99.9%) 2.222 ms/op
                 executeQuery·p0.00:   476.578 ms/op
                 executeQuery·p0.50:   480.772 ms/op
                 executeQuery·p0.90:   484.337 ms/op
                 executeQuery·p0.95:   485.386 ms/op
                 executeQuery·p0.99:   485.491 ms/op
                 executeQuery·p0.999:  485.491 ms/op
                 executeQuery·p0.9999: 485.491 ms/op
                 executeQuery·p1.00:   485.491 ms/op

Iteration   4: 480.647 ±(99.9%) 2.093 ms/op
                 executeQuery·p0.00:   476.054 ms/op
                 executeQuery·p0.50:   480.772 ms/op
                 executeQuery·p0.90:   483.918 ms/op
                 executeQuery·p0.95:   484.390 ms/op
                 executeQuery·p0.99:   484.442 ms/op
                 executeQuery·p0.999:  484.442 ms/op
                 executeQuery·p0.9999: 484.442 ms/op
                 executeQuery·p1.00:   484.442 ms/op

Iteration   5: 481.521 ±(99.9%) 0.950 ms/op
                 executeQuery·p0.00:   479.724 ms/op
                 executeQuery·p0.50:   481.296 ms/op
                 executeQuery·p0.90:   482.869 ms/op
                 executeQuery·p0.95:   484.285 ms/op
                 executeQuery·p0.99:   484.442 ms/op
                 executeQuery·p0.999:  484.442 ms/op
                 executeQuery·p0.9999: 484.442 ms/op
                 executeQuery·p1.00:   484.442 ms/op


# Run progress: 0.95% complete, ETA 08:59:09
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

487.089 ±(99.9%) 11.328 ms/op
# Warmup Iteration   2: 483.943 ±(99.9%) 2.959 ms/op
# Warmup Iteration   3: 484.567 ±(99.9%) 3.394 ms/op
# Warmup Iteration   4: 482.869 ±(99.9%) 2.052 ms/op
# Warmup Iteration   5: 480.947 ±(99.9%) 3.090 ms/op
Iteration   1: 481.371 ±(99.9%) 2.264 ms/op
                 executeQuery·p0.00:   475.529 ms/op
                 executeQuery·p0.50:   481.296 ms/op
                 executeQuery·p0.90:   485.386 ms/op
                 executeQuery·p0.95:   485.491 ms/op
                 executeQuery·p0.99:   485.491 ms/op
                 executeQuery·p0.999:  485.491 ms/op
                 executeQuery·p0.9999: 485.491 ms/op
                 executeQuery·p1.00:   485.491 ms/op

Iteration   2: 482.245 ±(99.9%) 3.489 ms/op
                 executeQuery·p0.00:   477.102 ms/op
                 executeQuery·p0.50:   481.296 ms/op
                 executeQuery·p0.90:   490.000 ms/op
                 executeQuery·p0.95:   493.040 ms/op
                 executeQuery·p0.99:   493.355 ms/op
                 executeQuery·p0.999:  493.355 ms/op
                 executeQuery·p0.9999: 493.355 ms/op
                 executeQuery·p1.00:   493.355 ms/op

Iteration   3: 471.549 ±(99.9%) 2.574 ms/op
                 executeQuery·p0.00:   468.189 ms/op
                 executeQuery·p0.50:   471.335 ms/op
                 executeQuery·p0.90:   477.522 ms/op
                 executeQuery·p0.95:   481.060 ms/op
                 executeQuery·p0.99:   481.296 ms/op
                 executeQuery·p0.999:  481.296 ms/op
                 executeQuery·p0.9999: 481.296 ms/op
                 executeQuery·p1.00:   481.296 ms/op

Iteration   4: 470.930 ±(99.9%) 1.886 ms/op
                 executeQuery·p0.00:   468.189 ms/op
                 executeQuery·p0.50:   470.024 ms/op
                 executeQuery·p0.90:   474.166 ms/op
                 executeQuery·p0.95:   478.491 ms/op
                 executeQuery·p0.99:   479.199 ms/op
                 executeQuery·p0.999:  479.199 ms/op
                 executeQuery·p0.9999: 479.199 ms/op
                 executeQuery·p1.00:   479.199 ms/op

Iteration   5: 470.143 ±(99.9%) 1.492 ms/op
                 executeQuery·p0.00:   467.665 ms/op
                 executeQuery·p0.50:   469.500 ms/op
                 executeQuery·p0.90:   471.859 ms/op
                 executeQuery·p0.95:   474.979 ms/op
                 executeQuery·p0.99:   475.529 ms/op
                 executeQuery·p0.999:  475.529 ms/op
                 executeQuery·p0.9999: 475.529 ms/op
                 executeQuery·p1.00:   475.529 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 215
  mean =    475.824 ±(99.9%) 1.347 ms/op

  Histogram, ms/op:
    [460.000, 462.500) = 0 
    [462.500, 465.000) = 0 
    [465.000, 467.500) = 0 
    [467.500, 470.000) = 56 
    [470.000, 472.500) = 46 
    [472.500, 475.000) = 2 
    [475.000, 477.500) = 9 
    [477.500, 480.000) = 26 
    [480.000, 482.500) = 52 
    [482.500, 485.000) = 17 
    [485.000, 487.500) = 4 
    [487.500, 490.000) = 1 
    [490.000, 492.500) = 1 
    [492.500, 495.000) = 1 
    [495.000, 497.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =    467.665 ms/op
     p(50.0000) =    476.054 ms/op
     p(90.0000) =    482.869 ms/op
     p(95.0000) =    484.442 ms/op
     p(99.0000) =    490.042 ms/op
     p(99.9000) =    493.355 ms/op
     p(99.9900) =    493.355 ms/op
     p(99.9990) =    493.355 ms/op
     p(99.9999) =    493.355 ms/op
    p(100.0000) =    493.355 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192)

# Run progress: 1.27% complete, ETA 08:58:17
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

647.954 ±(99.9%) 78.683 ms/op
# Warmup Iteration   2: 621.281 ±(99.9%) 15.604 ms/op
# Warmup Iteration   3: 619.577 ±(99.9%) 6.951 ms/op
# Warmup Iteration   4: 617.546 ±(99.9%) 5.451 ms/op
# Warmup Iteration   5: 618.660 ±(99.9%) 6.764 ms/op
Iteration   1: 615.842 ±(99.9%) 7.270 ms/op
                 executeQuery·p0.00:   607.126 ms/op
                 executeQuery·p0.50:   617.611 ms/op
                 executeQuery·p0.90:   625.580 ms/op
                 executeQuery·p0.95:   627.048 ms/op
                 executeQuery·p0.99:   627.048 ms/op
                 executeQuery·p0.999:  627.048 ms/op
                 executeQuery·p0.9999: 627.048 ms/op
                 executeQuery·p1.00:   627.048 ms/op

Iteration   2: 617.611 ±(99.9%) 9.597 ms/op
                 executeQuery·p0.00:   603.980 ms/op
                 executeQuery·p0.50:   622.330 ms/op
                 executeQuery·p0.90:   628.412 ms/op
                 executeQuery·p0.95:   629.146 ms/op
                 executeQuery·p0.99:   629.146 ms/op
                 executeQuery·p0.999:  629.146 ms/op
                 executeQuery·p0.9999: 629.146 ms/op
                 executeQuery·p1.00:   629.146 ms/op

Iteration   3: 612.738 ±(99.9%) 6.849 ms/op
                 executeQuery·p0.00:   597.688 ms/op
                 executeQuery·p0.50:   612.368 ms/op
                 executeQuery·p0.90:   622.015 ms/op
                 executeQuery·p0.95:   622.854 ms/op
                 executeQuery·p0.99:   622.854 ms/op
                 executeQuery·p0.999:  622.854 ms/op
                 executeQuery·p0.9999: 622.854 ms/op
                 executeQuery·p1.00:   622.854 ms/op

Iteration   4: 619.119 ±(99.9%) 7.951 ms/op
                 executeQuery·p0.00:   606.077 ms/op
                 executeQuery·p0.50:   622.330 ms/op
                 executeQuery·p0.90:   627.678 ms/op
                 executeQuery·p0.95:   629.146 ms/op
                 executeQuery·p0.99:   629.146 ms/op
                 executeQuery·p0.999:  629.146 ms/op
                 executeQuery·p0.9999: 629.146 ms/op
                 executeQuery·p1.00:   629.146 ms/op

Iteration   5: 621.609 ±(99.9%) 7.106 ms/op
                 executeQuery·p0.00:   607.126 ms/op
                 executeQuery·p0.50:   623.903 ms/op
                 executeQuery·p0.90:   626.629 ms/op
                 executeQuery·p0.95:   628.097 ms/op
                 executeQuery·p0.99:   628.097 ms/op
                 executeQuery·p0.999:  628.097 ms/op
                 executeQuery·p0.9999: 628.097 ms/op
                 executeQuery·p1.00:   628.097 ms/op


# Run progress: 1.58% complete, ETA 08:56:18
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

659.624 ±(99.9%) 31.283 ms/op
# Warmup Iteration   2: 649.724 ±(99.9%) 9.588 ms/op
# Warmup Iteration   3: 645.464 ±(99.9%) 3.937 ms/op
# Warmup Iteration   4: 647.954 ±(99.9%) 4.984 ms/op
# Warmup Iteration   5: 646.513 ±(99.9%) 4.837 ms/op
Iteration   1: 644.940 ±(99.9%) 6.008 ms/op
                 executeQuery·p0.00:   630.194 ms/op
                 executeQuery·p0.50:   644.874 ms/op
                 executeQuery·p0.90:   651.480 ms/op
                 executeQuery·p0.95:   652.214 ms/op
                 executeQuery·p0.99:   652.214 ms/op
                 executeQuery·p0.999:  652.214 ms/op
                 executeQuery·p0.9999: 652.214 ms/op
                 executeQuery·p1.00:   652.214 ms/op

Iteration   2: 653.853 ±(99.9%) 6.127 ms/op
                 executeQuery·p0.00:   643.826 ms/op
                 executeQuery·p0.50:   654.311 ms/op
                 executeQuery·p0.90:   661.861 ms/op
                 executeQuery·p0.95:   664.797 ms/op
                 executeQuery·p0.99:   664.797 ms/op
                 executeQuery·p0.999:  664.797 ms/op
                 executeQuery·p0.9999: 664.797 ms/op
                 executeQuery·p1.00:   664.797 ms/op

Iteration   3: 646.447 ±(99.9%) 4.513 ms/op
                 executeQuery·p0.00:   641.729 ms/op
                 executeQuery·p0.50:   644.874 ms/op
                 executeQuery·p0.90:   653.892 ms/op
                 executeQuery·p0.95:   655.360 ms/op
                 executeQuery·p0.99:   655.360 ms/op
                 executeQuery·p0.999:  655.360 ms/op
                 executeQuery·p0.9999: 655.360 ms/op
                 executeQuery·p1.00:   655.360 ms/op

Iteration   4: 654.705 ±(99.9%) 3.042 ms/op
                 executeQuery·p0.00:   648.020 ms/op
                 executeQuery·p0.50:   654.836 ms/op
                 executeQuery·p0.90:   658.296 ms/op
                 executeQuery·p0.95:   662.700 ms/op
                 executeQuery·p0.99:   662.700 ms/op
                 executeQuery·p0.999:  662.700 ms/op
                 executeQuery·p0.9999: 662.700 ms/op
                 executeQuery·p1.00:   662.700 ms/op

Iteration   5: 652.673 ±(99.9%) 4.612 ms/op
                 executeQuery·p0.00:   644.874 ms/op
                 executeQuery·p0.50:   653.787 ms/op
                 executeQuery·p0.90:   659.449 ms/op
                 executeQuery·p0.95:   661.651 ms/op
                 executeQuery·p0.99:   661.651 ms/op
                 executeQuery·p0.999:  661.651 ms/op
                 executeQuery·p0.9999: 661.651 ms/op
                 executeQuery·p1.00:   661.651 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 161
  mean =    633.822 ±(99.9%) 4.796 ms/op

  Histogram, ms/op:
    [590.000, 595.000) = 0 
    [595.000, 600.000) = 1 
    [600.000, 605.000) = 2 
    [605.000, 610.000) = 21 
    [610.000, 615.000) = 9 
    [615.000, 620.000) = 5 
    [620.000, 625.000) = 31 
    [625.000, 630.000) = 12 
    [630.000, 635.000) = 2 
    [635.000, 640.000) = 0 
    [640.000, 645.000) = 20 
    [645.000, 650.000) = 11 
    [650.000, 655.000) = 28 
    [655.000, 660.000) = 14 
    [660.000, 665.000) = 5 

  Percentiles, ms/op:
      p(0.0000) =    597.688 ms/op
     p(50.0000) =    629.146 ms/op
     p(90.0000) =    655.360 ms/op
     p(95.0000) =    657.352 ms/op
     p(99.0000) =    663.497 ms/op
     p(99.9000) =    664.797 ms/op
     p(99.9900) =    664.797 ms/op
     p(99.9990) =    664.797 ms/op
     p(99.9999) =    664.797 ms/op
    p(100.0000) =    664.797 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144)

# Run progress: 1.90% complete, ETA 08:57:23
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

2906.653 ms/op
# Warmup Iteration   2: 2197.815 ms/op
# Warmup Iteration   3: 2132.804 ms/op
# Warmup Iteration   4: 1983.906 ms/op
# Warmup Iteration   5: 1950.351 ms/op
Iteration   1: 2009.072 ms/op
                 executeQuery·p0.00:   2009.072 ms/op
                 executeQuery·p0.50:   2009.072 ms/op
                 executeQuery·p0.90:   2009.072 ms/op
                 executeQuery·p0.95:   2009.072 ms/op
                 executeQuery·p0.99:   2009.072 ms/op
                 executeQuery·p0.999:  2009.072 ms/op
                 executeQuery·p0.9999: 2009.072 ms/op
                 executeQuery·p1.00:   2009.072 ms/op

Iteration   2: 1965.031 ms/op
                 executeQuery·p0.00:   1965.031 ms/op
                 executeQuery·p0.50:   1965.031 ms/op
                 executeQuery·p0.90:   1965.031 ms/op
                 executeQuery·p0.95:   1965.031 ms/op
                 executeQuery·p0.99:   1965.031 ms/op
                 executeQuery·p0.999:  1965.031 ms/op
                 executeQuery·p0.9999: 1965.031 ms/op
                 executeQuery·p1.00:   1965.031 ms/op

Iteration   3: 1946.157 ms/op
                 executeQuery·p0.00:   1946.157 ms/op
                 executeQuery·p0.50:   1946.157 ms/op
                 executeQuery·p0.90:   1946.157 ms/op
                 executeQuery·p0.95:   1946.157 ms/op
                 executeQuery·p0.99:   1946.157 ms/op
                 executeQuery·p0.999:  1946.157 ms/op
                 executeQuery·p0.9999: 1946.157 ms/op
                 executeQuery·p1.00:   1946.157 ms/op

Iteration   4: 1954.546 ms/op
                 executeQuery·p0.00:   1954.546 ms/op
                 executeQuery·p0.50:   1954.546 ms/op
                 executeQuery·p0.90:   1954.546 ms/op
                 executeQuery·p0.95:   1954.546 ms/op
                 executeQuery·p0.99:   1954.546 ms/op
                 executeQuery·p0.999:  1954.546 ms/op
                 executeQuery·p0.9999: 1954.546 ms/op
                 executeQuery·p1.00:   1954.546 ms/op

Iteration   5: 1952.449 ms/op
                 executeQuery·p0.00:   1952.449 ms/op
                 executeQuery·p0.50:   1952.449 ms/op
                 executeQuery·p0.90:   1952.449 ms/op
                 executeQuery·p0.95:   1952.449 ms/op
                 executeQuery·p0.99:   1952.449 ms/op
                 executeQuery·p0.999:  1952.449 ms/op
                 executeQuery·p0.9999: 1952.449 ms/op
                 executeQuery·p1.00:   1952.449 ms/op


# Run progress: 2.22% complete, ETA 09:01:48
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

2344.616 ms/op
# Warmup Iteration   2: 2252.341 ms/op
# Warmup Iteration   3: 1986.003 ms/op
# Warmup Iteration   4: 2025.849 ms/op
# Warmup Iteration   5: 2021.655 ms/op
Iteration   1: 2044.723 ms/op
                 executeQuery·p0.00:   2044.723 ms/op
                 executeQuery·p0.50:   2044.723 ms/op
                 executeQuery·p0.90:   2044.723 ms/op
                 executeQuery·p0.95:   2044.723 ms/op
                 executeQuery·p0.99:   2044.723 ms/op
                 executeQuery·p0.999:  2044.723 ms/op
                 executeQuery·p0.9999: 2044.723 ms/op
                 executeQuery·p1.00:   2044.723 ms/op

Iteration   2: 1965.031 ms/op
                 executeQuery·p0.00:   1965.031 ms/op
                 executeQuery·p0.50:   1965.031 ms/op
                 executeQuery·p0.90:   1965.031 ms/op
                 executeQuery·p0.95:   1965.031 ms/op
                 executeQuery·p0.99:   1965.031 ms/op
                 executeQuery·p0.999:  1965.031 ms/op
                 executeQuery·p0.9999: 1965.031 ms/op
                 executeQuery·p1.00:   1965.031 ms/op

Iteration   3: 1979.711 ms/op
                 executeQuery·p0.00:   1979.711 ms/op
                 executeQuery·p0.50:   1979.711 ms/op
                 executeQuery·p0.90:   1979.711 ms/op
                 executeQuery·p0.95:   1979.711 ms/op
                 executeQuery·p0.99:   1979.711 ms/op
                 executeQuery·p0.999:  1979.711 ms/op
                 executeQuery·p0.9999: 1979.711 ms/op
                 executeQuery·p1.00:   1979.711 ms/op

Iteration   4: 1958.740 ms/op
                 executeQuery·p0.00:   1958.740 ms/op
                 executeQuery·p0.50:   1958.740 ms/op
                 executeQuery·p0.90:   1958.740 ms/op
                 executeQuery·p0.95:   1958.740 ms/op
                 executeQuery·p0.99:   1958.740 ms/op
                 executeQuery·p0.999:  1958.740 ms/op
                 executeQuery·p0.9999: 1958.740 ms/op
                 executeQuery·p1.00:   1958.740 ms/op

Iteration   5: 1958.740 ms/op
                 executeQuery·p0.00:   1958.740 ms/op
                 executeQuery·p0.50:   1958.740 ms/op
                 executeQuery·p0.90:   1958.740 ms/op
                 executeQuery·p0.95:   1958.740 ms/op
                 executeQuery·p0.99:   1958.740 ms/op
                 executeQuery·p0.999:  1958.740 ms/op
                 executeQuery·p0.9999: 1958.740 ms/op
                 executeQuery·p1.00:   1958.740 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =   1973.420 ±(99.9%) 46.478 ms/op

  Histogram, ms/op:
    [1940.000, 1950.000) = 1 
    [1950.000, 1960.000) = 4 
    [1960.000, 1970.000) = 2 
    [1970.000, 1980.000) = 1 
    [1980.000, 1990.000) = 0 
    [1990.000, 2000.000) = 0 
    [2000.000, 2010.000) = 1 
    [2010.000, 2020.000) = 0 
    [2020.000, 2030.000) = 0 
    [2030.000, 2040.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   1946.157 ms/op
     p(50.0000) =   1961.886 ms/op
     p(90.0000) =   2041.158 ms/op
     p(95.0000) =   2044.723 ms/op
     p(99.0000) =   2044.723 ms/op
     p(99.9000) =   2044.723 ms/op
     p(99.9900) =   2044.723 ms/op
     p(99.9990) =   2044.723 ms/op
     p(99.9999) =   2044.723 ms/op
    p(100.0000) =   2044.723 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288)

# Run progress: 2.53% complete, ETA 09:11:26
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5637.145 ms/op
# Warmup Iteration   2: 4974.445 ms/op
# Warmup Iteration   3: 5192.548 ms/op
# Warmup Iteration   4: 4831.838 ms/op
# Warmup Iteration   5: 4865.393 ms/op
Iteration   1: 5091.885 ms/op
                 executeQuery·p0.00:   5091.885 ms/op
                 executeQuery·p0.50:   5091.885 ms/op
                 executeQuery·p0.90:   5091.885 ms/op
                 executeQuery·p0.95:   5091.885 ms/op
                 executeQuery·p0.99:   5091.885 ms/op
                 executeQuery·p0.999:  5091.885 ms/op
                 executeQuery·p0.9999: 5091.885 ms/op
                 executeQuery·p1.00:   5091.885 ms/op

Iteration   2: 4831.838 ms/op
                 executeQuery·p0.00:   4831.838 ms/op
                 executeQuery·p0.50:   4831.838 ms/op
                 executeQuery·p0.90:   4831.838 ms/op
                 executeQuery·p0.95:   4831.838 ms/op
                 executeQuery·p0.99:   4831.838 ms/op
                 executeQuery·p0.999:  4831.838 ms/op
                 executeQuery·p0.9999: 4831.838 ms/op
                 executeQuery·p1.00:   4831.838 ms/op

Iteration   3: 5075.108 ms/op
                 executeQuery·p0.00:   5075.108 ms/op
                 executeQuery·p0.50:   5075.108 ms/op
                 executeQuery·p0.90:   5075.108 ms/op
                 executeQuery·p0.95:   5075.108 ms/op
                 executeQuery·p0.99:   5075.108 ms/op
                 executeQuery·p0.999:  5075.108 ms/op
                 executeQuery·p0.9999: 5075.108 ms/op
                 executeQuery·p1.00:   5075.108 ms/op

Iteration   4: 4638.900 ms/op
                 executeQuery·p0.00:   4638.900 ms/op
                 executeQuery·p0.50:   4638.900 ms/op
                 executeQuery·p0.90:   4638.900 ms/op
                 executeQuery·p0.95:   4638.900 ms/op
                 executeQuery·p0.99:   4638.900 ms/op
                 executeQuery·p0.999:  4638.900 ms/op
                 executeQuery·p0.9999: 4638.900 ms/op
                 executeQuery·p1.00:   4638.900 ms/op

Iteration   5: 4714.398 ms/op
                 executeQuery·p0.00:   4714.398 ms/op
                 executeQuery·p0.50:   4714.398 ms/op
                 executeQuery·p0.90:   4714.398 ms/op
                 executeQuery·p0.95:   4714.398 ms/op
                 executeQuery·p0.99:   4714.398 ms/op
                 executeQuery·p0.999:  4714.398 ms/op
                 executeQuery·p0.9999: 4714.398 ms/op
                 executeQuery·p1.00:   4714.398 ms/op


# Run progress: 2.85% complete, ETA 12:00:30
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5452.595 ms/op
# Warmup Iteration   2: 4982.833 ms/op
# Warmup Iteration   3: 5217.714 ms/op
# Warmup Iteration   4: 4831.838 ms/op
# Warmup Iteration   5: 4882.170 ms/op
Iteration   1: 5100.274 ms/op
                 executeQuery·p0.00:   5100.274 ms/op
                 executeQuery·p0.50:   5100.274 ms/op
                 executeQuery·p0.90:   5100.274 ms/op
                 executeQuery·p0.95:   5100.274 ms/op
                 executeQuery·p0.99:   5100.274 ms/op
                 executeQuery·p0.999:  5100.274 ms/op
                 executeQuery·p0.9999: 5100.274 ms/op
                 executeQuery·p1.00:   5100.274 ms/op

Iteration   2: 4840.227 ms/op
                 executeQuery·p0.00:   4840.227 ms/op
                 executeQuery·p0.50:   4840.227 ms/op
                 executeQuery·p0.90:   4840.227 ms/op
                 executeQuery·p0.95:   4840.227 ms/op
                 executeQuery·p0.99:   4840.227 ms/op
                 executeQuery·p0.999:  4840.227 ms/op
                 executeQuery·p0.9999: 4840.227 ms/op
                 executeQuery·p1.00:   4840.227 ms/op

Iteration   3: 5091.885 ms/op
                 executeQuery·p0.00:   5091.885 ms/op
                 executeQuery·p0.50:   5091.885 ms/op
                 executeQuery·p0.90:   5091.885 ms/op
                 executeQuery·p0.95:   5091.885 ms/op
                 executeQuery·p0.99:   5091.885 ms/op
                 executeQuery·p0.999:  5091.885 ms/op
                 executeQuery·p0.9999: 5091.885 ms/op
                 executeQuery·p1.00:   5091.885 ms/op

Iteration   4: 4840.227 ms/op
                 executeQuery·p0.00:   4840.227 ms/op
                 executeQuery·p0.50:   4840.227 ms/op
                 executeQuery·p0.90:   4840.227 ms/op
                 executeQuery·p0.95:   4840.227 ms/op
                 executeQuery·p0.99:   4840.227 ms/op
                 executeQuery·p0.999:  4840.227 ms/op
                 executeQuery·p0.9999: 4840.227 ms/op
                 executeQuery·p1.00:   4840.227 ms/op

Iteration   5: 4840.227 ms/op
                 executeQuery·p0.00:   4840.227 ms/op
                 executeQuery·p0.50:   4840.227 ms/op
                 executeQuery·p0.90:   4840.227 ms/op
                 executeQuery·p0.95:   4840.227 ms/op
                 executeQuery·p0.99:   4840.227 ms/op
                 executeQuery·p0.999:  4840.227 ms/op
                 executeQuery·p0.9999: 4840.227 ms/op
                 executeQuery·p1.00:   4840.227 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =   4906.497 ±(99.9%) 257.941 ms/op

  Histogram, ms/op:
    [4600.000, 4650.000) = 1 
    [4650.000, 4700.000) = 0 
    [4700.000, 4750.000) = 1 
    [4750.000, 4800.000) = 0 
    [4800.000, 4850.000) = 4 
    [4850.000, 4900.000) = 0 
    [4900.000, 4950.000) = 0 
    [4950.000, 5000.000) = 0 
    [5000.000, 5050.000) = 0 
    [5050.000, 5100.000) = 3 
    [5100.000, 5150.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4638.900 ms/op
     p(50.0000) =   4840.227 ms/op
     p(90.0000) =   5099.435 ms/op
     p(95.0000) =   5100.274 ms/op
     p(99.0000) =   5100.274 ms/op
     p(99.9000) =   5100.274 ms/op
     p(99.9900) =   5100.274 ms/op
     p(99.9990) =   5100.274 ms/op
     p(99.9999) =   5100.274 ms/op
    p(100.0000) =   5100.274 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2)

# Run progress: 3.16% complete, ETA 14:16:09
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6345.982 ms/op
# Warmup Iteration   2: 3269.460 ±(99.9%) 991.289 ms/op
# Warmup Iteration   3: 3232.760 ±(99.9%) 685.091 ms/op
# Warmup Iteration   4: 3220.177 ±(99.9%) 13.552 ms/op
# Warmup Iteration   5: 3263.169 ±(99.9%) 579.196 ms/op
Iteration   1: 3224.371 ±(99.9%) 40.655 ms/op
                 executeQuery·p0.00:   3217.031 ms/op
                 executeQuery·p0.50:   3225.420 ms/op
                 executeQuery·p0.90:   3229.614 ms/op
                 executeQuery·p0.95:   3229.614 ms/op
                 executeQuery·p0.99:   3229.614 ms/op
                 executeQuery·p0.999:  3229.614 ms/op
                 executeQuery·p0.9999: 3229.614 ms/op
                 executeQuery·p1.00:   3229.614 ms/op

Iteration   2: 3171.942 ±(99.9%) 34.105 ms/op
                 executeQuery·p0.00:   3166.700 ms/op
                 executeQuery·p0.50:   3170.894 ms/op
                 executeQuery·p0.90:   3179.282 ms/op
                 executeQuery·p0.95:   3179.282 ms/op
                 executeQuery·p0.99:   3179.282 ms/op
                 executeQuery·p0.999:  3179.282 ms/op
                 executeQuery·p0.9999: 3179.282 ms/op
                 executeQuery·p1.00:   3179.282 ms/op

Iteration   3: 3225.420 ±(99.9%) 58.550 ms/op
                 executeQuery·p0.00:   3217.031 ms/op
                 executeQuery·p0.50:   3223.323 ms/op
                 executeQuery·p0.90:   3238.003 ms/op
                 executeQuery·p0.95:   3238.003 ms/op
                 executeQuery·p0.99:   3238.003 ms/op
                 executeQuery·p0.999:  3238.003 ms/op
                 executeQuery·p0.9999: 3238.003 ms/op
                 executeQuery·p1.00:   3238.003 ms/op

Iteration   4: 3225.420 ±(99.9%) 101.412 ms/op
                 executeQuery·p0.00:   3208.643 ms/op
                 executeQuery·p0.50:   3223.323 ms/op
                 executeQuery·p0.90:   3246.391 ms/op
                 executeQuery·p0.95:   3246.391 ms/op
                 executeQuery·p0.99:   3246.391 ms/op
                 executeQuery·p0.999:  3246.391 ms/op
                 executeQuery·p0.9999: 3246.391 ms/op
                 executeQuery·p1.00:   3246.391 ms/op

Iteration   5: 3215.983 ±(99.9%) 80.933 ms/op
                 executeQuery·p0.00:   3204.448 ms/op
                 executeQuery·p0.50:   3212.837 ms/op
                 executeQuery·p0.90:   3233.808 ms/op
                 executeQuery·p0.95:   3233.808 ms/op
                 executeQuery·p0.99:   3233.808 ms/op
                 executeQuery·p0.999:  3233.808 ms/op
                 executeQuery·p0.9999: 3233.808 ms/op
                 executeQuery·p1.00:   3233.808 ms/op


# Run progress: 3.48% complete, ETA 13:56:10
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3164.602 ±(99.9%) 5537.554 ms/op
# Warmup Iteration   2: 3228.566 ±(99.9%) 34.105 ms/op
# Warmup Iteration   3: 3223.323 ±(99.9%) 46.945 ms/op
# Warmup Iteration   4: 3229.614 ±(99.9%) 38.330 ms/op
# Warmup Iteration   5: 3224.371 ±(99.9%) 13.552 ms/op
Iteration   1: 3224.371 ±(99.9%) 25.950 ms/op
                 executeQuery·p0.00:   3221.225 ms/op
                 executeQuery·p0.50:   3223.323 ms/op
                 executeQuery·p0.90:   3229.614 ms/op
                 executeQuery·p0.95:   3229.614 ms/op
                 executeQuery·p0.99:   3229.614 ms/op
                 executeQuery·p0.999:  3229.614 ms/op
                 executeQuery·p0.9999: 3229.614 ms/op
                 executeQuery·p1.00:   3229.614 ms/op

Iteration   2: 3234.857 ±(99.9%) 140.617 ms/op
                 executeQuery·p0.00:   3221.225 ms/op
                 executeQuery·p0.50:   3225.420 ms/op
                 executeQuery·p0.90:   3267.363 ms/op
                 executeQuery·p0.95:   3267.363 ms/op
                 executeQuery·p0.99:   3267.363 ms/op
                 executeQuery·p0.999:  3267.363 ms/op
                 executeQuery·p0.9999: 3267.363 ms/op
                 executeQuery·p1.00:   3267.363 ms/op

Iteration   3: 3224.371 ±(99.9%) 60.098 ms/op
                 executeQuery·p0.00:   3217.031 ms/op
                 executeQuery·p0.50:   3221.225 ms/op
                 executeQuery·p0.90:   3238.003 ms/op
                 executeQuery·p0.95:   3238.003 ms/op
                 executeQuery·p0.99:   3238.003 ms/op
                 executeQuery·p0.999:  3238.003 ms/op
                 executeQuery·p0.9999: 3238.003 ms/op
                 executeQuery·p1.00:   3238.003 ms/op

Iteration   4: 3249.537 ±(99.9%) 365.898 ms/op
                 executeQuery·p0.00:   3221.225 ms/op
                 executeQuery·p0.50:   3221.225 ms/op
                 executeQuery·p0.90:   3334.472 ms/op
                 executeQuery·p0.95:   3334.472 ms/op
                 executeQuery·p0.99:   3334.472 ms/op
                 executeQuery·p0.999:  3334.472 ms/op
                 executeQuery·p0.9999: 3334.472 ms/op
                 executeQuery·p1.00:   3334.472 ms/op

Iteration   5: 3217.031 ±(99.9%) 22.130 ms/op
                 executeQuery·p0.00:   3212.837 ms/op
                 executeQuery·p0.50:   3217.031 ms/op
                 executeQuery·p0.90:   3221.225 ms/op
                 executeQuery·p0.95:   3221.225 ms/op
                 executeQuery·p0.99:   3221.225 ms/op
                 executeQuery·p0.999:  3221.225 ms/op
                 executeQuery·p0.9999: 3221.225 ms/op
                 executeQuery·p1.00:   3221.225 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 40
  mean =   3221.330 ±(99.9%) 14.842 ms/op

  Histogram, ms/op:
    [3100.000, 3125.000) = 0 
    [3125.000, 3150.000) = 0 
    [3150.000, 3175.000) = 3 
    [3175.000, 3200.000) = 1 
    [3200.000, 3225.000) = 22 
    [3225.000, 3250.000) = 12 
    [3250.000, 3275.000) = 1 
    [3275.000, 3300.000) = 0 
    [3300.000, 3325.000) = 0 
    [3325.000, 3350.000) = 1 
    [3350.000, 3375.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   3166.700 ms/op
     p(50.0000) =   3221.225 ms/op
     p(90.0000) =   3238.003 ms/op
     p(95.0000) =   3266.314 ms/op
     p(99.0000) =   3334.472 ms/op
     p(99.9000) =   3334.472 ms/op
     p(99.9900) =   3334.472 ms/op
     p(99.9990) =   3334.472 ms/op
     p(99.9999) =   3334.472 ms/op
    p(100.0000) =   3334.472 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16)

# Run progress: 3.80% complete, ETA 13:39:08
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6656.360 ms/op
# Warmup Iteration   2: 4577.384 ±(99.9%) 2198.306 ms/op
# Warmup Iteration   3: 4543.829 ±(99.9%) 441.787 ms/op
# Warmup Iteration   4: 4535.441 ±(99.9%) 176.715 ms/op
# Warmup Iteration   5: 4535.441 ±(99.9%) 176.715 ms/op
Iteration   1: 4535.441 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4529.848 ms/op
                 executeQuery·p0.50:   4538.237 ms/op
                 executeQuery·p0.90:   4538.237 ms/op
                 executeQuery·p0.95:   4538.237 ms/op
                 executeQuery·p0.99:   4538.237 ms/op
                 executeQuery·p0.999:  4538.237 ms/op
                 executeQuery·p0.9999: 4538.237 ms/op
                 executeQuery·p1.00:   4538.237 ms/op

Iteration   2: 4543.829 ±(99.9%) 176.715 ms/op
                 executeQuery·p0.00:   4538.237 ms/op
                 executeQuery·p0.50:   4538.237 ms/op
                 executeQuery·p0.90:   4555.014 ms/op
                 executeQuery·p0.95:   4555.014 ms/op
                 executeQuery·p0.99:   4555.014 ms/op
                 executeQuery·p0.999:  4555.014 ms/op
                 executeQuery·p0.9999: 4555.014 ms/op
                 executeQuery·p1.00:   4555.014 ms/op

Iteration   3: 4543.829 ±(99.9%) 176.715 ms/op
                 executeQuery·p0.00:   4538.237 ms/op
                 executeQuery·p0.50:   4538.237 ms/op
                 executeQuery·p0.90:   4555.014 ms/op
                 executeQuery·p0.95:   4555.014 ms/op
                 executeQuery·p0.99:   4555.014 ms/op
                 executeQuery·p0.999:  4555.014 ms/op
                 executeQuery·p0.9999: 4555.014 ms/op
                 executeQuery·p1.00:   4555.014 ms/op

Iteration   4: 4543.829 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4538.237 ms/op
                 executeQuery·p0.50:   4546.626 ms/op
                 executeQuery·p0.90:   4546.626 ms/op
                 executeQuery·p0.95:   4546.626 ms/op
                 executeQuery·p0.99:   4546.626 ms/op
                 executeQuery·p0.999:  4546.626 ms/op
                 executeQuery·p0.9999: 4546.626 ms/op
                 executeQuery·p1.00:   4546.626 ms/op

Iteration   5: 4521.460 ±(99.9%) 551.792 ms/op
                 executeQuery·p0.00:   4487.905 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4546.626 ms/op
                 executeQuery·p0.95:   4546.626 ms/op
                 executeQuery·p0.99:   4546.626 ms/op
                 executeQuery·p0.999:  4546.626 ms/op
                 executeQuery·p0.9999: 4546.626 ms/op
                 executeQuery·p1.00:   4546.626 ms/op


# Run progress: 4.11% complete, ETA 13:27:10
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

4445.962 ±(99.9%) 7828.981 ms/op
# Warmup Iteration   2: 4577.384 ±(99.9%) 491.953 ms/op
# Warmup Iteration   3: 4546.626 ±(99.9%) 153.039 ms/op
# Warmup Iteration   4: 4543.829 ±(99.9%) 88.357 ms/op
# Warmup Iteration   5: 4549.422 ±(99.9%) 88.357 ms/op
Iteration   1: 4546.626 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   4546.626 ms/op
                 executeQuery·p0.50:   4546.626 ms/op
                 executeQuery·p0.90:   4546.626 ms/op
                 executeQuery·p0.95:   4546.626 ms/op
                 executeQuery·p0.99:   4546.626 ms/op
                 executeQuery·p0.999:  4546.626 ms/op
                 executeQuery·p0.9999: 4546.626 ms/op
                 executeQuery·p1.00:   4546.626 ms/op

Iteration   2: 4546.626 ±(99.9%) 153.039 ms/op
                 executeQuery·p0.00:   4538.237 ms/op
                 executeQuery·p0.50:   4546.626 ms/op
                 executeQuery·p0.90:   4555.014 ms/op
                 executeQuery·p0.95:   4555.014 ms/op
                 executeQuery·p0.99:   4555.014 ms/op
                 executeQuery·p0.999:  4555.014 ms/op
                 executeQuery·p0.9999: 4555.014 ms/op
                 executeQuery·p1.00:   4555.014 ms/op

Iteration   3: 4566.199 ±(99.9%) 318.577 ms/op
                 executeQuery·p0.00:   4546.626 ms/op
                 executeQuery·p0.50:   4571.791 ms/op
                 executeQuery·p0.90:   4580.180 ms/op
                 executeQuery·p0.95:   4580.180 ms/op
                 executeQuery·p0.99:   4580.180 ms/op
                 executeQuery·p0.999:  4580.180 ms/op
                 executeQuery·p0.9999: 4580.180 ms/op
                 executeQuery·p1.00:   4580.180 ms/op

Iteration   4: 4557.810 ±(99.9%) 176.715 ms/op
                 executeQuery·p0.00:   4546.626 ms/op
                 executeQuery·p0.50:   4563.403 ms/op
                 executeQuery·p0.90:   4563.403 ms/op
                 executeQuery·p0.95:   4563.403 ms/op
                 executeQuery·p0.99:   4563.403 ms/op
                 executeQuery·p0.999:  4563.403 ms/op
                 executeQuery·p0.9999: 4563.403 ms/op
                 executeQuery·p1.00:   4563.403 ms/op

Iteration   5: 4532.645 ±(99.9%) 441.787 ms/op
                 executeQuery·p0.00:   4504.682 ms/op
                 executeQuery·p0.50:   4546.626 ms/op
                 executeQuery·p0.90:   4546.626 ms/op
                 executeQuery·p0.95:   4546.626 ms/op
                 executeQuery·p0.99:   4546.626 ms/op
                 executeQuery·p0.999:  4546.626 ms/op
                 executeQuery·p0.9999: 4546.626 ms/op
                 executeQuery·p1.00:   4546.626 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 30
  mean =   4543.829 ±(99.9%) 11.527 ms/op

  Histogram, ms/op:
    [4480.000, 4490.000) = 1 
    [4490.000, 4500.000) = 0 
    [4500.000, 4510.000) = 1 
    [4510.000, 4520.000) = 0 
    [4520.000, 4530.000) = 2 
    [4530.000, 4540.000) = 8 
    [4540.000, 4550.000) = 11 
    [4550.000, 4560.000) = 3 
    [4560.000, 4570.000) = 2 
    [4570.000, 4580.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4487.905 ms/op
     p(50.0000) =   4546.626 ms/op
     p(90.0000) =   4563.403 ms/op
     p(95.0000) =   4575.566 ms/op
     p(99.0000) =   4580.180 ms/op
     p(99.9000) =   4580.180 ms/op
     p(99.9900) =   4580.180 ms/op
     p(99.9990) =   4580.180 ms/op
     p(99.9999) =   4580.180 ms/op
    p(100.0000) =   4580.180 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192)

# Run progress: 4.43% complete, ETA 13:16:42
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

7759.462 ms/op
# Warmup Iteration   2: 6337.593 ms/op
# Warmup Iteration   3: 6488.588 ms/op
# Warmup Iteration   4: 6530.531 ms/op
# Warmup Iteration   5: 6505.366 ms/op
Iteration   1: 6484.394 ms/op
                 executeQuery·p0.00:   6400.508 ms/op
                 executeQuery·p0.50:   6484.394 ms/op
                 executeQuery·p0.90:   6568.280 ms/op
                 executeQuery·p0.95:   6568.280 ms/op
                 executeQuery·p0.99:   6568.280 ms/op
                 executeQuery·p0.999:  6568.280 ms/op
                 executeQuery·p0.9999: 6568.280 ms/op
                 executeQuery·p1.00:   6568.280 ms/op

Iteration   2: 6559.891 ms/op
                 executeQuery·p0.00:   6543.114 ms/op
                 executeQuery·p0.50:   6559.891 ms/op
                 executeQuery·p0.90:   6576.669 ms/op
                 executeQuery·p0.95:   6576.669 ms/op
                 executeQuery·p0.99:   6576.669 ms/op
                 executeQuery·p0.999:  6576.669 ms/op
                 executeQuery·p0.9999: 6576.669 ms/op
                 executeQuery·p1.00:   6576.669 ms/op

Iteration   3: 6530.531 ms/op
                 executeQuery·p0.00:   6459.228 ms/op
                 executeQuery·p0.50:   6530.531 ms/op
                 executeQuery·p0.90:   6601.834 ms/op
                 executeQuery·p0.95:   6601.834 ms/op
                 executeQuery·p0.99:   6601.834 ms/op
                 executeQuery·p0.999:  6601.834 ms/op
                 executeQuery·p0.9999: 6601.834 ms/op
                 executeQuery·p1.00:   6601.834 ms/op

Iteration   4: 6593.446 ms/op
                 executeQuery·p0.00:   6559.891 ms/op
                 executeQuery·p0.50:   6593.446 ms/op
                 executeQuery·p0.90:   6627.000 ms/op
                 executeQuery·p0.95:   6627.000 ms/op
                 executeQuery·p0.99:   6627.000 ms/op
                 executeQuery·p0.999:  6627.000 ms/op
                 executeQuery·p0.9999: 6627.000 ms/op
                 executeQuery·p1.00:   6627.000 ms/op

Iteration   5: 6467.617 ms/op
                 executeQuery·p0.00:   6425.674 ms/op
                 executeQuery·p0.50:   6467.617 ms/op
                 executeQuery·p0.90:   6509.560 ms/op
                 executeQuery·p0.95:   6509.560 ms/op
                 executeQuery·p0.99:   6509.560 ms/op
                 executeQuery·p0.999:  6509.560 ms/op
                 executeQuery·p0.9999: 6509.560 ms/op
                 executeQuery·p1.00:   6509.560 ms/op


# Run progress: 4.75% complete, ETA 13:06:07
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6534.726 ms/op
# Warmup Iteration   2: 6312.428 ms/op
# Warmup Iteration   3: 6576.669 ms/op
# Warmup Iteration   4: 6434.062 ms/op
# Warmup Iteration   5: 6568.280 ms/op
Iteration   1: 6564.086 ms/op
                 executeQuery·p0.00:   6408.897 ms/op
                 executeQuery·p0.50:   6564.086 ms/op
                 executeQuery·p0.90:   6719.275 ms/op
                 executeQuery·p0.95:   6719.275 ms/op
                 executeQuery·p0.99:   6719.275 ms/op
                 executeQuery·p0.999:  6719.275 ms/op
                 executeQuery·p0.9999: 6719.275 ms/op
                 executeQuery·p1.00:   6719.275 ms/op

Iteration   2: 6559.891 ms/op
                 executeQuery·p0.00:   6551.503 ms/op
                 executeQuery·p0.50:   6559.891 ms/op
                 executeQuery·p0.90:   6568.280 ms/op
                 executeQuery·p0.95:   6568.280 ms/op
                 executeQuery·p0.99:   6568.280 ms/op
                 executeQuery·p0.999:  6568.280 ms/op
                 executeQuery·p0.9999: 6568.280 ms/op
                 executeQuery·p1.00:   6568.280 ms/op

Iteration   3: 6501.171 ms/op
                 executeQuery·p0.00:   6434.062 ms/op
                 executeQuery·p0.50:   6501.171 ms/op
                 executeQuery·p0.90:   6568.280 ms/op
                 executeQuery·p0.95:   6568.280 ms/op
                 executeQuery·p0.99:   6568.280 ms/op
                 executeQuery·p0.999:  6568.280 ms/op
                 executeQuery·p0.9999: 6568.280 ms/op
                 executeQuery·p1.00:   6568.280 ms/op

Iteration   4: 6559.891 ms/op
                 executeQuery·p0.00:   6551.503 ms/op
                 executeQuery·p0.50:   6559.891 ms/op
                 executeQuery·p0.90:   6568.280 ms/op
                 executeQuery·p0.95:   6568.280 ms/op
                 executeQuery·p0.99:   6568.280 ms/op
                 executeQuery·p0.999:  6568.280 ms/op
                 executeQuery·p0.9999: 6568.280 ms/op
                 executeQuery·p1.00:   6568.280 ms/op

Iteration   5: 6530.531 ms/op
                 executeQuery·p0.00:   6434.062 ms/op
                 executeQuery·p0.50:   6530.531 ms/op
                 executeQuery·p0.90:   6627.000 ms/op
                 executeQuery·p0.95:   6627.000 ms/op
                 executeQuery·p0.99:   6627.000 ms/op
                 executeQuery·p0.999:  6627.000 ms/op
                 executeQuery·p0.9999: 6627.000 ms/op
                 executeQuery·p1.00:   6627.000 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 20
  mean =   6535.145 ±(99.9%) 73.320 ms/op

  Histogram, ms/op:
    [6400.000, 6425.000) = 2 
    [6425.000, 6450.000) = 3 
    [6450.000, 6475.000) = 1 
    [6475.000, 6500.000) = 0 
    [6500.000, 6525.000) = 1 
    [6525.000, 6550.000) = 1 
    [6550.000, 6575.000) = 7 
    [6575.000, 6600.000) = 1 
    [6600.000, 6625.000) = 1 
    [6625.000, 6650.000) = 2 
    [6650.000, 6675.000) = 0 
    [6675.000, 6700.000) = 0 
    [6700.000, 6725.000) = 1 
    [6725.000, 6750.000) = 0 
    [6750.000, 6775.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   6400.508 ms/op
     p(50.0000) =   6555.697 ms/op
     p(90.0000) =   6627.000 ms/op
     p(95.0000) =   6714.661 ms/op
     p(99.0000) =   6719.275 ms/op
     p(99.9000) =   6719.275 ms/op
     p(99.9900) =   6719.275 ms/op
     p(99.9990) =   6719.275 ms/op
     p(99.9999) =   6719.275 ms/op
    p(100.0000) =   6719.275 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144)

# Run progress: 5.06% complete, ETA 12:55:52
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

25467.814 ms/op
# Warmup Iteration   2: 20468.204 ms/op
# Warmup Iteration   3: 19797.115 ms/op
# Warmup Iteration   4: 20401.095 ms/op
# Warmup Iteration   5: 20736.639 ms/op
Iteration   1: 22515.024 ms/op
                 executeQuery·p0.00:   22515.024 ms/op
                 executeQuery·p0.50:   22515.024 ms/op
                 executeQuery·p0.90:   22515.024 ms/op
                 executeQuery·p0.95:   22515.024 ms/op
                 executeQuery·p0.99:   22515.024 ms/op
                 executeQuery·p0.999:  22515.024 ms/op
                 executeQuery·p0.9999: 22515.024 ms/op
                 executeQuery·p1.00:   22515.024 ms/op

Iteration   2: 20568.867 ms/op
                 executeQuery·p0.00:   20568.867 ms/op
                 executeQuery·p0.50:   20568.867 ms/op
                 executeQuery·p0.90:   20568.867 ms/op
                 executeQuery·p0.95:   20568.867 ms/op
                 executeQuery·p0.99:   20568.867 ms/op
                 executeQuery·p0.999:  20568.867 ms/op
                 executeQuery·p0.9999: 20568.867 ms/op
                 executeQuery·p1.00:   20568.867 ms/op

Iteration   3: 20031.996 ms/op
                 executeQuery·p0.00:   20031.996 ms/op
                 executeQuery·p0.50:   20031.996 ms/op
                 executeQuery·p0.90:   20031.996 ms/op
                 executeQuery·p0.95:   20031.996 ms/op
                 executeQuery·p0.99:   20031.996 ms/op
                 executeQuery·p0.999:  20031.996 ms/op
                 executeQuery·p0.9999: 20031.996 ms/op
                 executeQuery·p1.00:   20031.996 ms/op

Iteration   4: 20837.302 ms/op
                 executeQuery·p0.00:   20837.302 ms/op
                 executeQuery·p0.50:   20837.302 ms/op
                 executeQuery·p0.90:   20837.302 ms/op
                 executeQuery·p0.95:   20837.302 ms/op
                 executeQuery·p0.99:   20837.302 ms/op
                 executeQuery·p0.999:  20837.302 ms/op
                 executeQuery·p0.9999: 20837.302 ms/op
                 executeQuery·p1.00:   20837.302 ms/op

Iteration   5: 20434.649 ms/op
                 executeQuery·p0.00:   20434.649 ms/op
                 executeQuery·p0.50:   20434.649 ms/op
                 executeQuery·p0.90:   20434.649 ms/op
                 executeQuery·p0.95:   20434.649 ms/op
                 executeQuery·p0.99:   20434.649 ms/op
                 executeQuery·p0.999:  20434.649 ms/op
                 executeQuery·p0.9999: 20434.649 ms/op
                 executeQuery·p1.00:   20434.649 ms/op


# Run progress: 5.38% complete, ETA 13:35:46
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

22817.014 ms/op
# Warmup Iteration   2: 20300.431 ms/op
# Warmup Iteration   3: 19562.234 ms/op
# Warmup Iteration   4: 19528.679 ms/op
# Warmup Iteration   5: 20300.431 ms/op
Iteration   1: 24226.300 ms/op
                 executeQuery·p0.00:   24226.300 ms/op
                 executeQuery·p0.50:   24226.300 ms/op
                 executeQuery·p0.90:   24226.300 ms/op
                 executeQuery·p0.95:   24226.300 ms/op
                 executeQuery·p0.99:   24226.300 ms/op
                 executeQuery·p0.999:  24226.300 ms/op
                 executeQuery·p0.9999: 24226.300 ms/op
                 executeQuery·p1.00:   24226.300 ms/op

Iteration   2: 22582.133 ms/op
                 executeQuery·p0.00:   22582.133 ms/op
                 executeQuery·p0.50:   22582.133 ms/op
                 executeQuery·p0.90:   22582.133 ms/op
                 executeQuery·p0.95:   22582.133 ms/op
                 executeQuery·p0.99:   22582.133 ms/op
                 executeQuery·p0.999:  22582.133 ms/op
                 executeQuery·p0.9999: 22582.133 ms/op
                 executeQuery·p1.00:   22582.133 ms/op

Iteration   3: 21877.490 ms/op
                 executeQuery·p0.00:   21877.490 ms/op
                 executeQuery·p0.50:   21877.490 ms/op
                 executeQuery·p0.90:   21877.490 ms/op
                 executeQuery·p0.95:   21877.490 ms/op
                 executeQuery·p0.99:   21877.490 ms/op
                 executeQuery·p0.999:  21877.490 ms/op
                 executeQuery·p0.9999: 21877.490 ms/op
                 executeQuery·p1.00:   21877.490 ms/op

Iteration   4: 20166.214 ms/op
                 executeQuery·p0.00:   20166.214 ms/op
                 executeQuery·p0.50:   20166.214 ms/op
                 executeQuery·p0.90:   20166.214 ms/op
                 executeQuery·p0.95:   20166.214 ms/op
                 executeQuery·p0.99:   20166.214 ms/op
                 executeQuery·p0.999:  20166.214 ms/op
                 executeQuery·p0.9999: 20166.214 ms/op
                 executeQuery·p1.00:   20166.214 ms/op

Iteration   5: 20132.659 ms/op
                 executeQuery·p0.00:   20132.659 ms/op
                 executeQuery·p0.50:   20132.659 ms/op
                 executeQuery·p0.90:   20132.659 ms/op
                 executeQuery·p0.95:   20132.659 ms/op
                 executeQuery·p0.99:   20132.659 ms/op
                 executeQuery·p0.999:  20132.659 ms/op
                 executeQuery·p0.9999: 20132.659 ms/op
                 executeQuery·p1.00:   20132.659 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  21337.263 ±(99.9%) 2123.575 ms/op

  Histogram, ms/op:
    [20000.000, 20500.000) = 4 
    [20500.000, 21000.000) = 2 
    [21000.000, 21500.000) = 0 
    [21500.000, 22000.000) = 1 
    [22000.000, 22500.000) = 0 
    [22500.000, 23000.000) = 2 
    [23000.000, 23500.000) = 0 
    [23500.000, 24000.000) = 0 
    [24000.000, 24500.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  20031.996 ms/op
     p(50.0000) =  20703.085 ms/op
     p(90.0000) =  24061.883 ms/op
     p(95.0000) =  24226.300 ms/op
     p(99.0000) =  24226.300 ms/op
     p(99.9000) =  24226.300 ms/op
     p(99.9900) =  24226.300 ms/op
     p(99.9990) =  24226.300 ms/op
     p(99.9999) =  24226.300 ms/op
    p(100.0000) =  24226.300 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288)

# Run progress: 5.70% complete, ETA 14:10:38
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

51271.172 ms/op
# Warmup Iteration   2: 51338.281 ms/op
# Warmup Iteration   3: 48385.491 ms/op
# Warmup Iteration   4: 46439.334 ms/op
# Warmup Iteration   5: 48653.926 ms/op
Iteration   1: 48318.382 ms/op
                 executeQuery·p0.00:   48318.382 ms/op
                 executeQuery·p0.50:   48318.382 ms/op
                 executeQuery·p0.90:   48318.382 ms/op
                 executeQuery·p0.95:   48318.382 ms/op
                 executeQuery·p0.99:   48318.382 ms/op
                 executeQuery·p0.999:  48318.382 ms/op
                 executeQuery·p0.9999: 48318.382 ms/op
                 executeQuery·p1.00:   48318.382 ms/op

Iteration   2: 47378.858 ms/op
                 executeQuery·p0.00:   47378.858 ms/op
                 executeQuery·p0.50:   47378.858 ms/op
                 executeQuery·p0.90:   47378.858 ms/op
                 executeQuery·p0.95:   47378.858 ms/op
                 executeQuery·p0.99:   47378.858 ms/op
                 executeQuery·p0.999:  47378.858 ms/op
                 executeQuery·p0.9999: 47378.858 ms/op
                 executeQuery·p1.00:   47378.858 ms/op

Iteration   3: 49727.668 ms/op
                 executeQuery·p0.00:   49727.668 ms/op
                 executeQuery·p0.50:   49727.668 ms/op
                 executeQuery·p0.90:   49727.668 ms/op
                 executeQuery·p0.95:   49727.668 ms/op
                 executeQuery·p0.99:   49727.668 ms/op
                 executeQuery·p0.999:  49727.668 ms/op
                 executeQuery·p0.9999: 49727.668 ms/op
                 executeQuery·p1.00:   49727.668 ms/op

Iteration   4: 47244.640 ms/op
                 executeQuery·p0.00:   47244.640 ms/op
                 executeQuery·p0.50:   47244.640 ms/op
                 executeQuery·p0.90:   47244.640 ms/op
                 executeQuery·p0.95:   47244.640 ms/op
                 executeQuery·p0.99:   47244.640 ms/op
                 executeQuery·p0.999:  47244.640 ms/op
                 executeQuery·p0.9999: 47244.640 ms/op
                 executeQuery·p1.00:   47244.640 ms/op

Iteration   5: 50734.301 ms/op
                 executeQuery·p0.00:   50734.301 ms/op
                 executeQuery·p0.50:   50734.301 ms/op
                 executeQuery·p0.90:   50734.301 ms/op
                 executeQuery·p0.95:   50734.301 ms/op
                 executeQuery·p0.99:   50734.301 ms/op
                 executeQuery·p0.999:  50734.301 ms/op
                 executeQuery·p0.9999: 50734.301 ms/op
                 executeQuery·p1.00:   50734.301 ms/op


# Run progress: 6.01% complete, ETA 17:03:58
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

49593.450 ms/op
# Warmup Iteration   2: 48251.273 ms/op
# Warmup Iteration   3: 50801.410 ms/op
# Warmup Iteration   4: 47177.531 ms/op
# Warmup Iteration   5: 50868.519 ms/op
Iteration   1: 48385.491 ms/op
                 executeQuery·p0.00:   48385.491 ms/op
                 executeQuery·p0.50:   48385.491 ms/op
                 executeQuery·p0.90:   48385.491 ms/op
                 executeQuery·p0.95:   48385.491 ms/op
                 executeQuery·p0.99:   48385.491 ms/op
                 executeQuery·p0.999:  48385.491 ms/op
                 executeQuery·p0.9999: 48385.491 ms/op
                 executeQuery·p1.00:   48385.491 ms/op

Iteration   2: 50600.083 ms/op
                 executeQuery·p0.00:   50600.083 ms/op
                 executeQuery·p0.50:   50600.083 ms/op
                 executeQuery·p0.90:   50600.083 ms/op
                 executeQuery·p0.95:   50600.083 ms/op
                 executeQuery·p0.99:   50600.083 ms/op
                 executeQuery·p0.999:  50600.083 ms/op
                 executeQuery·p0.9999: 50600.083 ms/op
                 executeQuery·p1.00:   50600.083 ms/op

Iteration   3: 48519.709 ms/op
                 executeQuery·p0.00:   48519.709 ms/op
                 executeQuery·p0.50:   48519.709 ms/op
                 executeQuery·p0.90:   48519.709 ms/op
                 executeQuery·p0.95:   48519.709 ms/op
                 executeQuery·p0.99:   48519.709 ms/op
                 executeQuery·p0.999:  48519.709 ms/op
                 executeQuery·p0.9999: 48519.709 ms/op
                 executeQuery·p1.00:   48519.709 ms/op

Iteration   4: 50868.519 ms/op
                 executeQuery·p0.00:   50868.519 ms/op
                 executeQuery·p0.50:   50868.519 ms/op
                 executeQuery·p0.90:   50868.519 ms/op
                 executeQuery·p0.95:   50868.519 ms/op
                 executeQuery·p0.99:   50868.519 ms/op
                 executeQuery·p0.999:  50868.519 ms/op
                 executeQuery·p0.9999: 50868.519 ms/op
                 executeQuery·p1.00:   50868.519 ms/op

Iteration   5: 50532.975 ms/op
                 executeQuery·p0.00:   50532.975 ms/op
                 executeQuery·p0.50:   50532.975 ms/op
                 executeQuery·p0.90:   50532.975 ms/op
                 executeQuery·p0.95:   50532.975 ms/op
                 executeQuery·p0.99:   50532.975 ms/op
                 executeQuery·p0.999:  50532.975 ms/op
                 executeQuery·p0.9999: 50532.975 ms/op
                 executeQuery·p1.00:   50532.975 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  49231.063 ±(99.9%) 2149.186 ms/op

  Histogram, ms/op:
    [47000.000, 47250.000) = 1 
    [47250.000, 47500.000) = 1 
    [47500.000, 47750.000) = 0 
    [47750.000, 48000.000) = 0 
    [48000.000, 48250.000) = 0 
    [48250.000, 48500.000) = 2 
    [48500.000, 48750.000) = 1 
    [48750.000, 49000.000) = 0 
    [49000.000, 49250.000) = 0 
    [49250.000, 49500.000) = 0 
    [49500.000, 49750.000) = 1 
    [49750.000, 50000.000) = 0 
    [50000.000, 50250.000) = 0 
    [50250.000, 50500.000) = 0 
    [50500.000, 50750.000) = 3 

  Percentiles, ms/op:
      p(0.0000) =  47244.640 ms/op
     p(50.0000) =  49123.688 ms/op
     p(90.0000) =  50855.097 ms/op
     p(95.0000) =  50868.519 ms/op
     p(99.0000) =  50868.519 ms/op
     p(99.9000) =  50868.519 ms/op
     p(99.9900) =  50868.519 ms/op
     p(99.9990) =  50868.519 ms/op
     p(99.9999) =  50868.519 ms/op
    p(100.0000) =  50868.519 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2)

# Run progress: 6.33% complete, ETA 19:35:08
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

17649.631 ms/op
# Warmup Iteration   2: 7180.648 ms/op
# Warmup Iteration   3: 6589.252 ms/op
# Warmup Iteration   4: 6551.503 ms/op
# Warmup Iteration   5: 6459.228 ms/op
Iteration   1: 6425.674 ms/op
                 executeQuery·p0.00:   6425.674 ms/op
                 executeQuery·p0.50:   6425.674 ms/op
                 executeQuery·p0.90:   6425.674 ms/op
                 executeQuery·p0.95:   6425.674 ms/op
                 executeQuery·p0.99:   6425.674 ms/op
                 executeQuery·p0.999:  6425.674 ms/op
                 executeQuery·p0.9999: 6425.674 ms/op
                 executeQuery·p1.00:   6425.674 ms/op

Iteration   2: 6438.257 ms/op
                 executeQuery·p0.00:   6425.674 ms/op
                 executeQuery·p0.50:   6438.257 ms/op
                 executeQuery·p0.90:   6450.840 ms/op
                 executeQuery·p0.95:   6450.840 ms/op
                 executeQuery·p0.99:   6450.840 ms/op
                 executeQuery·p0.999:  6450.840 ms/op
                 executeQuery·p0.9999: 6450.840 ms/op
                 executeQuery·p1.00:   6450.840 ms/op

Iteration   3: 6434.062 ms/op
                 executeQuery·p0.00:   6434.062 ms/op
                 executeQuery·p0.50:   6434.062 ms/op
                 executeQuery·p0.90:   6434.062 ms/op
                 executeQuery·p0.95:   6434.062 ms/op
                 executeQuery·p0.99:   6434.062 ms/op
                 executeQuery·p0.999:  6434.062 ms/op
                 executeQuery·p0.9999: 6434.062 ms/op
                 executeQuery·p1.00:   6434.062 ms/op

Iteration   4: 6429.868 ms/op
                 executeQuery·p0.00:   6425.674 ms/op
                 executeQuery·p0.50:   6429.868 ms/op
                 executeQuery·p0.90:   6434.062 ms/op
                 executeQuery·p0.95:   6434.062 ms/op
                 executeQuery·p0.99:   6434.062 ms/op
                 executeQuery·p0.999:  6434.062 ms/op
                 executeQuery·p0.9999: 6434.062 ms/op
                 executeQuery·p1.00:   6434.062 ms/op

Iteration   5: 6434.062 ms/op
                 executeQuery·p0.00:   6425.674 ms/op
                 executeQuery·p0.50:   6434.062 ms/op
                 executeQuery·p0.90:   6442.451 ms/op
                 executeQuery·p0.95:   6442.451 ms/op
                 executeQuery·p0.99:   6442.451 ms/op
                 executeQuery·p0.999:  6442.451 ms/op
                 executeQuery·p0.9999: 6442.451 ms/op
                 executeQuery·p1.00:   6442.451 ms/op


# Run progress: 6.65% complete, ETA 19:07:33
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5335.155 ms/op
# Warmup Iteration   2: 7067.402 ms/op
# Warmup Iteration   3: 6266.290 ms/op
# Warmup Iteration   4: 6278.873 ms/op
# Warmup Iteration   5: 6496.977 ms/op
Iteration   1: 6295.650 ms/op
                 executeQuery·p0.00:   6291.456 ms/op
                 executeQuery·p0.50:   6295.650 ms/op
                 executeQuery·p0.90:   6299.845 ms/op
                 executeQuery·p0.95:   6299.845 ms/op
                 executeQuery·p0.99:   6299.845 ms/op
                 executeQuery·p0.999:  6299.845 ms/op
                 executeQuery·p0.9999: 6299.845 ms/op
                 executeQuery·p1.00:   6299.845 ms/op

Iteration   2: 6304.039 ms/op
                 executeQuery·p0.00:   6299.845 ms/op
                 executeQuery·p0.50:   6304.039 ms/op
                 executeQuery·p0.90:   6308.233 ms/op
                 executeQuery·p0.95:   6308.233 ms/op
                 executeQuery·p0.99:   6308.233 ms/op
                 executeQuery·p0.999:  6308.233 ms/op
                 executeQuery·p0.9999: 6308.233 ms/op
                 executeQuery·p1.00:   6308.233 ms/op

Iteration   3: 6295.650 ms/op
                 executeQuery·p0.00:   6291.456 ms/op
                 executeQuery·p0.50:   6295.650 ms/op
                 executeQuery·p0.90:   6299.845 ms/op
                 executeQuery·p0.95:   6299.845 ms/op
                 executeQuery·p0.99:   6299.845 ms/op
                 executeQuery·p0.999:  6299.845 ms/op
                 executeQuery·p0.9999: 6299.845 ms/op
                 executeQuery·p1.00:   6299.845 ms/op

Iteration   4: 6262.096 ms/op
                 executeQuery·p0.00:   6232.736 ms/op
                 executeQuery·p0.50:   6262.096 ms/op
                 executeQuery·p0.90:   6291.456 ms/op
                 executeQuery·p0.95:   6291.456 ms/op
                 executeQuery·p0.99:   6291.456 ms/op
                 executeQuery·p0.999:  6291.456 ms/op
                 executeQuery·p0.9999: 6291.456 ms/op
                 executeQuery·p1.00:   6291.456 ms/op

Iteration   5: 6241.124 ms/op
                 executeQuery·p0.00:   6232.736 ms/op
                 executeQuery·p0.50:   6241.124 ms/op
                 executeQuery·p0.90:   6249.513 ms/op
                 executeQuery·p0.95:   6249.513 ms/op
                 executeQuery·p0.99:   6249.513 ms/op
                 executeQuery·p0.999:  6249.513 ms/op
                 executeQuery·p0.9999: 6249.513 ms/op
                 executeQuery·p1.00:   6249.513 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 20
  mean =   6356.048 ±(99.9%) 70.430 ms/op

  Histogram, ms/op:
    [6200.000, 6225.000) = 0 
    [6225.000, 6250.000) = 3 
    [6250.000, 6275.000) = 0 
    [6275.000, 6300.000) = 6 
    [6300.000, 6325.000) = 1 
    [6325.000, 6350.000) = 0 
    [6350.000, 6375.000) = 0 
    [6375.000, 6400.000) = 0 
    [6400.000, 6425.000) = 0 
    [6425.000, 6450.000) = 9 
    [6450.000, 6475.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   6232.736 ms/op
     p(50.0000) =   6366.953 ms/op
     p(90.0000) =   6441.612 ms/op
     p(95.0000) =   6450.420 ms/op
     p(99.0000) =   6450.840 ms/op
     p(99.9000) =   6450.840 ms/op
     p(99.9900) =   6450.840 ms/op
     p(99.9990) =   6450.840 ms/op
     p(99.9999) =   6450.840 ms/op
    p(100.0000) =   6450.840 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16)

# Run progress: 6.96% complete, ETA 18:40:04
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

17062.429 ms/op
# Warmup Iteration   2: 11660.165 ms/op
# Warmup Iteration   3: 11827.937 ms/op
# Warmup Iteration   4: 11542.725 ms/op
# Warmup Iteration   5: 11156.849 ms/op
Iteration   1: 11089.740 ms/op
                 executeQuery·p0.00:   11089.740 ms/op
                 executeQuery·p0.50:   11089.740 ms/op
                 executeQuery·p0.90:   11089.740 ms/op
                 executeQuery·p0.95:   11089.740 ms/op
                 executeQuery·p0.99:   11089.740 ms/op
                 executeQuery·p0.999:  11089.740 ms/op
                 executeQuery·p0.9999: 11089.740 ms/op
                 executeQuery·p1.00:   11089.740 ms/op

Iteration   2: 11106.517 ms/op
                 executeQuery·p0.00:   11106.517 ms/op
                 executeQuery·p0.50:   11106.517 ms/op
                 executeQuery·p0.90:   11106.517 ms/op
                 executeQuery·p0.95:   11106.517 ms/op
                 executeQuery·p0.99:   11106.517 ms/op
                 executeQuery·p0.999:  11106.517 ms/op
                 executeQuery·p0.9999: 11106.517 ms/op
                 executeQuery·p1.00:   11106.517 ms/op

Iteration   3: 11140.071 ms/op
                 executeQuery·p0.00:   11140.071 ms/op
                 executeQuery·p0.50:   11140.071 ms/op
                 executeQuery·p0.90:   11140.071 ms/op
                 executeQuery·p0.95:   11140.071 ms/op
                 executeQuery·p0.99:   11140.071 ms/op
                 executeQuery·p0.999:  11140.071 ms/op
                 executeQuery·p0.9999: 11140.071 ms/op
                 executeQuery·p1.00:   11140.071 ms/op

Iteration   4: 11106.517 ms/op
                 executeQuery·p0.00:   11106.517 ms/op
                 executeQuery·p0.50:   11106.517 ms/op
                 executeQuery·p0.90:   11106.517 ms/op
                 executeQuery·p0.95:   11106.517 ms/op
                 executeQuery·p0.99:   11106.517 ms/op
                 executeQuery·p0.999:  11106.517 ms/op
                 executeQuery·p0.9999: 11106.517 ms/op
                 executeQuery·p1.00:   11106.517 ms/op

Iteration   5: 11123.294 ms/op
                 executeQuery·p0.00:   11123.294 ms/op
                 executeQuery·p0.50:   11123.294 ms/op
                 executeQuery·p0.90:   11123.294 ms/op
                 executeQuery·p0.95:   11123.294 ms/op
                 executeQuery·p0.99:   11123.294 ms/op
                 executeQuery·p0.999:  11123.294 ms/op
                 executeQuery·p0.9999: 11123.294 ms/op
                 executeQuery·p1.00:   11123.294 ms/op


# Run progress: 7.28% complete, ETA 18:13:21
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

10779.361 ms/op
# Warmup Iteration   2: 12180.259 ms/op
# Warmup Iteration   3: 11056.185 ms/op
# Warmup Iteration   4: 11576.279 ms/op
# Warmup Iteration   5: 11123.294 ms/op
Iteration   1: 11089.740 ms/op
                 executeQuery·p0.00:   11089.740 ms/op
                 executeQuery·p0.50:   11089.740 ms/op
                 executeQuery·p0.90:   11089.740 ms/op
                 executeQuery·p0.95:   11089.740 ms/op
                 executeQuery·p0.99:   11089.740 ms/op
                 executeQuery·p0.999:  11089.740 ms/op
                 executeQuery·p0.9999: 11089.740 ms/op
                 executeQuery·p1.00:   11089.740 ms/op

Iteration   2: 11106.517 ms/op
                 executeQuery·p0.00:   11106.517 ms/op
                 executeQuery·p0.50:   11106.517 ms/op
                 executeQuery·p0.90:   11106.517 ms/op
                 executeQuery·p0.95:   11106.517 ms/op
                 executeQuery·p0.99:   11106.517 ms/op
                 executeQuery·p0.999:  11106.517 ms/op
                 executeQuery·p0.9999: 11106.517 ms/op
                 executeQuery·p1.00:   11106.517 ms/op

Iteration   3: 11072.963 ms/op
                 executeQuery·p0.00:   11072.963 ms/op
                 executeQuery·p0.50:   11072.963 ms/op
                 executeQuery·p0.90:   11072.963 ms/op
                 executeQuery·p0.95:   11072.963 ms/op
                 executeQuery·p0.99:   11072.963 ms/op
                 executeQuery·p0.999:  11072.963 ms/op
                 executeQuery·p0.9999: 11072.963 ms/op
                 executeQuery·p1.00:   11072.963 ms/op

Iteration   4: 11072.963 ms/op
                 executeQuery·p0.00:   11072.963 ms/op
                 executeQuery·p0.50:   11072.963 ms/op
                 executeQuery·p0.90:   11072.963 ms/op
                 executeQuery·p0.95:   11072.963 ms/op
                 executeQuery·p0.99:   11072.963 ms/op
                 executeQuery·p0.999:  11072.963 ms/op
                 executeQuery·p0.9999: 11072.963 ms/op
                 executeQuery·p1.00:   11072.963 ms/op

Iteration   5: 11056.185 ms/op
                 executeQuery·p0.00:   11056.185 ms/op
                 executeQuery·p0.50:   11056.185 ms/op
                 executeQuery·p0.90:   11056.185 ms/op
                 executeQuery·p0.95:   11056.185 ms/op
                 executeQuery·p0.99:   11056.185 ms/op
                 executeQuery·p0.999:  11056.185 ms/op
                 executeQuery·p0.9999: 11056.185 ms/op
                 executeQuery·p1.00:   11056.185 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  11096.451 ±(99.9%) 38.188 ms/op

  Histogram, ms/op:
    [11050.000, 11060.000) = 1 
    [11060.000, 11070.000) = 0 
    [11070.000, 11080.000) = 2 
    [11080.000, 11090.000) = 2 
    [11090.000, 11100.000) = 0 
    [11100.000, 11110.000) = 3 
    [11110.000, 11120.000) = 0 
    [11120.000, 11130.000) = 1 
    [11130.000, 11140.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  11056.185 ms/op
     p(50.0000) =  11098.128 ms/op
     p(90.0000) =  11138.394 ms/op
     p(95.0000) =  11140.071 ms/op
     p(99.0000) =  11140.071 ms/op
     p(99.9000) =  11140.071 ms/op
     p(99.9900) =  11140.071 ms/op
     p(99.9990) =  11140.071 ms/op
     p(99.9999) =  11140.071 ms/op
    p(100.0000) =  11140.071 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192)

# Run progress: 7.59% complete, ETA 17:49:30
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

16861.102 ms/op
# Warmup Iteration   2: 12717.130 ms/op
# Warmup Iteration   3: 12331.254 ms/op
# Warmup Iteration   4: 12129.927 ms/op
# Warmup Iteration   5: 12784.239 ms/op
Iteration   1: 12834.570 ms/op
                 executeQuery·p0.00:   12834.570 ms/op
                 executeQuery·p0.50:   12834.570 ms/op
                 executeQuery·p0.90:   12834.570 ms/op
                 executeQuery·p0.95:   12834.570 ms/op
                 executeQuery·p0.99:   12834.570 ms/op
                 executeQuery·p0.999:  12834.570 ms/op
                 executeQuery·p0.9999: 12834.570 ms/op
                 executeQuery·p1.00:   12834.570 ms/op

Iteration   2: 12834.570 ms/op
                 executeQuery·p0.00:   12834.570 ms/op
                 executeQuery·p0.50:   12834.570 ms/op
                 executeQuery·p0.90:   12834.570 ms/op
                 executeQuery·p0.95:   12834.570 ms/op
                 executeQuery·p0.99:   12834.570 ms/op
                 executeQuery·p0.999:  12834.570 ms/op
                 executeQuery·p0.9999: 12834.570 ms/op
                 executeQuery·p1.00:   12834.570 ms/op

Iteration   3: 12784.239 ms/op
                 executeQuery·p0.00:   12784.239 ms/op
                 executeQuery·p0.50:   12784.239 ms/op
                 executeQuery·p0.90:   12784.239 ms/op
                 executeQuery·p0.95:   12784.239 ms/op
                 executeQuery·p0.99:   12784.239 ms/op
                 executeQuery·p0.999:  12784.239 ms/op
                 executeQuery·p0.9999: 12784.239 ms/op
                 executeQuery·p1.00:   12784.239 ms/op

Iteration   4: 12834.570 ms/op
                 executeQuery·p0.00:   12834.570 ms/op
                 executeQuery·p0.50:   12834.570 ms/op
                 executeQuery·p0.90:   12834.570 ms/op
                 executeQuery·p0.95:   12834.570 ms/op
                 executeQuery·p0.99:   12834.570 ms/op
                 executeQuery·p0.999:  12834.570 ms/op
                 executeQuery·p0.9999: 12834.570 ms/op
                 executeQuery·p1.00:   12834.570 ms/op

Iteration   5: 12884.902 ms/op
                 executeQuery·p0.00:   12884.902 ms/op
                 executeQuery·p0.50:   12884.902 ms/op
                 executeQuery·p0.90:   12884.902 ms/op
                 executeQuery·p0.95:   12884.902 ms/op
                 executeQuery·p0.99:   12884.902 ms/op
                 executeQuery·p0.999:  12884.902 ms/op
                 executeQuery·p0.9999: 12884.902 ms/op
                 executeQuery·p1.00:   12884.902 ms/op


# Run progress: 7.91% complete, ETA 17:29:00
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

12012.487 ms/op
# Warmup Iteration   2: 12197.036 ms/op
# Warmup Iteration   3: 12549.358 ms/op
# Warmup Iteration   4: 11962.155 ms/op
# Warmup Iteration   5: 12280.922 ms/op
Iteration   1: 12280.922 ms/op
                 executeQuery·p0.00:   12280.922 ms/op
                 executeQuery·p0.50:   12280.922 ms/op
                 executeQuery·p0.90:   12280.922 ms/op
                 executeQuery·p0.95:   12280.922 ms/op
                 executeQuery·p0.99:   12280.922 ms/op
                 executeQuery·p0.999:  12280.922 ms/op
                 executeQuery·p0.9999: 12280.922 ms/op
                 executeQuery·p1.00:   12280.922 ms/op

Iteration   2: 12012.487 ms/op
                 executeQuery·p0.00:   12012.487 ms/op
                 executeQuery·p0.50:   12012.487 ms/op
                 executeQuery·p0.90:   12012.487 ms/op
                 executeQuery·p0.95:   12012.487 ms/op
                 executeQuery·p0.99:   12012.487 ms/op
                 executeQuery·p0.999:  12012.487 ms/op
                 executeQuery·p0.9999: 12012.487 ms/op
                 executeQuery·p1.00:   12012.487 ms/op

Iteration   3: 12750.684 ms/op
                 executeQuery·p0.00:   12750.684 ms/op
                 executeQuery·p0.50:   12750.684 ms/op
                 executeQuery·p0.90:   12750.684 ms/op
                 executeQuery·p0.95:   12750.684 ms/op
                 executeQuery·p0.99:   12750.684 ms/op
                 executeQuery·p0.999:  12750.684 ms/op
                 executeQuery·p0.9999: 12750.684 ms/op
                 executeQuery·p1.00:   12750.684 ms/op

Iteration   4: 11962.155 ms/op
                 executeQuery·p0.00:   11962.155 ms/op
                 executeQuery·p0.50:   11962.155 ms/op
                 executeQuery·p0.90:   11962.155 ms/op
                 executeQuery·p0.95:   11962.155 ms/op
                 executeQuery·p0.99:   11962.155 ms/op
                 executeQuery·p0.999:  11962.155 ms/op
                 executeQuery·p0.9999: 11962.155 ms/op
                 executeQuery·p1.00:   11962.155 ms/op

Iteration   5: 12163.482 ms/op
                 executeQuery·p0.00:   12163.482 ms/op
                 executeQuery·p0.50:   12163.482 ms/op
                 executeQuery·p0.90:   12163.482 ms/op
                 executeQuery·p0.95:   12163.482 ms/op
                 executeQuery·p0.99:   12163.482 ms/op
                 executeQuery·p0.999:  12163.482 ms/op
                 executeQuery·p0.9999: 12163.482 ms/op
                 executeQuery·p1.00:   12163.482 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  12534.258 ±(99.9%) 575.488 ms/op

  Histogram, ms/op:
    [11900.000, 12000.000) = 1 
    [12000.000, 12100.000) = 1 
    [12100.000, 12200.000) = 1 
    [12200.000, 12300.000) = 1 
    [12300.000, 12400.000) = 0 
    [12400.000, 12500.000) = 0 
    [12500.000, 12600.000) = 0 
    [12600.000, 12700.000) = 0 
    [12700.000, 12800.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =  11962.155 ms/op
     p(50.0000) =  12767.461 ms/op
     p(90.0000) =  12879.869 ms/op
     p(95.0000) =  12884.902 ms/op
     p(99.0000) =  12884.902 ms/op
     p(99.9000) =  12884.902 ms/op
     p(99.9900) =  12884.902 ms/op
     p(99.9990) =  12884.902 ms/op
     p(99.9999) =  12884.902 ms/op
    p(100.0000) =  12884.902 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144)

# Run progress: 8.23% complete, ETA 17:08:16
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

53284.438 ms/op
# Warmup Iteration   2: 51472.499 ms/op
# Warmup Iteration   3: 47177.531 ms/op
# Warmup Iteration   4: 43889.197 ms/op
# Warmup Iteration   5: 47110.423 ms/op
Iteration   1: 44761.612 ms/op
                 executeQuery·p0.00:   44761.612 ms/op
                 executeQuery·p0.50:   44761.612 ms/op
                 executeQuery·p0.90:   44761.612 ms/op
                 executeQuery·p0.95:   44761.612 ms/op
                 executeQuery·p0.99:   44761.612 ms/op
                 executeQuery·p0.999:  44761.612 ms/op
                 executeQuery·p0.9999: 44761.612 ms/op
                 executeQuery·p1.00:   44761.612 ms/op

Iteration   2: 46774.878 ms/op
                 executeQuery·p0.00:   46774.878 ms/op
                 executeQuery·p0.50:   46774.878 ms/op
                 executeQuery·p0.90:   46774.878 ms/op
                 executeQuery·p0.95:   46774.878 ms/op
                 executeQuery·p0.99:   46774.878 ms/op
                 executeQuery·p0.999:  46774.878 ms/op
                 executeQuery·p0.9999: 46774.878 ms/op
                 executeQuery·p1.00:   46774.878 ms/op

Iteration   3: 44493.177 ms/op
                 executeQuery·p0.00:   44493.177 ms/op
                 executeQuery·p0.50:   44493.177 ms/op
                 executeQuery·p0.90:   44493.177 ms/op
                 executeQuery·p0.95:   44493.177 ms/op
                 executeQuery·p0.99:   44493.177 ms/op
                 executeQuery·p0.999:  44493.177 ms/op
                 executeQuery·p0.9999: 44493.177 ms/op
                 executeQuery·p1.00:   44493.177 ms/op

Iteration   4: 44560.286 ms/op
                 executeQuery·p0.00:   44560.286 ms/op
                 executeQuery·p0.50:   44560.286 ms/op
                 executeQuery·p0.90:   44560.286 ms/op
                 executeQuery·p0.95:   44560.286 ms/op
                 executeQuery·p0.99:   44560.286 ms/op
                 executeQuery·p0.999:  44560.286 ms/op
                 executeQuery·p0.9999: 44560.286 ms/op
                 executeQuery·p1.00:   44560.286 ms/op

Iteration   5: 43889.197 ms/op
                 executeQuery·p0.00:   43889.197 ms/op
                 executeQuery·p0.50:   43889.197 ms/op
                 executeQuery·p0.90:   43889.197 ms/op
                 executeQuery·p0.95:   43889.197 ms/op
                 executeQuery·p0.99:   43889.197 ms/op
                 executeQuery·p0.999:  43889.197 ms/op
                 executeQuery·p0.9999: 43889.197 ms/op
                 executeQuery·p1.00:   43889.197 ms/op


# Run progress: 8.54% complete, ETA 18:06:18
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

49727.668 ms/op
# Warmup Iteration   2: 49190.797 ms/op
# Warmup Iteration   3: 41540.387 ms/op
# Warmup Iteration   4: 48922.362 ms/op
# Warmup Iteration   5: 49727.668 ms/op
Iteration   1: 47110.423 ms/op
                 executeQuery·p0.00:   47110.423 ms/op
                 executeQuery·p0.50:   47110.423 ms/op
                 executeQuery·p0.90:   47110.423 ms/op
                 executeQuery·p0.95:   47110.423 ms/op
                 executeQuery·p0.99:   47110.423 ms/op
                 executeQuery·p0.999:  47110.423 ms/op
                 executeQuery·p0.9999: 47110.423 ms/op
                 executeQuery·p1.00:   47110.423 ms/op

Iteration   2: 47781.511 ms/op
                 executeQuery·p0.00:   47781.511 ms/op
                 executeQuery·p0.50:   47781.511 ms/op
                 executeQuery·p0.90:   47781.511 ms/op
                 executeQuery·p0.95:   47781.511 ms/op
                 executeQuery·p0.99:   47781.511 ms/op
                 executeQuery·p0.999:  47781.511 ms/op
                 executeQuery·p0.9999: 47781.511 ms/op
                 executeQuery·p1.00:   47781.511 ms/op

Iteration   3: 45634.028 ms/op
                 executeQuery·p0.00:   45634.028 ms/op
                 executeQuery·p0.50:   45634.028 ms/op
                 executeQuery·p0.90:   45634.028 ms/op
                 executeQuery·p0.95:   45634.028 ms/op
                 executeQuery·p0.99:   45634.028 ms/op
                 executeQuery·p0.999:  45634.028 ms/op
                 executeQuery·p0.9999: 45634.028 ms/op
                 executeQuery·p1.00:   45634.028 ms/op

Iteration   4: 44090.524 ms/op
                 executeQuery·p0.00:   44090.524 ms/op
                 executeQuery·p0.50:   44090.524 ms/op
                 executeQuery·p0.90:   44090.524 ms/op
                 executeQuery·p0.95:   44090.524 ms/op
                 executeQuery·p0.99:   44090.524 ms/op
                 executeQuery·p0.999:  44090.524 ms/op
                 executeQuery·p0.9999: 44090.524 ms/op
                 executeQuery·p1.00:   44090.524 ms/op

Iteration   5: 44157.633 ms/op
                 executeQuery·p0.00:   44157.633 ms/op
                 executeQuery·p0.50:   44157.633 ms/op
                 executeQuery·p0.90:   44157.633 ms/op
                 executeQuery·p0.95:   44157.633 ms/op
                 executeQuery·p0.99:   44157.633 ms/op
                 executeQuery·p0.999:  44157.633 ms/op
                 executeQuery·p0.9999: 44157.633 ms/op
                 executeQuery·p1.00:   44157.633 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  45325.327 ±(99.9%) 2135.840 ms/op

  Histogram, ms/op:
    [43000.000, 43500.000) = 0 
    [43500.000, 44000.000) = 1 
    [44000.000, 44500.000) = 3 
    [44500.000, 45000.000) = 2 
    [45000.000, 45500.000) = 0 
    [45500.000, 46000.000) = 1 
    [46000.000, 46500.000) = 0 
    [46500.000, 47000.000) = 1 
    [47000.000, 47500.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  43889.197 ms/op
     p(50.0000) =  44660.949 ms/op
     p(90.0000) =  47714.402 ms/op
     p(95.0000) =  47781.511 ms/op
     p(99.0000) =  47781.511 ms/op
     p(99.9000) =  47781.511 ms/op
     p(99.9900) =  47781.511 ms/op
     p(99.9990) =  47781.511 ms/op
     p(99.9999) =  47781.511 ms/op
    p(100.0000) =  47781.511 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288)

# Run progress: 8.86% complete, ETA 18:59:29
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
private final class KeyValueMap_494046002 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_494046002() {
        this(4);
    }
    public KeyValueMap_494046002(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_494046002 aggregation_state_map = new KeyValueMap_494046002();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

101871.256 ms/op
# Warmup Iteration   2: 102944.997 ms/op
# Warmup Iteration   3: 96636.764 ms/op
# Warmup Iteration   4: 97978.941 ms/op
# Warmup Iteration   5: 97307.853 ms/op
Iteration   1: 97039.417 ms/op
                 executeQuery·p0.00:   97039.417 ms/op
                 executeQuery·p0.50:   97039.417 ms/op
                 executeQuery·p0.90:   97039.417 ms/op
                 executeQuery·p0.95:   97039.417 ms/op
                 executeQuery·p0.99:   97039.417 ms/op
                 executeQuery·p0.999:  97039.417 ms/op
                 executeQuery·p0.9999: 97039.417 ms/op
                 executeQuery·p1.00:   97039.417 ms/op

Iteration   2: 96905.200 ms/op
                 executeQuery·p0.00:   96905.200 ms/op
                 executeQuery·p0.50:   96905.200 ms/op
                 executeQuery·p0.90:   96905.200 ms/op
                 executeQuery·p0.95:   96905.200 ms/op
                 executeQuery·p0.99:   96905.200 ms/op
                 executeQuery·p0.999:  96905.200 ms/op
                 executeQuery·p0.9999: 96905.200 ms/op
                 executeQuery·p1.00:   96905.200 ms/op

Iteration   3: 94355.063 ms/op
                 executeQuery·p0.00:   94355.063 ms/op
                 executeQuery·p0.50:   94355.063 ms/op
                 executeQuery·p0.90:   94355.063 ms/op
                 executeQuery·p0.95:   94355.063 ms/op
                 executeQuery·p0.99:   94355.063 ms/op
                 executeQuery·p0.999:  94355.063 ms/op
                 executeQuery·p0.9999: 94355.063 ms/op
                 executeQuery·p1.00:   94355.063 ms/op

Iteration   4: 94086.627 ms/op
                 executeQuery·p0.00:   94086.627 ms/op
                 executeQuery·p0.50:   94086.627 ms/op
                 executeQuery·p0.90:   94086.627 ms/op
                 executeQuery·p0.95:   94086.627 ms/op
                 executeQuery·p0.99:   94086.627 ms/op
                 executeQuery·p0.999:  94086.627 ms/op
                 executeQuery·p0.9999: 94086.627 ms/op
                 executeQuery·p1.00:   94086.627 ms/op

Iteration   5: 94355.063 ms/op
                 executeQuery·p0.00:   94355.063 ms/op
                 executeQuery·p0.50:   94355.063 ms/op
                 executeQuery·p0.90:   94355.063 ms/op
                 executeQuery·p0.95:   94355.063 ms/op
                 executeQuery·p0.99:   94355.063 ms/op
                 executeQuery·p0.999:  94355.063 ms/op
                 executeQuery·p0.9999: 94355.063 ms/op
                 executeQuery·p1.00:   94355.063 ms/op


# Run progress: 9.18% complete, ETA 21:56:02
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
private final class KeyValueMap_662565010 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_662565010() {
        this(4);
    }
    public KeyValueMap_662565010(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_662565010 aggregation_state_map = new KeyValueMap_662565010();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = aggregation_query_table_vc_0.get(aviv);
        long group_key_pre_hash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = aggregation_query_table_vc_1.get(aviv);
        int ordinal_value_1 = aggregation_query_table_vc_2.get(aviv);
        int ordinal_value_2 = aggregation_query_table_vc_3.get(aviv);
        aggregation_state_map.incrementForKey(ordinal_value, group_key_pre_hash, ordinal_value_0, ordinal_value_1, ordinal_value_2);
    }
}
for (int key_i = 0; key_i < aggregation_state_map.numberOfRecords; key_i++) {
    int groupKey_0 = aggregation_state_map.keys_ord_0[key_i];
    long aggregation_0_value = aggregation_state_map.values_ord_0[key_i];
    long aggregation_1_value = aggregation_state_map.values_ord_1[key_i];
    long aggregation_2_value = aggregation_state_map.values_ord_2[key_i];
    resultKeyArray[resultWritePtr] = groupKey_0;
    resultSum2Array[resultWritePtr] = aggregation_0_value;
    resultSum3Array[resultWritePtr] = aggregation_1_value;
    resultSum4Array[resultWritePtr++] = aggregation_2_value;
}
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

98247.377 ms/op
# Warmup Iteration   2: 103481.868 ms/op
# Warmup Iteration   3: 94623.498 ms/op
# Warmup Iteration   4: 97307.853 ms/op
# Warmup Iteration   5: 98650.030 ms/op
Iteration   1: 97442.071 ms/op
                 executeQuery·p0.00:   97442.071 ms/op
                 executeQuery·p0.50:   97442.071 ms/op
                 executeQuery·p0.90:   97442.071 ms/op
                 executeQuery·p0.95:   97442.071 ms/op
                 executeQuery·p0.99:   97442.071 ms/op
                 executeQuery·p0.999:  97442.071 ms/op
                 executeQuery·p0.9999: 97442.071 ms/op
                 executeQuery·p1.00:   97442.071 ms/op

Iteration   2: 98784.248 ms/op
                 executeQuery·p0.00:   98784.248 ms/op
                 executeQuery·p0.50:   98784.248 ms/op
                 executeQuery·p0.90:   98784.248 ms/op
                 executeQuery·p0.95:   98784.248 ms/op
                 executeQuery·p0.99:   98784.248 ms/op
                 executeQuery·p0.999:  98784.248 ms/op
                 executeQuery·p0.9999: 98784.248 ms/op
                 executeQuery·p1.00:   98784.248 ms/op

Iteration   3: 103347.651 ms/op
                 executeQuery·p0.00:   103347.651 ms/op
                 executeQuery·p0.50:   103347.651 ms/op
                 executeQuery·p0.90:   103347.651 ms/op
                 executeQuery·p0.95:   103347.651 ms/op
                 executeQuery·p0.99:   103347.651 ms/op
                 executeQuery·p0.999:  103347.651 ms/op
                 executeQuery·p0.9999: 103347.651 ms/op
                 executeQuery·p1.00:   103347.651 ms/op

Iteration   4: 98650.030 ms/op
                 executeQuery·p0.00:   98650.030 ms/op
                 executeQuery·p0.50:   98650.030 ms/op
                 executeQuery·p0.90:   98650.030 ms/op
                 executeQuery·p0.95:   98650.030 ms/op
                 executeQuery·p0.99:   98650.030 ms/op
                 executeQuery·p0.999:  98650.030 ms/op
                 executeQuery·p0.9999: 98650.030 ms/op
                 executeQuery·p1.00:   98650.030 ms/op

Iteration   5: 97710.506 ms/op
                 executeQuery·p0.00:   97710.506 ms/op
                 executeQuery·p0.50:   97710.506 ms/op
                 executeQuery·p0.90:   97710.506 ms/op
                 executeQuery·p0.95:   97710.506 ms/op
                 executeQuery·p0.99:   97710.506 ms/op
                 executeQuery·p0.999:  97710.506 ms/op
                 executeQuery·p0.9999: 97710.506 ms/op
                 executeQuery·p1.00:   97710.506 ms/op



Result "benchmarks.aggregation_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  97267.587 ±(99.9%) 4176.203 ms/op

  Histogram, ms/op:
    [ 94000.000,  95000.000) = 3 
    [ 95000.000,  96000.000) = 0 
    [ 96000.000,  97000.000) = 1 
    [ 97000.000,  98000.000) = 3 
    [ 98000.000,  99000.000) = 2 
    [ 99000.000, 100000.000) = 0 
    [100000.000, 101000.000) = 0 
    [101000.000, 102000.000) = 0 
    [102000.000, 103000.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  94086.627 ms/op
     p(50.0000) =  97240.744 ms/op
     p(90.0000) = 102891.310 ms/op
     p(95.0000) = 103347.651 ms/op
     p(99.0000) = 103347.651 ms/op
     p(99.9000) = 103347.651 ms/op
     p(99.9900) = 103347.651 ms/op
     p(99.9990) = 103347.651 ms/op
     p(99.9999) = 103347.651 ms/op
    p(100.0000) = 103347.651 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2)

# Run progress: 9.49% complete, ETA 1 days, 00:42:04
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

380.672 ±(99.9%) 84.322 ms/op
# Warmup Iteration   2: 348.037 ±(99.9%) 4.670 ms/op
# Warmup Iteration   3: 347.983 ±(99.9%) 2.935 ms/op
# Warmup Iteration   4: 350.893 ±(99.9%) 7.908 ms/op
# Warmup Iteration   5: 349.194 ±(99.9%) 5.275 ms/op
Iteration   1: 345.470 ±(99.9%) 2.935 ms/op
                 executeQuery·p0.00:   341.836 ms/op
                 executeQuery·p0.50:   343.933 ms/op
                 executeQuery·p0.90:   349.700 ms/op
                 executeQuery·p0.95:   357.302 ms/op
                 executeQuery·p0.99:   363.332 ms/op
                 executeQuery·p0.999:  363.332 ms/op
                 executeQuery·p0.9999: 363.332 ms/op
                 executeQuery·p1.00:   363.332 ms/op

Iteration   2: 345.036 ±(99.9%) 2.303 ms/op
                 executeQuery·p0.00:   340.263 ms/op
                 executeQuery·p0.50:   343.409 ms/op
                 executeQuery·p0.90:   349.176 ms/op
                 executeQuery·p0.95:   352.584 ms/op
                 executeQuery·p0.99:   355.467 ms/op
                 executeQuery·p0.999:  355.467 ms/op
                 executeQuery·p0.9999: 355.467 ms/op
                 executeQuery·p1.00:   355.467 ms/op

Iteration   3: 343.499 ±(99.9%) 1.924 ms/op
                 executeQuery·p0.00:   339.739 ms/op
                 executeQuery·p0.50:   342.360 ms/op
                 executeQuery·p0.90:   347.603 ms/op
                 executeQuery·p0.95:   351.011 ms/op
                 executeQuery·p0.99:   351.273 ms/op
                 executeQuery·p0.999:  351.273 ms/op
                 executeQuery·p0.9999: 351.273 ms/op
                 executeQuery·p1.00:   351.273 ms/op

Iteration   4: 346.898 ±(99.9%) 3.005 ms/op
                 executeQuery·p0.00:   342.360 ms/op
                 executeQuery·p0.50:   346.030 ms/op
                 executeQuery·p0.90:   352.846 ms/op
                 executeQuery·p0.95:   358.613 ms/op
                 executeQuery·p0.99:   363.856 ms/op
                 executeQuery·p0.999:  363.856 ms/op
                 executeQuery·p0.9999: 363.856 ms/op
                 executeQuery·p1.00:   363.856 ms/op

Iteration   5: 347.061 ±(99.9%) 3.558 ms/op
                 executeQuery·p0.00:   342.360 ms/op
                 executeQuery·p0.50:   345.506 ms/op
                 executeQuery·p0.90:   352.322 ms/op
                 executeQuery·p0.95:   362.807 ms/op
                 executeQuery·p0.99:   366.477 ms/op
                 executeQuery·p0.999:  366.477 ms/op
                 executeQuery·p0.9999: 366.477 ms/op
                 executeQuery·p1.00:   366.477 ms/op


# Run progress: 9.81% complete, ETA 1 days, 00:05:00
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

353.153 ±(99.9%) 30.437 ms/op
# Warmup Iteration   2: 347.748 ±(99.9%) 6.050 ms/op
# Warmup Iteration   3: 346.572 ±(99.9%) 2.370 ms/op
# Warmup Iteration   4: 347.639 ±(99.9%) 2.659 ms/op
# Warmup Iteration   5: 341.923 ±(99.9%) 4.648 ms/op
Iteration   1: 346.211 ±(99.9%) 2.115 ms/op
                 executeQuery·p0.00:   342.884 ms/op
                 executeQuery·p0.50:   344.982 ms/op
                 executeQuery·p0.90:   350.749 ms/op
                 executeQuery·p0.95:   352.059 ms/op
                 executeQuery·p0.99:   353.370 ms/op
                 executeQuery·p0.999:  353.370 ms/op
                 executeQuery·p0.9999: 353.370 ms/op
                 executeQuery·p1.00:   353.370 ms/op

Iteration   2: 346.193 ±(99.9%) 1.854 ms/op
                 executeQuery·p0.00:   342.360 ms/op
                 executeQuery·p0.50:   346.030 ms/op
                 executeQuery·p0.90:   350.224 ms/op
                 executeQuery·p0.95:   350.749 ms/op
                 executeQuery·p0.99:   350.749 ms/op
                 executeQuery·p0.999:  350.749 ms/op
                 executeQuery·p0.9999: 350.749 ms/op
                 executeQuery·p1.00:   350.749 ms/op

Iteration   3: 345.090 ±(99.9%) 1.832 ms/op
                 executeQuery·p0.00:   342.360 ms/op
                 executeQuery·p0.50:   344.457 ms/op
                 executeQuery·p0.90:   350.224 ms/op
                 executeQuery·p0.95:   351.273 ms/op
                 executeQuery·p0.99:   352.322 ms/op
                 executeQuery·p0.999:  352.322 ms/op
                 executeQuery·p0.9999: 352.322 ms/op
                 executeQuery·p1.00:   352.322 ms/op

Iteration   4: 345.343 ±(99.9%) 2.491 ms/op
                 executeQuery·p0.00:   341.311 ms/op
                 executeQuery·p0.50:   343.933 ms/op
                 executeQuery·p0.90:   349.700 ms/op
                 executeQuery·p0.95:   354.419 ms/op
                 executeQuery·p0.99:   355.992 ms/op
                 executeQuery·p0.999:  355.992 ms/op
                 executeQuery·p0.9999: 355.992 ms/op
                 executeQuery·p1.00:   355.992 ms/op

Iteration   5: 347.675 ±(99.9%) 4.334 ms/op
                 executeQuery·p0.00:   341.836 ms/op
                 executeQuery·p0.50:   346.554 ms/op
                 executeQuery·p0.90:   350.749 ms/op
                 executeQuery·p0.95:   368.312 ms/op
                 executeQuery·p0.99:   372.769 ms/op
                 executeQuery·p0.999:  372.769 ms/op
                 executeQuery·p0.9999: 372.769 ms/op
                 executeQuery·p1.00:   372.769 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 290
  mean =    345.847 ±(99.9%) 0.807 ms/op

  Histogram, ms/op:
    [330.000, 335.000) = 0 
    [335.000, 340.000) = 1 
    [340.000, 345.000) = 164 
    [345.000, 350.000) = 94 
    [350.000, 355.000) = 23 
    [355.000, 360.000) = 3 
    [360.000, 365.000) = 3 
    [365.000, 370.000) = 1 
    [370.000, 375.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    339.739 ms/op
     p(50.0000) =    344.457 ms/op
     p(90.0000) =    350.224 ms/op
     p(95.0000) =    351.745 ms/op
     p(99.0000) =    364.092 ms/op
     p(99.9000) =    372.769 ms/op
     p(99.9900) =    372.769 ms/op
     p(99.9990) =    372.769 ms/op
     p(99.9999) =    372.769 ms/op
    p(100.0000) =    372.769 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16)

# Run progress: 10.13% complete, ETA 23:30:09
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

504.470 ±(99.9%) 98.279 ms/op
# Warmup Iteration   2: 469.476 ±(99.9%) 9.616 ms/op
# Warmup Iteration   3: 467.546 ±(99.9%) 3.733 ms/op
# Warmup Iteration   4: 467.236 ±(99.9%) 2.670 ms/op
# Warmup Iteration   5: 471.049 ±(99.9%) 7.958 ms/op
Iteration   1: 467.117 ±(99.9%) 1.511 ms/op
                 executeQuery·p0.00:   464.519 ms/op
                 executeQuery·p0.50:   467.141 ms/op
                 executeQuery·p0.90:   469.814 ms/op
                 executeQuery·p0.95:   471.178 ms/op
                 executeQuery·p0.99:   471.335 ms/op
                 executeQuery·p0.999:  471.335 ms/op
                 executeQuery·p0.9999: 471.335 ms/op
                 executeQuery·p1.00:   471.335 ms/op

Iteration   2: 468.809 ±(99.9%) 3.348 ms/op
                 executeQuery·p0.00:   463.471 ms/op
                 executeQuery·p0.50:   467.927 ms/op
                 executeQuery·p0.90:   476.316 ms/op
                 executeQuery·p0.95:   478.885 ms/op
                 executeQuery·p0.99:   479.199 ms/op
                 executeQuery·p0.999:  479.199 ms/op
                 executeQuery·p0.9999: 479.199 ms/op
                 executeQuery·p1.00:   479.199 ms/op

Iteration   3: 468.785 ±(99.9%) 2.752 ms/op
                 executeQuery·p0.00:   465.568 ms/op
                 executeQuery·p0.50:   467.403 ms/op
                 executeQuery·p0.90:   475.896 ms/op
                 executeQuery·p0.95:   476.499 ms/op
                 executeQuery·p0.99:   476.578 ms/op
                 executeQuery·p0.999:  476.578 ms/op
                 executeQuery·p0.9999: 476.578 ms/op
                 executeQuery·p1.00:   476.578 ms/op

Iteration   4: 468.976 ±(99.9%) 2.728 ms/op
                 executeQuery·p0.00:   465.043 ms/op
                 executeQuery·p0.50:   468.189 ms/op
                 executeQuery·p0.90:   475.424 ms/op
                 executeQuery·p0.95:   476.499 ms/op
                 executeQuery·p0.99:   476.578 ms/op
                 executeQuery·p0.999:  476.578 ms/op
                 executeQuery·p0.9999: 476.578 ms/op
                 executeQuery·p1.00:   476.578 ms/op

Iteration   5: 470.453 ±(99.9%) 3.169 ms/op
                 executeQuery·p0.00:   465.043 ms/op
                 executeQuery·p0.50:   470.286 ms/op
                 executeQuery·p0.90:   475.372 ms/op
                 executeQuery·p0.95:   481.768 ms/op
                 executeQuery·p0.99:   482.869 ms/op
                 executeQuery·p0.999:  482.869 ms/op
                 executeQuery·p0.9999: 482.869 ms/op
                 executeQuery·p1.00:   482.869 ms/op


# Run progress: 10.44% complete, ETA 22:57:36
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

482.844 ±(99.9%) 26.503 ms/op
# Warmup Iteration   2: 471.955 ±(99.9%) 4.455 ms/op
# Warmup Iteration   3: 479.873 ±(99.9%) 30.070 ms/op
# Warmup Iteration   4: 470.525 ±(99.9%) 3.569 ms/op
# Warmup Iteration   5: 477.202 ±(99.9%) 8.104 ms/op
Iteration   1: 480.048 ±(99.9%) 6.856 ms/op
                 executeQuery·p0.00:   469.238 ms/op
                 executeQuery·p0.50:   476.578 ms/op
                 executeQuery·p0.90:   494.718 ms/op
                 executeQuery·p0.95:   495.400 ms/op
                 executeQuery·p0.99:   495.452 ms/op
                 executeQuery·p0.999:  495.452 ms/op
                 executeQuery·p0.9999: 495.452 ms/op
                 executeQuery·p1.00:   495.452 ms/op

Iteration   2: 478.750 ±(99.9%) 2.095 ms/op
                 executeQuery·p0.00:   475.005 ms/op
                 executeQuery·p0.50:   478.675 ms/op
                 executeQuery·p0.90:   481.296 ms/op
                 executeQuery·p0.95:   484.128 ms/op
                 executeQuery·p0.99:   484.442 ms/op
                 executeQuery·p0.999:  484.442 ms/op
                 executeQuery·p0.9999: 484.442 ms/op
                 executeQuery·p1.00:   484.442 ms/op

Iteration   3: 478.975 ±(99.9%) 3.923 ms/op
                 executeQuery·p0.00:   473.432 ms/op
                 executeQuery·p0.50:   477.626 ms/op
                 executeQuery·p0.90:   486.854 ms/op
                 executeQuery·p0.95:   491.782 ms/op
                 executeQuery·p0.99:   492.306 ms/op
                 executeQuery·p0.999:  492.306 ms/op
                 executeQuery·p0.9999: 492.306 ms/op
                 executeQuery·p1.00:   492.306 ms/op

Iteration   4: 477.951 ±(99.9%) 2.976 ms/op
                 executeQuery·p0.00:   473.956 ms/op
                 executeQuery·p0.50:   477.102 ms/op
                 executeQuery·p0.90:   483.289 ms/op
                 executeQuery·p0.95:   488.165 ms/op
                 executeQuery·p0.99:   488.636 ms/op
                 executeQuery·p0.999:  488.636 ms/op
                 executeQuery·p0.9999: 488.636 ms/op
                 executeQuery·p1.00:   488.636 ms/op

Iteration   5: 478.425 ±(99.9%) 4.004 ms/op
                 executeQuery·p0.00:   473.432 ms/op
                 executeQuery·p0.50:   477.102 ms/op
                 executeQuery·p0.90:   486.959 ms/op
                 executeQuery·p0.95:   493.827 ms/op
                 executeQuery·p0.99:   494.404 ms/op
                 executeQuery·p0.999:  494.404 ms/op
                 executeQuery·p0.9999: 494.404 ms/op
                 executeQuery·p1.00:   494.404 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 215
  mean =    473.712 ±(99.9%) 1.506 ms/op

  Histogram, ms/op:
    [460.000, 462.500) = 0 
    [462.500, 465.000) = 5 
    [465.000, 467.500) = 37 
    [467.500, 470.000) = 39 
    [470.000, 472.500) = 17 
    [472.500, 475.000) = 15 
    [475.000, 477.500) = 43 
    [477.500, 480.000) = 31 
    [480.000, 482.500) = 13 
    [482.500, 485.000) = 4 
    [485.000, 487.500) = 2 
    [487.500, 490.000) = 3 
    [490.000, 492.500) = 1 
    [492.500, 495.000) = 4 
    [495.000, 497.500) = 1 

  Percentiles, ms/op:
      p(0.0000) =    463.471 ms/op
     p(50.0000) =    474.481 ms/op
     p(90.0000) =    480.772 ms/op
     p(95.0000) =    486.225 ms/op
     p(99.0000) =    494.844 ms/op
     p(99.9000) =    495.452 ms/op
     p(99.9900) =    495.452 ms/op
     p(99.9990) =    495.452 ms/op
     p(99.9999) =    495.452 ms/op
    p(100.0000) =    495.452 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192)

# Run progress: 10.76% complete, ETA 22:26:37
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

705.467 ±(99.9%) 69.730 ms/op
# Warmup Iteration   2: 677.520 ±(99.9%) 16.469 ms/op
# Warmup Iteration   3: 685.000 ±(99.9%) 12.305 ms/op
# Warmup Iteration   4: 684.580 ±(99.9%) 14.392 ms/op
# Warmup Iteration   5: 687.796 ±(99.9%) 19.073 ms/op
Iteration   1: 692.340 ±(99.9%) 7.988 ms/op
                 executeQuery·p0.00:   685.769 ms/op
                 executeQuery·p0.50:   691.012 ms/op
                 executeQuery·p0.90:   707.579 ms/op
                 executeQuery·p0.95:   715.129 ms/op
                 executeQuery·p0.99:   715.129 ms/op
                 executeQuery·p0.999:  715.129 ms/op
                 executeQuery·p0.9999: 715.129 ms/op
                 executeQuery·p1.00:   715.129 ms/op

Iteration   2: 684.161 ±(99.9%) 14.342 ms/op
                 executeQuery·p0.00:   650.117 ms/op
                 executeQuery·p0.50:   681.574 ms/op
                 executeQuery·p0.90:   702.546 ms/op
                 executeQuery·p0.95:   705.692 ms/op
                 executeQuery·p0.99:   705.692 ms/op
                 executeQuery·p0.999:  705.692 ms/op
                 executeQuery·p0.9999: 705.692 ms/op
                 executeQuery·p1.00:   705.692 ms/op

Iteration   3: 687.796 ±(99.9%) 13.062 ms/op
                 executeQuery·p0.00:   657.457 ms/op
                 executeQuery·p0.50:   691.012 ms/op
                 executeQuery·p0.90:   700.658 ms/op
                 executeQuery·p0.95:   702.546 ms/op
                 executeQuery·p0.99:   702.546 ms/op
                 executeQuery·p0.999:  702.546 ms/op
                 executeQuery·p0.9999: 702.546 ms/op
                 executeQuery·p1.00:   702.546 ms/op

Iteration   4: 690.662 ±(99.9%) 9.742 ms/op
                 executeQuery·p0.00:   670.040 ms/op
                 executeQuery·p0.50:   691.012 ms/op
                 executeQuery·p0.90:   701.288 ms/op
                 executeQuery·p0.95:   702.546 ms/op
                 executeQuery·p0.99:   702.546 ms/op
                 executeQuery·p0.999:  702.546 ms/op
                 executeQuery·p0.9999: 702.546 ms/op
                 executeQuery·p1.00:   702.546 ms/op

Iteration   5: 666.125 ±(99.9%) 13.791 ms/op
                 executeQuery·p0.00:   645.923 ms/op
                 executeQuery·p0.50:   670.040 ms/op
                 executeQuery·p0.90:   681.365 ms/op
                 executeQuery·p0.95:   692.060 ms/op
                 executeQuery·p0.99:   692.060 ms/op
                 executeQuery·p0.999:  692.060 ms/op
                 executeQuery·p0.9999: 692.060 ms/op
                 executeQuery·p1.00:   692.060 ms/op


# Run progress: 11.08% complete, ETA 21:57:37
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

691.012 ±(99.9%) 45.161 ms/op
# Warmup Iteration   2: 675.912 ±(99.9%) 19.899 ms/op
# Warmup Iteration   3: 685.909 ±(99.9%) 17.479 ms/op
# Warmup Iteration   4: 681.015 ±(99.9%) 15.340 ms/op
# Warmup Iteration   5: 679.547 ±(99.9%) 13.240 ms/op
Iteration   1: 684.161 ±(99.9%) 13.249 ms/op
                 executeQuery·p0.00:   655.360 ms/op
                 executeQuery·p0.50:   685.769 ms/op
                 executeQuery·p0.90:   697.932 ms/op
                 executeQuery·p0.95:   706.740 ms/op
                 executeQuery·p0.99:   706.740 ms/op
                 executeQuery·p0.999:  706.740 ms/op
                 executeQuery·p0.9999: 706.740 ms/op
                 executeQuery·p1.00:   706.740 ms/op

Iteration   2: 677.310 ±(99.9%) 12.181 ms/op
                 executeQuery·p0.00:   659.554 ms/op
                 executeQuery·p0.50:   682.623 ms/op
                 executeQuery·p0.90:   691.641 ms/op
                 executeQuery·p0.95:   697.303 ms/op
                 executeQuery·p0.99:   697.303 ms/op
                 executeQuery·p0.999:  697.303 ms/op
                 executeQuery·p0.9999: 697.303 ms/op
                 executeQuery·p1.00:   697.303 ms/op

Iteration   3: 681.854 ±(99.9%) 6.543 ms/op
                 executeQuery·p0.00:   661.651 ms/op
                 executeQuery·p0.50:   683.672 ms/op
                 executeQuery·p0.90:   686.188 ms/op
                 executeQuery·p0.95:   686.817 ms/op
                 executeQuery·p0.99:   686.817 ms/op
                 executeQuery·p0.999:  686.817 ms/op
                 executeQuery·p0.9999: 686.817 ms/op
                 executeQuery·p1.00:   686.817 ms/op

Iteration   4: 682.763 ±(99.9%) 14.560 ms/op
                 executeQuery·p0.00:   657.457 ms/op
                 executeQuery·p0.50:   685.769 ms/op
                 executeQuery·p0.90:   699.820 ms/op
                 executeQuery·p0.95:   706.740 ms/op
                 executeQuery·p0.99:   706.740 ms/op
                 executeQuery·p0.999:  706.740 ms/op
                 executeQuery·p0.9999: 706.740 ms/op
                 executeQuery·p1.00:   706.740 ms/op

Iteration   5: 689.683 ±(99.9%) 17.451 ms/op
                 executeQuery·p0.00:   645.923 ms/op
                 executeQuery·p0.50:   688.914 ms/op
                 executeQuery·p0.90:   712.193 ms/op
                 executeQuery·p0.95:   714.080 ms/op
                 executeQuery·p0.99:   714.080 ms/op
                 executeQuery·p0.999:  714.080 ms/op
                 executeQuery·p0.9999: 714.080 ms/op
                 executeQuery·p1.00:   714.080 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 150
  mean =    683.686 ±(99.9%) 3.734 ms/op

  Histogram, ms/op:
    [640.000, 645.000) = 0 
    [645.000, 650.000) = 5 
    [650.000, 655.000) = 1 
    [655.000, 660.000) = 4 
    [660.000, 665.000) = 5 
    [665.000, 670.000) = 5 
    [670.000, 675.000) = 12 
    [675.000, 680.000) = 9 
    [680.000, 685.000) = 37 
    [685.000, 690.000) = 25 
    [690.000, 695.000) = 18 
    [695.000, 700.000) = 17 
    [700.000, 705.000) = 6 
    [705.000, 710.000) = 3 
    [710.000, 715.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =    645.923 ms/op
     p(50.0000) =    684.720 ms/op
     p(90.0000) =    699.295 ms/op
     p(95.0000) =    702.546 ms/op
     p(99.0000) =    714.594 ms/op
     p(99.9000) =    715.129 ms/op
     p(99.9900) =    715.129 ms/op
     p(99.9990) =    715.129 ms/op
     p(99.9999) =    715.129 ms/op
    p(100.0000) =    715.129 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144)

# Run progress: 11.39% complete, ETA 21:30:07
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3380.609 ms/op
# Warmup Iteration   2: 2462.056 ms/op
# Warmup Iteration   3: 2306.867 ms/op
# Warmup Iteration   4: 2294.284 ms/op
# Warmup Iteration   5: 2491.417 ms/op
Iteration   1: 2839.544 ms/op
                 executeQuery·p0.00:   2839.544 ms/op
                 executeQuery·p0.50:   2839.544 ms/op
                 executeQuery·p0.90:   2839.544 ms/op
                 executeQuery·p0.95:   2839.544 ms/op
                 executeQuery·p0.99:   2839.544 ms/op
                 executeQuery·p0.999:  2839.544 ms/op
                 executeQuery·p0.9999: 2839.544 ms/op
                 executeQuery·p1.00:   2839.544 ms/op

Iteration   2: 2642.412 ms/op
                 executeQuery·p0.00:   2642.412 ms/op
                 executeQuery·p0.50:   2642.412 ms/op
                 executeQuery·p0.90:   2642.412 ms/op
                 executeQuery·p0.95:   2642.412 ms/op
                 executeQuery·p0.99:   2642.412 ms/op
                 executeQuery·p0.999:  2642.412 ms/op
                 executeQuery·p0.9999: 2642.412 ms/op
                 executeQuery·p1.00:   2642.412 ms/op

Iteration   3: 2751.463 ms/op
                 executeQuery·p0.00:   2751.463 ms/op
                 executeQuery·p0.50:   2751.463 ms/op
                 executeQuery·p0.90:   2751.463 ms/op
                 executeQuery·p0.95:   2751.463 ms/op
                 executeQuery·p0.99:   2751.463 ms/op
                 executeQuery·p0.999:  2751.463 ms/op
                 executeQuery·p0.9999: 2751.463 ms/op
                 executeQuery·p1.00:   2751.463 ms/op

Iteration   4: 2617.246 ms/op
                 executeQuery·p0.00:   2617.246 ms/op
                 executeQuery·p0.50:   2617.246 ms/op
                 executeQuery·p0.90:   2617.246 ms/op
                 executeQuery·p0.95:   2617.246 ms/op
                 executeQuery·p0.99:   2617.246 ms/op
                 executeQuery·p0.999:  2617.246 ms/op
                 executeQuery·p0.9999: 2617.246 ms/op
                 executeQuery·p1.00:   2617.246 ms/op

Iteration   5: 2441.085 ms/op
                 executeQuery·p0.00:   2441.085 ms/op
                 executeQuery·p0.50:   2441.085 ms/op
                 executeQuery·p0.90:   2441.085 ms/op
                 executeQuery·p0.95:   2441.085 ms/op
                 executeQuery·p0.99:   2441.085 ms/op
                 executeQuery·p0.999:  2441.085 ms/op
                 executeQuery·p0.9999: 2441.085 ms/op
                 executeQuery·p1.00:   2441.085 ms/op


# Run progress: 11.71% complete, ETA 21:05:34
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3401.581 ms/op
# Warmup Iteration   2: 2965.373 ms/op
# Warmup Iteration   3: 2445.279 ms/op
# Warmup Iteration   4: 2793.406 ms/op
# Warmup Iteration   5: 2415.919 ms/op
Iteration   1: 2524.971 ms/op
                 executeQuery·p0.00:   2524.971 ms/op
                 executeQuery·p0.50:   2524.971 ms/op
                 executeQuery·p0.90:   2524.971 ms/op
                 executeQuery·p0.95:   2524.971 ms/op
                 executeQuery·p0.99:   2524.971 ms/op
                 executeQuery·p0.999:  2524.971 ms/op
                 executeQuery·p0.9999: 2524.971 ms/op
                 executeQuery·p1.00:   2524.971 ms/op

Iteration   2: 2466.251 ms/op
                 executeQuery·p0.00:   2466.251 ms/op
                 executeQuery·p0.50:   2466.251 ms/op
                 executeQuery·p0.90:   2466.251 ms/op
                 executeQuery·p0.95:   2466.251 ms/op
                 executeQuery·p0.99:   2466.251 ms/op
                 executeQuery·p0.999:  2466.251 ms/op
                 executeQuery·p0.9999: 2466.251 ms/op
                 executeQuery·p1.00:   2466.251 ms/op

Iteration   3: 2078.278 ms/op
                 executeQuery·p0.00:   2078.278 ms/op
                 executeQuery·p0.50:   2078.278 ms/op
                 executeQuery·p0.90:   2078.278 ms/op
                 executeQuery·p0.95:   2078.278 ms/op
                 executeQuery·p0.99:   2078.278 ms/op
                 executeQuery·p0.999:  2078.278 ms/op
                 executeQuery·p0.9999: 2078.278 ms/op
                 executeQuery·p1.00:   2078.278 ms/op

Iteration   4: 2078.278 ms/op
                 executeQuery·p0.00:   2078.278 ms/op
                 executeQuery·p0.50:   2078.278 ms/op
                 executeQuery·p0.90:   2078.278 ms/op
                 executeQuery·p0.95:   2078.278 ms/op
                 executeQuery·p0.99:   2078.278 ms/op
                 executeQuery·p0.999:  2078.278 ms/op
                 executeQuery·p0.9999: 2078.278 ms/op
                 executeQuery·p1.00:   2078.278 ms/op

Iteration   5: 2095.055 ms/op
                 executeQuery·p0.00:   2095.055 ms/op
                 executeQuery·p0.50:   2095.055 ms/op
                 executeQuery·p0.90:   2095.055 ms/op
                 executeQuery·p0.95:   2095.055 ms/op
                 executeQuery·p0.99:   2095.055 ms/op
                 executeQuery·p0.999:  2095.055 ms/op
                 executeQuery·p0.9999: 2095.055 ms/op
                 executeQuery·p1.00:   2095.055 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =   2453.458 ±(99.9%) 426.370 ms/op

  Histogram, ms/op:
    [2000.000, 2050.000) = 0 
    [2050.000, 2100.000) = 3 
    [2100.000, 2150.000) = 0 
    [2150.000, 2200.000) = 0 
    [2200.000, 2250.000) = 0 
    [2250.000, 2300.000) = 0 
    [2300.000, 2350.000) = 0 
    [2350.000, 2400.000) = 0 
    [2400.000, 2450.000) = 1 
    [2450.000, 2500.000) = 1 
    [2500.000, 2550.000) = 1 
    [2550.000, 2600.000) = 0 
    [2600.000, 2650.000) = 2 
    [2650.000, 2700.000) = 0 
    [2700.000, 2750.000) = 0 
    [2750.000, 2800.000) = 1 
    [2800.000, 2850.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2078.278 ms/op
     p(50.0000) =   2495.611 ms/op
     p(90.0000) =   2830.736 ms/op
     p(95.0000) =   2839.544 ms/op
     p(99.0000) =   2839.544 ms/op
     p(99.9000) =   2839.544 ms/op
     p(99.9900) =   2839.544 ms/op
     p(99.9990) =   2839.544 ms/op
     p(99.9999) =   2839.544 ms/op
    p(100.0000) =   2839.544 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288)

# Run progress: 12.03% complete, ETA 20:42:10
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5846.860 ms/op
# Warmup Iteration   2: 5192.548 ms/op
# Warmup Iteration   3: 5108.662 ms/op
# Warmup Iteration   4: 5209.326 ms/op
# Warmup Iteration   5: 4907.336 ms/op
Iteration   1: 5142.217 ms/op
                 executeQuery·p0.00:   5142.217 ms/op
                 executeQuery·p0.50:   5142.217 ms/op
                 executeQuery·p0.90:   5142.217 ms/op
                 executeQuery·p0.95:   5142.217 ms/op
                 executeQuery·p0.99:   5142.217 ms/op
                 executeQuery·p0.999:  5142.217 ms/op
                 executeQuery·p0.9999: 5142.217 ms/op
                 executeQuery·p1.00:   5142.217 ms/op

Iteration   2: 5309.989 ms/op
                 executeQuery·p0.00:   5309.989 ms/op
                 executeQuery·p0.50:   5309.989 ms/op
                 executeQuery·p0.90:   5309.989 ms/op
                 executeQuery·p0.95:   5309.989 ms/op
                 executeQuery·p0.99:   5309.989 ms/op
                 executeQuery·p0.999:  5309.989 ms/op
                 executeQuery·p0.9999: 5309.989 ms/op
                 executeQuery·p1.00:   5309.989 ms/op

Iteration   3: 4974.445 ms/op
                 executeQuery·p0.00:   4974.445 ms/op
                 executeQuery·p0.50:   4974.445 ms/op
                 executeQuery·p0.90:   4974.445 ms/op
                 executeQuery·p0.95:   4974.445 ms/op
                 executeQuery·p0.99:   4974.445 ms/op
                 executeQuery·p0.999:  4974.445 ms/op
                 executeQuery·p0.9999: 4974.445 ms/op
                 executeQuery·p1.00:   4974.445 ms/op

Iteration   4: 4907.336 ms/op
                 executeQuery·p0.00:   4907.336 ms/op
                 executeQuery·p0.50:   4907.336 ms/op
                 executeQuery·p0.90:   4907.336 ms/op
                 executeQuery·p0.95:   4907.336 ms/op
                 executeQuery·p0.99:   4907.336 ms/op
                 executeQuery·p0.999:  4907.336 ms/op
                 executeQuery·p0.9999: 4907.336 ms/op
                 executeQuery·p1.00:   4907.336 ms/op

Iteration   5: 4882.170 ms/op
                 executeQuery·p0.00:   4882.170 ms/op
                 executeQuery·p0.50:   4882.170 ms/op
                 executeQuery·p0.90:   4882.170 ms/op
                 executeQuery·p0.95:   4882.170 ms/op
                 executeQuery·p0.99:   4882.170 ms/op
                 executeQuery·p0.999:  4882.170 ms/op
                 executeQuery·p0.9999: 4882.170 ms/op
                 executeQuery·p1.00:   4882.170 ms/op


# Run progress: 12.34% complete, ETA 20:55:09
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5796.528 ms/op
# Warmup Iteration   2: 5251.269 ms/op
# Warmup Iteration   3: 5091.885 ms/op
# Warmup Iteration   4: 5326.766 ms/op
# Warmup Iteration   5: 5318.377 ms/op
Iteration   1: 5091.885 ms/op
                 executeQuery·p0.00:   5091.885 ms/op
                 executeQuery·p0.50:   5091.885 ms/op
                 executeQuery·p0.90:   5091.885 ms/op
                 executeQuery·p0.95:   5091.885 ms/op
                 executeQuery·p0.99:   5091.885 ms/op
                 executeQuery·p0.999:  5091.885 ms/op
                 executeQuery·p0.9999: 5091.885 ms/op
                 executeQuery·p1.00:   5091.885 ms/op

Iteration   2: 5385.486 ms/op
                 executeQuery·p0.00:   5385.486 ms/op
                 executeQuery·p0.50:   5385.486 ms/op
                 executeQuery·p0.90:   5385.486 ms/op
                 executeQuery·p0.95:   5385.486 ms/op
                 executeQuery·p0.99:   5385.486 ms/op
                 executeQuery·p0.999:  5385.486 ms/op
                 executeQuery·p0.9999: 5385.486 ms/op
                 executeQuery·p1.00:   5385.486 ms/op

Iteration   3: 4974.445 ms/op
                 executeQuery·p0.00:   4974.445 ms/op
                 executeQuery·p0.50:   4974.445 ms/op
                 executeQuery·p0.90:   4974.445 ms/op
                 executeQuery·p0.95:   4974.445 ms/op
                 executeQuery·p0.99:   4974.445 ms/op
                 executeQuery·p0.999:  4974.445 ms/op
                 executeQuery·p0.9999: 4974.445 ms/op
                 executeQuery·p1.00:   4974.445 ms/op

Iteration   4: 4789.895 ms/op
                 executeQuery·p0.00:   4789.895 ms/op
                 executeQuery·p0.50:   4789.895 ms/op
                 executeQuery·p0.90:   4789.895 ms/op
                 executeQuery·p0.95:   4789.895 ms/op
                 executeQuery·p0.99:   4789.895 ms/op
                 executeQuery·p0.999:  4789.895 ms/op
                 executeQuery·p0.9999: 4789.895 ms/op
                 executeQuery·p1.00:   4789.895 ms/op

Iteration   5: 4873.781 ms/op
                 executeQuery·p0.00:   4873.781 ms/op
                 executeQuery·p0.50:   4873.781 ms/op
                 executeQuery·p0.90:   4873.781 ms/op
                 executeQuery·p0.95:   4873.781 ms/op
                 executeQuery·p0.99:   4873.781 ms/op
                 executeQuery·p0.999:  4873.781 ms/op
                 executeQuery·p0.9999: 4873.781 ms/op
                 executeQuery·p1.00:   4873.781 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =   5033.165 ±(99.9%) 296.525 ms/op

  Histogram, ms/op:
    [4700.000, 4750.000) = 0 
    [4750.000, 4800.000) = 1 
    [4800.000, 4850.000) = 0 
    [4850.000, 4900.000) = 2 
    [4900.000, 4950.000) = 1 
    [4950.000, 5000.000) = 2 
    [5000.000, 5050.000) = 0 
    [5050.000, 5100.000) = 1 
    [5100.000, 5150.000) = 1 
    [5150.000, 5200.000) = 0 
    [5200.000, 5250.000) = 0 
    [5250.000, 5300.000) = 0 
    [5300.000, 5350.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4789.895 ms/op
     p(50.0000) =   4974.445 ms/op
     p(90.0000) =   5377.937 ms/op
     p(95.0000) =   5385.486 ms/op
     p(99.0000) =   5385.486 ms/op
     p(99.9000) =   5385.486 ms/op
     p(99.9900) =   5385.486 ms/op
     p(99.9990) =   5385.486 ms/op
     p(99.9999) =   5385.486 ms/op
    p(100.0000) =   5385.486 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2)

# Run progress: 12.66% complete, ETA 21:06:54
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6379.536 ms/op
# Warmup Iteration   2: 3728.736 ±(99.9%) 7215.611 ms/op
# Warmup Iteration   3: 3372.220 ±(99.9%) 76.520 ms/op
# Warmup Iteration   4: 3365.230 ±(99.9%) 44.179 ms/op
# Warmup Iteration   5: 3366.628 ±(99.9%) 44.179 ms/op
Iteration   1: 3372.220 ±(99.9%) 202.452 ms/op
                 executeQuery·p0.00:   3359.638 ms/op
                 executeQuery·p0.50:   3376.415 ms/op
                 executeQuery·p0.90:   3380.609 ms/op
                 executeQuery·p0.95:   3380.609 ms/op
                 executeQuery·p0.99:   3380.609 ms/op
                 executeQuery·p0.999:  3380.609 ms/op
                 executeQuery·p0.9999: 3380.609 ms/op
                 executeQuery·p1.00:   3380.609 ms/op

Iteration   2: 3365.230 ±(99.9%) 116.886 ms/op
                 executeQuery·p0.00:   3359.638 ms/op
                 executeQuery·p0.50:   3363.832 ms/op
                 executeQuery·p0.90:   3372.220 ms/op
                 executeQuery·p0.95:   3372.220 ms/op
                 executeQuery·p0.99:   3372.220 ms/op
                 executeQuery·p0.999:  3372.220 ms/op
                 executeQuery·p0.9999: 3372.220 ms/op
                 executeQuery·p1.00:   3372.220 ms/op

Iteration   3: 3414.163 ±(99.9%) 1657.142 ms/op
                 executeQuery·p0.00:   3359.638 ms/op
                 executeQuery·p0.50:   3363.832 ms/op
                 executeQuery·p0.90:   3519.021 ms/op
                 executeQuery·p0.95:   3519.021 ms/op
                 executeQuery·p0.99:   3519.021 ms/op
                 executeQuery·p0.999:  3519.021 ms/op
                 executeQuery·p0.9999: 3519.021 ms/op
                 executeQuery·p1.00:   3519.021 ms/op

Iteration   4: 3365.230 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3363.832 ms/op
                 executeQuery·p0.90:   3368.026 ms/op
                 executeQuery·p0.95:   3368.026 ms/op
                 executeQuery·p0.99:   3368.026 ms/op
                 executeQuery·p0.999:  3368.026 ms/op
                 executeQuery·p0.9999: 3368.026 ms/op
                 executeQuery·p1.00:   3368.026 ms/op

Iteration   5: 3366.628 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3368.026 ms/op
                 executeQuery·p0.95:   3368.026 ms/op
                 executeQuery·p0.99:   3368.026 ms/op
                 executeQuery·p0.999:  3368.026 ms/op
                 executeQuery·p0.9999: 3368.026 ms/op
                 executeQuery·p1.00:   3368.026 ms/op


# Run progress: 12.97% complete, ETA 20:43:27
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3377.988 ±(99.9%) 6179.484 ms/op
# Warmup Iteration   2: 3361.036 ±(99.9%) 44.179 ms/op
# Warmup Iteration   3: 3366.628 ±(99.9%) 116.886 ms/op
# Warmup Iteration   4: 3362.434 ±(99.9%) 44.179 ms/op
# Warmup Iteration   5: 3366.628 ±(99.9%) 159.288 ms/op
Iteration   1: 3361.036 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   3359.638 ms/op
                 executeQuery·p0.50:   3359.638 ms/op
                 executeQuery·p0.90:   3363.832 ms/op
                 executeQuery·p0.95:   3363.832 ms/op
                 executeQuery·p0.99:   3363.832 ms/op
                 executeQuery·p0.999:  3363.832 ms/op
                 executeQuery·p0.9999: 3363.832 ms/op
                 executeQuery·p1.00:   3363.832 ms/op

Iteration   2: 3368.026 ±(99.9%) 76.520 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3372.220 ms/op
                 executeQuery·p0.95:   3372.220 ms/op
                 executeQuery·p0.99:   3372.220 ms/op
                 executeQuery·p0.999:  3372.220 ms/op
                 executeQuery·p0.9999: 3372.220 ms/op
                 executeQuery·p1.00:   3372.220 ms/op

Iteration   3: 3368.026 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   3368.026 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3368.026 ms/op
                 executeQuery·p0.95:   3368.026 ms/op
                 executeQuery·p0.99:   3368.026 ms/op
                 executeQuery·p0.999:  3368.026 ms/op
                 executeQuery·p0.9999: 3368.026 ms/op
                 executeQuery·p1.00:   3368.026 ms/op

Iteration   4: 3366.628 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3368.026 ms/op
                 executeQuery·p0.95:   3368.026 ms/op
                 executeQuery·p0.99:   3368.026 ms/op
                 executeQuery·p0.999:  3368.026 ms/op
                 executeQuery·p0.9999: 3368.026 ms/op
                 executeQuery·p1.00:   3368.026 ms/op

Iteration   5: 3394.590 ±(99.9%) 971.931 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3363.832 ms/op
                 executeQuery·p0.90:   3456.106 ms/op
                 executeQuery·p0.95:   3456.106 ms/op
                 executeQuery·p0.99:   3456.106 ms/op
                 executeQuery·p0.999:  3456.106 ms/op
                 executeQuery·p0.9999: 3456.106 ms/op
                 executeQuery·p1.00:   3456.106 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 30
  mean =   3374.178 ±(99.9%) 21.565 ms/op

  Histogram, ms/op:
    [3300.000, 3325.000) = 0 
    [3325.000, 3350.000) = 0 
    [3350.000, 3375.000) = 26 
    [3375.000, 3400.000) = 2 
    [3400.000, 3425.000) = 0 
    [3425.000, 3450.000) = 0 
    [3450.000, 3475.000) = 1 
    [3475.000, 3500.000) = 0 
    [3500.000, 3525.000) = 1 
    [3525.000, 3550.000) = 0 
    [3550.000, 3575.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   3359.638 ms/op
     p(50.0000) =   3365.929 ms/op
     p(90.0000) =   3380.190 ms/op
     p(95.0000) =   3484.418 ms/op
     p(99.0000) =   3519.021 ms/op
     p(99.9000) =   3519.021 ms/op
     p(99.9900) =   3519.021 ms/op
     p(99.9990) =   3519.021 ms/op
     p(99.9999) =   3519.021 ms/op
    p(100.0000) =   3519.021 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16)

# Run progress: 13.29% complete, ETA 20:20:59
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6450.840 ms/op
# Warmup Iteration   2: 4728.379 ±(99.9%) 6602.607 ms/op
# Warmup Iteration   3: 4585.772 ±(99.9%) 385.141 ms/op
# Warmup Iteration   4: 4616.531 ±(99.9%) 1283.465 ms/op
# Warmup Iteration   5: 4588.569 ±(99.9%) 551.792 ms/op
Iteration   1: 4580.180 ±(99.9%) 404.904 ms/op
                 executeQuery·p0.00:   4563.403 ms/op
                 executeQuery·p0.50:   4571.791 ms/op
                 executeQuery·p0.90:   4605.346 ms/op
                 executeQuery·p0.95:   4605.346 ms/op
                 executeQuery·p0.99:   4605.346 ms/op
                 executeQuery·p0.999:  4605.346 ms/op
                 executeQuery·p0.9999: 4605.346 ms/op
                 executeQuery·p1.00:   4605.346 ms/op

Iteration   2: 4571.791 ±(99.9%) 265.072 ms/op
                 executeQuery·p0.00:   4563.403 ms/op
                 executeQuery·p0.50:   4563.403 ms/op
                 executeQuery·p0.90:   4588.569 ms/op
                 executeQuery·p0.95:   4588.569 ms/op
                 executeQuery·p0.99:   4588.569 ms/op
                 executeQuery·p0.999:  4588.569 ms/op
                 executeQuery·p0.9999: 4588.569 ms/op
                 executeQuery·p1.00:   4588.569 ms/op

Iteration   3: 4602.550 ±(99.9%) 922.478 ms/op
                 executeQuery·p0.00:   4555.014 ms/op
                 executeQuery·p0.50:   4596.957 ms/op
                 executeQuery·p0.90:   4655.677 ms/op
                 executeQuery·p0.95:   4655.677 ms/op
                 executeQuery·p0.99:   4655.677 ms/op
                 executeQuery·p0.999:  4655.677 ms/op
                 executeQuery·p0.9999: 4655.677 ms/op
                 executeQuery·p1.00:   4655.677 ms/op

Iteration   4: 4568.995 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4563.403 ms/op
                 executeQuery·p0.50:   4571.791 ms/op
                 executeQuery·p0.90:   4571.791 ms/op
                 executeQuery·p0.95:   4571.791 ms/op
                 executeQuery·p0.99:   4571.791 ms/op
                 executeQuery·p0.999:  4571.791 ms/op
                 executeQuery·p0.9999: 4571.791 ms/op
                 executeQuery·p1.00:   4571.791 ms/op

Iteration   5: 4568.995 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4563.403 ms/op
                 executeQuery·p0.50:   4571.791 ms/op
                 executeQuery·p0.90:   4571.791 ms/op
                 executeQuery·p0.95:   4571.791 ms/op
                 executeQuery·p0.99:   4571.791 ms/op
                 executeQuery·p0.999:  4571.791 ms/op
                 executeQuery·p0.9999: 4571.791 ms/op
                 executeQuery·p1.00:   4571.791 ms/op


# Run progress: 13.61% complete, ETA 20:02:56
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_680108970 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_680108970() {
        this(4);
    }
    public KeyValueMap_680108970(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_680108970 aggregation_state_map = new KeyValueMap_680108970();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

4596.957 ±(99.9%) 5447.430 ms/op
# Warmup Iteration   2: 4650.085 ±(99.9%) 4064.439 ms/op
# Warmup Iteration   3: 4538.237 ±(99.9%) 306.079 ms/op
# Warmup Iteration   4: 4521.460 ±(99.9%) 0.001 ms/op
# Warmup Iteration   5: 4527.052 ±(99.9%) 88.357 ms/op
Iteration   1: 4532.645 ±(99.9%) 233.772 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4546.626 ms/op
                 executeQuery·p0.95:   4546.626 ms/op
                 executeQuery·p0.99:   4546.626 ms/op
                 executeQuery·p0.999:  4546.626 ms/op
                 executeQuery·p0.9999: 4546.626 ms/op
                 executeQuery·p1.00:   4546.626 ms/op

Iteration   2: 4527.052 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4529.848 ms/op
                 executeQuery·p0.95:   4529.848 ms/op
                 executeQuery·p0.99:   4529.848 ms/op
                 executeQuery·p0.999:  4529.848 ms/op
                 executeQuery·p0.9999: 4529.848 ms/op
                 executeQuery·p1.00:   4529.848 ms/op

Iteration   3: 4532.645 ±(99.9%) 353.429 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4521.460 ms/op
                 executeQuery·p0.90:   4555.014 ms/op
                 executeQuery·p0.95:   4555.014 ms/op
                 executeQuery·p0.99:   4555.014 ms/op
                 executeQuery·p0.999:  4555.014 ms/op
                 executeQuery·p0.9999: 4555.014 ms/op
                 executeQuery·p1.00:   4555.014 ms/op

Iteration   4: 4524.256 ±(99.9%) 176.715 ms/op
                 executeQuery·p0.00:   4513.071 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4529.848 ms/op
                 executeQuery·p0.95:   4529.848 ms/op
                 executeQuery·p0.99:   4529.848 ms/op
                 executeQuery·p0.999:  4529.848 ms/op
                 executeQuery·p0.9999: 4529.848 ms/op
                 executeQuery·p1.00:   4529.848 ms/op

Iteration   5: 4524.256 ±(99.9%) 176.715 ms/op
                 executeQuery·p0.00:   4513.071 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4529.848 ms/op
                 executeQuery·p0.95:   4529.848 ms/op
                 executeQuery·p0.99:   4529.848 ms/op
                 executeQuery·p0.999:  4529.848 ms/op
                 executeQuery·p0.9999: 4529.848 ms/op
                 executeQuery·p1.00:   4529.848 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 30
  mean =   4553.336 ±(99.9%) 21.400 ms/op

  Histogram, ms/op:
    [4500.000, 4512.500) = 0 
    [4512.500, 4525.000) = 6 
    [4525.000, 4537.500) = 7 
    [4537.500, 4550.000) = 1 
    [4550.000, 4562.500) = 2 
    [4562.500, 4575.000) = 10 
    [4575.000, 4587.500) = 0 
    [4587.500, 4600.000) = 2 
    [4600.000, 4612.500) = 1 
    [4612.500, 4625.000) = 0 
    [4625.000, 4637.500) = 0 
    [4637.500, 4650.000) = 0 
    [4650.000, 4662.500) = 1 
    [4662.500, 4675.000) = 0 
    [4675.000, 4687.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   4513.071 ms/op
     p(50.0000) =   4555.014 ms/op
     p(90.0000) =   4596.118 ms/op
     p(95.0000) =   4627.995 ms/op
     p(99.0000) =   4655.677 ms/op
     p(99.9000) =   4655.677 ms/op
     p(99.9900) =   4655.677 ms/op
     p(99.9990) =   4655.677 ms/op
     p(99.9999) =   4655.677 ms/op
    p(100.0000) =   4655.677 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192)

# Run progress: 13.92% complete, ETA 19:45:32
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

7906.263 ms/op
# Warmup Iteration   2: 6702.498 ms/op
# Warmup Iteration   3: 6463.422 ms/op
# Warmup Iteration   4: 6459.228 ms/op
# Warmup Iteration   5: 6488.588 ms/op
Iteration   1: 6463.422 ms/op
                 executeQuery·p0.00:   6383.731 ms/op
                 executeQuery·p0.50:   6463.422 ms/op
                 executeQuery·p0.90:   6543.114 ms/op
                 executeQuery·p0.95:   6543.114 ms/op
                 executeQuery·p0.99:   6543.114 ms/op
                 executeQuery·p0.999:  6543.114 ms/op
                 executeQuery·p0.9999: 6543.114 ms/op
                 executeQuery·p1.00:   6543.114 ms/op

Iteration   2: 6366.953 ms/op
                 executeQuery·p0.00:   6358.565 ms/op
                 executeQuery·p0.50:   6366.953 ms/op
                 executeQuery·p0.90:   6375.342 ms/op
                 executeQuery·p0.95:   6375.342 ms/op
                 executeQuery·p0.99:   6375.342 ms/op
                 executeQuery·p0.999:  6375.342 ms/op
                 executeQuery·p0.9999: 6375.342 ms/op
                 executeQuery·p1.00:   6375.342 ms/op

Iteration   3: 6429.868 ms/op
                 executeQuery·p0.00:   6392.119 ms/op
                 executeQuery·p0.50:   6429.868 ms/op
                 executeQuery·p0.90:   6467.617 ms/op
                 executeQuery·p0.95:   6467.617 ms/op
                 executeQuery·p0.99:   6467.617 ms/op
                 executeQuery·p0.999:  6467.617 ms/op
                 executeQuery·p0.9999: 6467.617 ms/op
                 executeQuery·p1.00:   6467.617 ms/op

Iteration   4: 6517.948 ms/op
                 executeQuery·p0.00:   6509.560 ms/op
                 executeQuery·p0.50:   6517.948 ms/op
                 executeQuery·p0.90:   6526.337 ms/op
                 executeQuery·p0.95:   6526.337 ms/op
                 executeQuery·p0.99:   6526.337 ms/op
                 executeQuery·p0.999:  6526.337 ms/op
                 executeQuery·p0.9999: 6526.337 ms/op
                 executeQuery·p1.00:   6526.337 ms/op

Iteration   5: 6387.925 ms/op
                 executeQuery·p0.00:   6375.342 ms/op
                 executeQuery·p0.50:   6387.925 ms/op
                 executeQuery·p0.90:   6400.508 ms/op
                 executeQuery·p0.95:   6400.508 ms/op
                 executeQuery·p0.99:   6400.508 ms/op
                 executeQuery·p0.999:  6400.508 ms/op
                 executeQuery·p0.9999: 6400.508 ms/op
                 executeQuery·p1.00:   6400.508 ms/op


# Run progress: 14.24% complete, ETA 19:28:25
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6744.441 ms/op
# Warmup Iteration   2: 6576.669 ms/op
# Warmup Iteration   3: 6849.298 ms/op
# Warmup Iteration   4: 6803.161 ms/op
# Warmup Iteration   5: 6798.967 ms/op
Iteration   1: 6664.749 ms/op
                 executeQuery·p0.00:   6635.389 ms/op
                 executeQuery·p0.50:   6664.749 ms/op
                 executeQuery·p0.90:   6694.109 ms/op
                 executeQuery·p0.95:   6694.109 ms/op
                 executeQuery·p0.99:   6694.109 ms/op
                 executeQuery·p0.999:  6694.109 ms/op
                 executeQuery·p0.9999: 6694.109 ms/op
                 executeQuery·p1.00:   6694.109 ms/op

Iteration   2: 6769.607 ms/op
                 executeQuery·p0.00:   6677.332 ms/op
                 executeQuery·p0.50:   6769.607 ms/op
                 executeQuery·p0.90:   6861.881 ms/op
                 executeQuery·p0.95:   6861.881 ms/op
                 executeQuery·p0.99:   6861.881 ms/op
                 executeQuery·p0.999:  6861.881 ms/op
                 executeQuery·p0.9999: 6861.881 ms/op
                 executeQuery·p1.00:   6861.881 ms/op

Iteration   3: 6803.161 ms/op
                 executeQuery·p0.00:   6677.332 ms/op
                 executeQuery·p0.50:   6803.161 ms/op
                 executeQuery·p0.90:   6928.990 ms/op
                 executeQuery·p0.95:   6928.990 ms/op
                 executeQuery·p0.99:   6928.990 ms/op
                 executeQuery·p0.999:  6928.990 ms/op
                 executeQuery·p0.9999: 6928.990 ms/op
                 executeQuery·p1.00:   6928.990 ms/op

Iteration   4: 6777.995 ms/op
                 executeQuery·p0.00:   6694.109 ms/op
                 executeQuery·p0.50:   6777.995 ms/op
                 executeQuery·p0.90:   6861.881 ms/op
                 executeQuery·p0.95:   6861.881 ms/op
                 executeQuery·p0.99:   6861.881 ms/op
                 executeQuery·p0.999:  6861.881 ms/op
                 executeQuery·p0.9999: 6861.881 ms/op
                 executeQuery·p1.00:   6861.881 ms/op

Iteration   5: 6966.739 ms/op
                 executeQuery·p0.00:   6618.612 ms/op
                 executeQuery·p0.50:   6966.739 ms/op
                 executeQuery·p0.90:   7314.866 ms/op
                 executeQuery·p0.95:   7314.866 ms/op
                 executeQuery·p0.99:   7314.866 ms/op
                 executeQuery·p0.999:  7314.866 ms/op
                 executeQuery·p0.9999: 7314.866 ms/op
                 executeQuery·p1.00:   7314.866 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 20
  mean =   6614.837 ±(99.9%) 209.572 ms/op

  Histogram, ms/op:
    [6300.000, 6400.000) = 5 
    [6400.000, 6500.000) = 2 
    [6500.000, 6600.000) = 3 
    [6600.000, 6700.000) = 6 
    [6700.000, 6800.000) = 0 
    [6800.000, 6900.000) = 2 
    [6900.000, 7000.000) = 1 
    [7000.000, 7100.000) = 0 
    [7100.000, 7200.000) = 0 
    [7200.000, 7300.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   6358.565 ms/op
     p(50.0000) =   6580.863 ms/op
     p(90.0000) =   6922.279 ms/op
     p(95.0000) =   7295.572 ms/op
     p(99.0000) =   7314.866 ms/op
     p(99.9000) =   7314.866 ms/op
     p(99.9900) =   7314.866 ms/op
     p(99.9990) =   7314.866 ms/op
     p(99.9999) =   7314.866 ms/op
    p(100.0000) =   7314.866 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144)

# Run progress: 14.56% complete, ETA 19:12:15
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

29595.009 ms/op
# Warmup Iteration   2: 27179.090 ms/op
# Warmup Iteration   3: 23454.548 ms/op
# Warmup Iteration   4: 27246.199 ms/op
# Warmup Iteration   5: 26071.794 ms/op
Iteration   1: 25602.032 ms/op
                 executeQuery·p0.00:   25602.032 ms/op
                 executeQuery·p0.50:   25602.032 ms/op
                 executeQuery·p0.90:   25602.032 ms/op
                 executeQuery·p0.95:   25602.032 ms/op
                 executeQuery·p0.99:   25602.032 ms/op
                 executeQuery·p0.999:  25602.032 ms/op
                 executeQuery·p0.9999: 25602.032 ms/op
                 executeQuery·p1.00:   25602.032 ms/op

Iteration   2: 26575.110 ms/op
                 executeQuery·p0.00:   26575.110 ms/op
                 executeQuery·p0.50:   26575.110 ms/op
                 executeQuery·p0.90:   26575.110 ms/op
                 executeQuery·p0.95:   26575.110 ms/op
                 executeQuery·p0.99:   26575.110 ms/op
                 executeQuery·p0.999:  26575.110 ms/op
                 executeQuery·p0.9999: 26575.110 ms/op
                 executeQuery·p1.00:   26575.110 ms/op

Iteration   3: 24763.171 ms/op
                 executeQuery·p0.00:   24763.171 ms/op
                 executeQuery·p0.50:   24763.171 ms/op
                 executeQuery·p0.90:   24763.171 ms/op
                 executeQuery·p0.95:   24763.171 ms/op
                 executeQuery·p0.99:   24763.171 ms/op
                 executeQuery·p0.999:  24763.171 ms/op
                 executeQuery·p0.9999: 24763.171 ms/op
                 executeQuery·p1.00:   24763.171 ms/op

Iteration   4: 23387.439 ms/op
                 executeQuery·p0.00:   23387.439 ms/op
                 executeQuery·p0.50:   23387.439 ms/op
                 executeQuery·p0.90:   23387.439 ms/op
                 executeQuery·p0.95:   23387.439 ms/op
                 executeQuery·p0.99:   23387.439 ms/op
                 executeQuery·p0.999:  23387.439 ms/op
                 executeQuery·p0.9999: 23387.439 ms/op
                 executeQuery·p1.00:   23387.439 ms/op

Iteration   5: 26004.685 ms/op
                 executeQuery·p0.00:   26004.685 ms/op
                 executeQuery·p0.50:   26004.685 ms/op
                 executeQuery·p0.90:   26004.685 ms/op
                 executeQuery·p0.95:   26004.685 ms/op
                 executeQuery·p0.99:   26004.685 ms/op
                 executeQuery·p0.999:  26004.685 ms/op
                 executeQuery·p0.9999: 26004.685 ms/op
                 executeQuery·p1.00:   26004.685 ms/op


# Run progress: 14.87% complete, ETA 19:16:36
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

26508.001 ms/op
# Warmup Iteration   2: 25803.358 ms/op
# Warmup Iteration   3: 24360.518 ms/op
# Warmup Iteration   4: 27145.535 ms/op
# Warmup Iteration   5: 21407.728 ms/op
Iteration   1: 25434.259 ms/op
                 executeQuery·p0.00:   25434.259 ms/op
                 executeQuery·p0.50:   25434.259 ms/op
                 executeQuery·p0.90:   25434.259 ms/op
                 executeQuery·p0.95:   25434.259 ms/op
                 executeQuery·p0.99:   25434.259 ms/op
                 executeQuery·p0.999:  25434.259 ms/op
                 executeQuery·p0.9999: 25434.259 ms/op
                 executeQuery·p1.00:   25434.259 ms/op

Iteration   2: 25434.259 ms/op
                 executeQuery·p0.00:   25434.259 ms/op
                 executeQuery·p0.50:   25434.259 ms/op
                 executeQuery·p0.90:   25434.259 ms/op
                 executeQuery·p0.95:   25434.259 ms/op
                 executeQuery·p0.99:   25434.259 ms/op
                 executeQuery·p0.999:  25434.259 ms/op
                 executeQuery·p0.9999: 25434.259 ms/op
                 executeQuery·p1.00:   25434.259 ms/op

Iteration   3: 25367.151 ms/op
                 executeQuery·p0.00:   25367.151 ms/op
                 executeQuery·p0.50:   25367.151 ms/op
                 executeQuery·p0.90:   25367.151 ms/op
                 executeQuery·p0.95:   25367.151 ms/op
                 executeQuery·p0.99:   25367.151 ms/op
                 executeQuery·p0.999:  25367.151 ms/op
                 executeQuery·p0.9999: 25367.151 ms/op
                 executeQuery·p1.00:   25367.151 ms/op

Iteration   4: 26407.338 ms/op
                 executeQuery·p0.00:   26407.338 ms/op
                 executeQuery·p0.50:   26407.338 ms/op
                 executeQuery·p0.90:   26407.338 ms/op
                 executeQuery·p0.95:   26407.338 ms/op
                 executeQuery·p0.99:   26407.338 ms/op
                 executeQuery·p0.999:  26407.338 ms/op
                 executeQuery·p0.9999: 26407.338 ms/op
                 executeQuery·p1.00:   26407.338 ms/op

Iteration   5: 25669.140 ms/op
                 executeQuery·p0.00:   25669.140 ms/op
                 executeQuery·p0.50:   25669.140 ms/op
                 executeQuery·p0.90:   25669.140 ms/op
                 executeQuery·p0.95:   25669.140 ms/op
                 executeQuery·p0.99:   25669.140 ms/op
                 executeQuery·p0.999:  25669.140 ms/op
                 executeQuery·p0.9999: 25669.140 ms/op
                 executeQuery·p1.00:   25669.140 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =  25464.458 ±(99.9%) 1360.890 ms/op

  Histogram, ms/op:
    [23000.000, 23250.000) = 0 
    [23250.000, 23500.000) = 1 
    [23500.000, 23750.000) = 0 
    [23750.000, 24000.000) = 0 
    [24000.000, 24250.000) = 0 
    [24250.000, 24500.000) = 0 
    [24500.000, 24750.000) = 0 
    [24750.000, 25000.000) = 1 
    [25000.000, 25250.000) = 0 
    [25250.000, 25500.000) = 3 
    [25500.000, 25750.000) = 2 
    [25750.000, 26000.000) = 0 
    [26000.000, 26250.000) = 1 
    [26250.000, 26500.000) = 1 
    [26500.000, 26750.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  23387.439 ms/op
     p(50.0000) =  25518.146 ms/op
     p(90.0000) =  26558.333 ms/op
     p(95.0000) =  26575.110 ms/op
     p(99.0000) =  26575.110 ms/op
     p(99.9000) =  26575.110 ms/op
     p(99.9900) =  26575.110 ms/op
     p(99.9990) =  26575.110 ms/op
     p(99.9999) =  26575.110 ms/op
    p(100.0000) =  26575.110 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288)

# Run progress: 15.19% complete, ETA 19:21:04
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

52680.458 ms/op
# Warmup Iteration   2: 49593.450 ms/op
# Warmup Iteration   3: 51740.934 ms/op
# Warmup Iteration   4: 48251.273 ms/op
# Warmup Iteration   5: 50264.539 ms/op
Iteration   1: 49056.580 ms/op
                 executeQuery·p0.00:   49056.580 ms/op
                 executeQuery·p0.50:   49056.580 ms/op
                 executeQuery·p0.90:   49056.580 ms/op
                 executeQuery·p0.95:   49056.580 ms/op
                 executeQuery·p0.99:   49056.580 ms/op
                 executeQuery·p0.999:  49056.580 ms/op
                 executeQuery·p0.9999: 49056.580 ms/op
                 executeQuery·p1.00:   49056.580 ms/op

Iteration   2: 50465.866 ms/op
                 executeQuery·p0.00:   50465.866 ms/op
                 executeQuery·p0.50:   50465.866 ms/op
                 executeQuery·p0.90:   50465.866 ms/op
                 executeQuery·p0.95:   50465.866 ms/op
                 executeQuery·p0.99:   50465.866 ms/op
                 executeQuery·p0.999:  50465.866 ms/op
                 executeQuery·p0.9999: 50465.866 ms/op
                 executeQuery·p1.00:   50465.866 ms/op

Iteration   3: 50398.757 ms/op
                 executeQuery·p0.00:   50398.757 ms/op
                 executeQuery·p0.50:   50398.757 ms/op
                 executeQuery·p0.90:   50398.757 ms/op
                 executeQuery·p0.95:   50398.757 ms/op
                 executeQuery·p0.99:   50398.757 ms/op
                 executeQuery·p0.999:  50398.757 ms/op
                 executeQuery·p0.9999: 50398.757 ms/op
                 executeQuery·p1.00:   50398.757 ms/op

Iteration   4: 47445.967 ms/op
                 executeQuery·p0.00:   47445.967 ms/op
                 executeQuery·p0.50:   47445.967 ms/op
                 executeQuery·p0.90:   47445.967 ms/op
                 executeQuery·p0.95:   47445.967 ms/op
                 executeQuery·p0.99:   47445.967 ms/op
                 executeQuery·p0.999:  47445.967 ms/op
                 executeQuery·p0.9999: 47445.967 ms/op
                 executeQuery·p1.00:   47445.967 ms/op

Iteration   5: 50331.648 ms/op
                 executeQuery·p0.00:   50331.648 ms/op
                 executeQuery·p0.50:   50331.648 ms/op
                 executeQuery·p0.90:   50331.648 ms/op
                 executeQuery·p0.95:   50331.648 ms/op
                 executeQuery·p0.99:   50331.648 ms/op
                 executeQuery·p0.999:  50331.648 ms/op
                 executeQuery·p0.9999: 50331.648 ms/op
                 executeQuery·p1.00:   50331.648 ms/op


# Run progress: 15.51% complete, ETA 20:11:16
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

50801.410 ms/op
# Warmup Iteration   2: 50331.648 ms/op
# Warmup Iteration   3: 51942.261 ms/op
# Warmup Iteration   4: 48989.471 ms/op
# Warmup Iteration   5: 50667.192 ms/op
Iteration   1: 49190.797 ms/op
                 executeQuery·p0.00:   49190.797 ms/op
                 executeQuery·p0.50:   49190.797 ms/op
                 executeQuery·p0.90:   49190.797 ms/op
                 executeQuery·p0.95:   49190.797 ms/op
                 executeQuery·p0.99:   49190.797 ms/op
                 executeQuery·p0.999:  49190.797 ms/op
                 executeQuery·p0.9999: 49190.797 ms/op
                 executeQuery·p1.00:   49190.797 ms/op

Iteration   2: 50600.083 ms/op
                 executeQuery·p0.00:   50600.083 ms/op
                 executeQuery·p0.50:   50600.083 ms/op
                 executeQuery·p0.90:   50600.083 ms/op
                 executeQuery·p0.95:   50600.083 ms/op
                 executeQuery·p0.99:   50600.083 ms/op
                 executeQuery·p0.999:  50600.083 ms/op
                 executeQuery·p0.9999: 50600.083 ms/op
                 executeQuery·p1.00:   50600.083 ms/op

Iteration   3: 50465.866 ms/op
                 executeQuery·p0.00:   50465.866 ms/op
                 executeQuery·p0.50:   50465.866 ms/op
                 executeQuery·p0.90:   50465.866 ms/op
                 executeQuery·p0.95:   50465.866 ms/op
                 executeQuery·p0.99:   50465.866 ms/op
                 executeQuery·p0.999:  50465.866 ms/op
                 executeQuery·p0.9999: 50465.866 ms/op
                 executeQuery·p1.00:   50465.866 ms/op

Iteration   4: 47982.838 ms/op
                 executeQuery·p0.00:   47982.838 ms/op
                 executeQuery·p0.50:   47982.838 ms/op
                 executeQuery·p0.90:   47982.838 ms/op
                 executeQuery·p0.95:   47982.838 ms/op
                 executeQuery·p0.99:   47982.838 ms/op
                 executeQuery·p0.999:  47982.838 ms/op
                 executeQuery·p0.9999: 47982.838 ms/op
                 executeQuery·p1.00:   47982.838 ms/op

Iteration   5: 50667.192 ms/op
                 executeQuery·p0.00:   50667.192 ms/op
                 executeQuery·p0.50:   50667.192 ms/op
                 executeQuery·p0.90:   50667.192 ms/op
                 executeQuery·p0.95:   50667.192 ms/op
                 executeQuery·p0.99:   50667.192 ms/op
                 executeQuery·p0.999:  50667.192 ms/op
                 executeQuery·p0.9999: 50667.192 ms/op
                 executeQuery·p1.00:   50667.192 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =  49660.559 ±(99.9%) 1781.241 ms/op

  Histogram, ms/op:
    [47000.000, 47250.000) = 0 
    [47250.000, 47500.000) = 1 
    [47500.000, 47750.000) = 0 
    [47750.000, 48000.000) = 1 
    [48000.000, 48250.000) = 0 
    [48250.000, 48500.000) = 0 
    [48500.000, 48750.000) = 0 
    [48750.000, 49000.000) = 0 
    [49000.000, 49250.000) = 2 
    [49250.000, 49500.000) = 0 
    [49500.000, 49750.000) = 0 
    [49750.000, 50000.000) = 0 
    [50000.000, 50250.000) = 0 
    [50250.000, 50500.000) = 4 
    [50500.000, 50750.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =  47445.967 ms/op
     p(50.0000) =  50365.202 ms/op
     p(90.0000) =  50660.481 ms/op
     p(95.0000) =  50667.192 ms/op
     p(99.0000) =  50667.192 ms/op
     p(99.9000) =  50667.192 ms/op
     p(99.9900) =  50667.192 ms/op
     p(99.9990) =  50667.192 ms/op
     p(99.9999) =  50667.192 ms/op
    p(100.0000) =  50667.192 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2)

# Run progress: 15.82% complete, ETA 20:59:24
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

18287.165 ms/op
# Warmup Iteration   2: 7721.714 ms/op
# Warmup Iteration   3: 7499.416 ms/op
# Warmup Iteration   4: 6715.081 ms/op
# Warmup Iteration   5: 6731.858 ms/op
Iteration   1: 6719.275 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6719.275 ms/op
                 executeQuery·p0.90:   6719.275 ms/op
                 executeQuery·p0.95:   6719.275 ms/op
                 executeQuery·p0.99:   6719.275 ms/op
                 executeQuery·p0.999:  6719.275 ms/op
                 executeQuery·p0.9999: 6719.275 ms/op
                 executeQuery·p1.00:   6719.275 ms/op

Iteration   2: 6736.052 ms/op
                 executeQuery·p0.00:   6727.664 ms/op
                 executeQuery·p0.50:   6736.052 ms/op
                 executeQuery·p0.90:   6744.441 ms/op
                 executeQuery·p0.95:   6744.441 ms/op
                 executeQuery·p0.99:   6744.441 ms/op
                 executeQuery·p0.999:  6744.441 ms/op
                 executeQuery·p0.9999: 6744.441 ms/op
                 executeQuery·p1.00:   6744.441 ms/op

Iteration   3: 6719.275 ms/op
                 executeQuery·p0.00:   6710.886 ms/op
                 executeQuery·p0.50:   6719.275 ms/op
                 executeQuery·p0.90:   6727.664 ms/op
                 executeQuery·p0.95:   6727.664 ms/op
                 executeQuery·p0.99:   6727.664 ms/op
                 executeQuery·p0.999:  6727.664 ms/op
                 executeQuery·p0.9999: 6727.664 ms/op
                 executeQuery·p1.00:   6727.664 ms/op

Iteration   4: 6719.275 ms/op
                 executeQuery·p0.00:   6702.498 ms/op
                 executeQuery·p0.50:   6719.275 ms/op
                 executeQuery·p0.90:   6736.052 ms/op
                 executeQuery·p0.95:   6736.052 ms/op
                 executeQuery·p0.99:   6736.052 ms/op
                 executeQuery·p0.999:  6736.052 ms/op
                 executeQuery·p0.9999: 6736.052 ms/op
                 executeQuery·p1.00:   6736.052 ms/op

Iteration   5: 6723.469 ms/op
                 executeQuery·p0.00:   6710.886 ms/op
                 executeQuery·p0.50:   6723.469 ms/op
                 executeQuery·p0.90:   6736.052 ms/op
                 executeQuery·p0.95:   6736.052 ms/op
                 executeQuery·p0.99:   6736.052 ms/op
                 executeQuery·p0.999:  6736.052 ms/op
                 executeQuery·p0.9999: 6736.052 ms/op
                 executeQuery·p1.00:   6736.052 ms/op


# Run progress: 16.14% complete, ETA 20:42:35
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5725.225 ms/op
# Warmup Iteration   2: 7969.178 ms/op
# Warmup Iteration   3: 6647.972 ms/op
# Warmup Iteration   4: 7054.819 ms/op
# Warmup Iteration   5: 6702.498 ms/op
Iteration   1: 6664.749 ms/op
                 executeQuery·p0.00:   6635.389 ms/op
                 executeQuery·p0.50:   6664.749 ms/op
                 executeQuery·p0.90:   6694.109 ms/op
                 executeQuery·p0.95:   6694.109 ms/op
                 executeQuery·p0.99:   6694.109 ms/op
                 executeQuery·p0.999:  6694.109 ms/op
                 executeQuery·p0.9999: 6694.109 ms/op
                 executeQuery·p1.00:   6694.109 ms/op

Iteration   2: 6635.389 ms/op
                 executeQuery·p0.00:   6585.057 ms/op
                 executeQuery·p0.50:   6635.389 ms/op
                 executeQuery·p0.90:   6685.721 ms/op
                 executeQuery·p0.95:   6685.721 ms/op
                 executeQuery·p0.99:   6685.721 ms/op
                 executeQuery·p0.999:  6685.721 ms/op
                 executeQuery·p0.9999: 6685.721 ms/op
                 executeQuery·p1.00:   6685.721 ms/op

Iteration   3: 6694.109 ms/op
                 executeQuery·p0.00:   6685.721 ms/op
                 executeQuery·p0.50:   6694.109 ms/op
                 executeQuery·p0.90:   6702.498 ms/op
                 executeQuery·p0.95:   6702.498 ms/op
                 executeQuery·p0.99:   6702.498 ms/op
                 executeQuery·p0.999:  6702.498 ms/op
                 executeQuery·p0.9999: 6702.498 ms/op
                 executeQuery·p1.00:   6702.498 ms/op

Iteration   4: 6719.275 ms/op
                 executeQuery·p0.00:   6702.498 ms/op
                 executeQuery·p0.50:   6719.275 ms/op
                 executeQuery·p0.90:   6736.052 ms/op
                 executeQuery·p0.95:   6736.052 ms/op
                 executeQuery·p0.99:   6736.052 ms/op
                 executeQuery·p0.999:  6736.052 ms/op
                 executeQuery·p0.9999: 6736.052 ms/op
                 executeQuery·p1.00:   6736.052 ms/op

Iteration   5: 6715.081 ms/op
                 executeQuery·p0.00:   6710.886 ms/op
                 executeQuery·p0.50:   6715.081 ms/op
                 executeQuery·p0.90:   6719.275 ms/op
                 executeQuery·p0.95:   6719.275 ms/op
                 executeQuery·p0.99:   6719.275 ms/op
                 executeQuery·p0.999:  6719.275 ms/op
                 executeQuery·p0.9999: 6719.275 ms/op
                 executeQuery·p1.00:   6719.275 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 20
  mean =   6704.595 ±(99.9%) 32.307 ms/op

  Histogram, ms/op:
    [6500.000, 6525.000) = 0 
    [6525.000, 6550.000) = 0 
    [6550.000, 6575.000) = 0 
    [6575.000, 6600.000) = 1 
    [6600.000, 6625.000) = 0 
    [6625.000, 6650.000) = 1 
    [6650.000, 6675.000) = 0 
    [6675.000, 6700.000) = 3 
    [6700.000, 6725.000) = 9 
    [6725.000, 6750.000) = 6 
    [6750.000, 6775.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   6585.057 ms/op
     p(50.0000) =   6710.886 ms/op
     p(90.0000) =   6736.052 ms/op
     p(95.0000) =   6744.021 ms/op
     p(99.0000) =   6744.441 ms/op
     p(99.9000) =   6744.441 ms/op
     p(99.9900) =   6744.441 ms/op
     p(99.9990) =   6744.441 ms/op
     p(99.9999) =   6744.441 ms/op
    p(100.0000) =   6744.441 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16)

# Run progress: 16.46% complete, ETA 20:25:40
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

17280.532 ms/op
# Warmup Iteration   2: 11475.616 ms/op
# Warmup Iteration   3: 10754.195 ms/op
# Warmup Iteration   4: 11878.269 ms/op
# Warmup Iteration   5: 10989.076 ms/op
Iteration   1: 11022.631 ms/op
                 executeQuery·p0.00:   11022.631 ms/op
                 executeQuery·p0.50:   11022.631 ms/op
                 executeQuery·p0.90:   11022.631 ms/op
                 executeQuery·p0.95:   11022.631 ms/op
                 executeQuery·p0.99:   11022.631 ms/op
                 executeQuery·p0.999:  11022.631 ms/op
                 executeQuery·p0.9999: 11022.631 ms/op
                 executeQuery·p1.00:   11022.631 ms/op

Iteration   2: 10972.299 ms/op
                 executeQuery·p0.00:   10972.299 ms/op
                 executeQuery·p0.50:   10972.299 ms/op
                 executeQuery·p0.90:   10972.299 ms/op
                 executeQuery·p0.95:   10972.299 ms/op
                 executeQuery·p0.99:   10972.299 ms/op
                 executeQuery·p0.999:  10972.299 ms/op
                 executeQuery·p0.9999: 10972.299 ms/op
                 executeQuery·p1.00:   10972.299 ms/op

Iteration   3: 11005.854 ms/op
                 executeQuery·p0.00:   11005.854 ms/op
                 executeQuery·p0.50:   11005.854 ms/op
                 executeQuery·p0.90:   11005.854 ms/op
                 executeQuery·p0.95:   11005.854 ms/op
                 executeQuery·p0.99:   11005.854 ms/op
                 executeQuery·p0.999:  11005.854 ms/op
                 executeQuery·p0.9999: 11005.854 ms/op
                 executeQuery·p1.00:   11005.854 ms/op

Iteration   4: 10989.076 ms/op
                 executeQuery·p0.00:   10989.076 ms/op
                 executeQuery·p0.50:   10989.076 ms/op
                 executeQuery·p0.90:   10989.076 ms/op
                 executeQuery·p0.95:   10989.076 ms/op
                 executeQuery·p0.99:   10989.076 ms/op
                 executeQuery·p0.999:  10989.076 ms/op
                 executeQuery·p0.9999: 10989.076 ms/op
                 executeQuery·p1.00:   10989.076 ms/op

Iteration   5: 10989.076 ms/op
                 executeQuery·p0.00:   10989.076 ms/op
                 executeQuery·p0.50:   10989.076 ms/op
                 executeQuery·p0.90:   10989.076 ms/op
                 executeQuery·p0.95:   10989.076 ms/op
                 executeQuery·p0.99:   10989.076 ms/op
                 executeQuery·p0.999:  10989.076 ms/op
                 executeQuery·p0.9999: 10989.076 ms/op
                 executeQuery·p1.00:   10989.076 ms/op


# Run progress: 16.77% complete, ETA 20:07:51
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

10317.988 ms/op
# Warmup Iteration   2: 11291.066 ms/op
# Warmup Iteration   3: 10905.190 ms/op
# Warmup Iteration   4: 11727.274 ms/op
# Warmup Iteration   5: 11005.854 ms/op
Iteration   1: 10989.076 ms/op
                 executeQuery·p0.00:   10989.076 ms/op
                 executeQuery·p0.50:   10989.076 ms/op
                 executeQuery·p0.90:   10989.076 ms/op
                 executeQuery·p0.95:   10989.076 ms/op
                 executeQuery·p0.99:   10989.076 ms/op
                 executeQuery·p0.999:  10989.076 ms/op
                 executeQuery·p0.9999: 10989.076 ms/op
                 executeQuery·p1.00:   10989.076 ms/op

Iteration   2: 10989.076 ms/op
                 executeQuery·p0.00:   10989.076 ms/op
                 executeQuery·p0.50:   10989.076 ms/op
                 executeQuery·p0.90:   10989.076 ms/op
                 executeQuery·p0.95:   10989.076 ms/op
                 executeQuery·p0.99:   10989.076 ms/op
                 executeQuery·p0.999:  10989.076 ms/op
                 executeQuery·p0.9999: 10989.076 ms/op
                 executeQuery·p1.00:   10989.076 ms/op

Iteration   3: 11005.854 ms/op
                 executeQuery·p0.00:   11005.854 ms/op
                 executeQuery·p0.50:   11005.854 ms/op
                 executeQuery·p0.90:   11005.854 ms/op
                 executeQuery·p0.95:   11005.854 ms/op
                 executeQuery·p0.99:   11005.854 ms/op
                 executeQuery·p0.999:  11005.854 ms/op
                 executeQuery·p0.9999: 11005.854 ms/op
                 executeQuery·p1.00:   11005.854 ms/op

Iteration   4: 11005.854 ms/op
                 executeQuery·p0.00:   11005.854 ms/op
                 executeQuery·p0.50:   11005.854 ms/op
                 executeQuery·p0.90:   11005.854 ms/op
                 executeQuery·p0.95:   11005.854 ms/op
                 executeQuery·p0.99:   11005.854 ms/op
                 executeQuery·p0.999:  11005.854 ms/op
                 executeQuery·p0.9999: 11005.854 ms/op
                 executeQuery·p1.00:   11005.854 ms/op

Iteration   5: 10989.076 ms/op
                 executeQuery·p0.00:   10989.076 ms/op
                 executeQuery·p0.50:   10989.076 ms/op
                 executeQuery·p0.90:   10989.076 ms/op
                 executeQuery·p0.95:   10989.076 ms/op
                 executeQuery·p0.99:   10989.076 ms/op
                 executeQuery·p0.999:  10989.076 ms/op
                 executeQuery·p0.9999: 10989.076 ms/op
                 executeQuery·p1.00:   10989.076 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =  10995.787 ±(99.9%) 21.389 ms/op

  Histogram, ms/op:
    [10970.000, 10975.000) = 1 
    [10975.000, 10980.000) = 0 
    [10980.000, 10985.000) = 0 
    [10985.000, 10990.000) = 5 
    [10990.000, 10995.000) = 0 
    [10995.000, 11000.000) = 0 
    [11000.000, 11005.000) = 0 
    [11005.000, 11010.000) = 3 
    [11010.000, 11015.000) = 0 
    [11015.000, 11020.000) = 0 
    [11020.000, 11025.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  10972.299 ms/op
     p(50.0000) =  10989.076 ms/op
     p(90.0000) =  11020.953 ms/op
     p(95.0000) =  11022.631 ms/op
     p(99.0000) =  11022.631 ms/op
     p(99.9000) =  11022.631 ms/op
     p(99.9900) =  11022.631 ms/op
     p(99.9990) =  11022.631 ms/op
     p(99.9999) =  11022.631 ms/op
    p(100.0000) =  11022.631 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192)

# Run progress: 17.09% complete, ETA 19:50:02
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

16978.543 ms/op
# Warmup Iteration   2: 14663.287 ms/op
# Warmup Iteration   3: 12499.026 ms/op
# Warmup Iteration   4: 13472.104 ms/op
# Warmup Iteration   5: 12868.125 ms/op
Iteration   1: 13203.669 ms/op
                 executeQuery·p0.00:   13203.669 ms/op
                 executeQuery·p0.50:   13203.669 ms/op
                 executeQuery·p0.90:   13203.669 ms/op
                 executeQuery·p0.95:   13203.669 ms/op
                 executeQuery·p0.99:   13203.669 ms/op
                 executeQuery·p0.999:  13203.669 ms/op
                 executeQuery·p0.9999: 13203.669 ms/op
                 executeQuery·p1.00:   13203.669 ms/op

Iteration   2: 13354.664 ms/op
                 executeQuery·p0.00:   13354.664 ms/op
                 executeQuery·p0.50:   13354.664 ms/op
                 executeQuery·p0.90:   13354.664 ms/op
                 executeQuery·p0.95:   13354.664 ms/op
                 executeQuery·p0.99:   13354.664 ms/op
                 executeQuery·p0.999:  13354.664 ms/op
                 executeQuery·p0.9999: 13354.664 ms/op
                 executeQuery·p1.00:   13354.664 ms/op

Iteration   3: 13354.664 ms/op
                 executeQuery·p0.00:   13354.664 ms/op
                 executeQuery·p0.50:   13354.664 ms/op
                 executeQuery·p0.90:   13354.664 ms/op
                 executeQuery·p0.95:   13354.664 ms/op
                 executeQuery·p0.99:   13354.664 ms/op
                 executeQuery·p0.999:  13354.664 ms/op
                 executeQuery·p0.9999: 13354.664 ms/op
                 executeQuery·p1.00:   13354.664 ms/op

Iteration   4: 12834.570 ms/op
                 executeQuery·p0.00:   12834.570 ms/op
                 executeQuery·p0.50:   12834.570 ms/op
                 executeQuery·p0.90:   12834.570 ms/op
                 executeQuery·p0.95:   12834.570 ms/op
                 executeQuery·p0.99:   12834.570 ms/op
                 executeQuery·p0.999:  12834.570 ms/op
                 executeQuery·p0.9999: 12834.570 ms/op
                 executeQuery·p1.00:   12834.570 ms/op

Iteration   5: 12868.125 ms/op
                 executeQuery·p0.00:   12868.125 ms/op
                 executeQuery·p0.50:   12868.125 ms/op
                 executeQuery·p0.90:   12868.125 ms/op
                 executeQuery·p0.95:   12868.125 ms/op
                 executeQuery·p0.99:   12868.125 ms/op
                 executeQuery·p0.999:  12868.125 ms/op
                 executeQuery·p0.9999: 12868.125 ms/op
                 executeQuery·p1.00:   12868.125 ms/op


# Run progress: 17.41% complete, ETA 19:34:51
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

13589.545 ms/op
# Warmup Iteration   2: 13690.208 ms/op
# Warmup Iteration   3: 11861.492 ms/op
# Warmup Iteration   4: 12868.125 ms/op
# Warmup Iteration   5: 11844.714 ms/op
Iteration   1: 11995.709 ms/op
                 executeQuery·p0.00:   11995.709 ms/op
                 executeQuery·p0.50:   11995.709 ms/op
                 executeQuery·p0.90:   11995.709 ms/op
                 executeQuery·p0.95:   11995.709 ms/op
                 executeQuery·p0.99:   11995.709 ms/op
                 executeQuery·p0.999:  11995.709 ms/op
                 executeQuery·p0.9999: 11995.709 ms/op
                 executeQuery·p1.00:   11995.709 ms/op

Iteration   2: 12297.699 ms/op
                 executeQuery·p0.00:   12297.699 ms/op
                 executeQuery·p0.50:   12297.699 ms/op
                 executeQuery·p0.90:   12297.699 ms/op
                 executeQuery·p0.95:   12297.699 ms/op
                 executeQuery·p0.99:   12297.699 ms/op
                 executeQuery·p0.999:  12297.699 ms/op
                 executeQuery·p0.9999: 12297.699 ms/op
                 executeQuery·p1.00:   12297.699 ms/op

Iteration   3: 12029.264 ms/op
                 executeQuery·p0.00:   12029.264 ms/op
                 executeQuery·p0.50:   12029.264 ms/op
                 executeQuery·p0.90:   12029.264 ms/op
                 executeQuery·p0.95:   12029.264 ms/op
                 executeQuery·p0.99:   12029.264 ms/op
                 executeQuery·p0.999:  12029.264 ms/op
                 executeQuery·p0.9999: 12029.264 ms/op
                 executeQuery·p1.00:   12029.264 ms/op

Iteration   4: 12331.254 ms/op
                 executeQuery·p0.00:   12331.254 ms/op
                 executeQuery·p0.50:   12331.254 ms/op
                 executeQuery·p0.90:   12331.254 ms/op
                 executeQuery·p0.95:   12331.254 ms/op
                 executeQuery·p0.99:   12331.254 ms/op
                 executeQuery·p0.999:  12331.254 ms/op
                 executeQuery·p0.9999: 12331.254 ms/op
                 executeQuery·p1.00:   12331.254 ms/op

Iteration   5: 11928.601 ms/op
                 executeQuery·p0.00:   11928.601 ms/op
                 executeQuery·p0.50:   11928.601 ms/op
                 executeQuery·p0.90:   11928.601 ms/op
                 executeQuery·p0.95:   11928.601 ms/op
                 executeQuery·p0.99:   11928.601 ms/op
                 executeQuery·p0.999:  11928.601 ms/op
                 executeQuery·p0.9999: 11928.601 ms/op
                 executeQuery·p1.00:   11928.601 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =  12619.822 ±(99.9%) 862.882 ms/op

  Histogram, ms/op:
    [11000.000, 11250.000) = 0 
    [11250.000, 11500.000) = 0 
    [11500.000, 11750.000) = 0 
    [11750.000, 12000.000) = 2 
    [12000.000, 12250.000) = 1 
    [12250.000, 12500.000) = 2 
    [12500.000, 12750.000) = 0 
    [12750.000, 13000.000) = 2 
    [13000.000, 13250.000) = 1 
    [13250.000, 13500.000) = 2 
    [13500.000, 13750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  11928.601 ms/op
     p(50.0000) =  12582.912 ms/op
     p(90.0000) =  13354.664 ms/op
     p(95.0000) =  13354.664 ms/op
     p(99.0000) =  13354.664 ms/op
     p(99.9000) =  13354.664 ms/op
     p(99.9900) =  13354.664 ms/op
     p(99.9990) =  13354.664 ms/op
     p(99.9999) =  13354.664 ms/op
    p(100.0000) =  13354.664 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144)

# Run progress: 17.72% complete, ETA 19:19:14
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

59190.018 ms/op
# Warmup Iteration   2: 52479.132 ms/op
# Warmup Iteration   3: 51338.281 ms/op
# Warmup Iteration   4: 51271.172 ms/op
# Warmup Iteration   5: 51136.954 ms/op
Iteration   1: 51204.063 ms/op
                 executeQuery·p0.00:   51204.063 ms/op
                 executeQuery·p0.50:   51204.063 ms/op
                 executeQuery·p0.90:   51204.063 ms/op
                 executeQuery·p0.95:   51204.063 ms/op
                 executeQuery·p0.99:   51204.063 ms/op
                 executeQuery·p0.999:  51204.063 ms/op
                 executeQuery·p0.9999: 51204.063 ms/op
                 executeQuery·p1.00:   51204.063 ms/op

Iteration   2: 51136.954 ms/op
                 executeQuery·p0.00:   51136.954 ms/op
                 executeQuery·p0.50:   51136.954 ms/op
                 executeQuery·p0.90:   51136.954 ms/op
                 executeQuery·p0.95:   51136.954 ms/op
                 executeQuery·p0.99:   51136.954 ms/op
                 executeQuery·p0.999:  51136.954 ms/op
                 executeQuery·p0.9999: 51136.954 ms/op
                 executeQuery·p1.00:   51136.954 ms/op

Iteration   3: 49928.995 ms/op
                 executeQuery·p0.00:   49928.995 ms/op
                 executeQuery·p0.50:   49928.995 ms/op
                 executeQuery·p0.90:   49928.995 ms/op
                 executeQuery·p0.95:   49928.995 ms/op
                 executeQuery·p0.99:   49928.995 ms/op
                 executeQuery·p0.999:  49928.995 ms/op
                 executeQuery·p0.9999: 49928.995 ms/op
                 executeQuery·p1.00:   49928.995 ms/op

Iteration   4: 54895.051 ms/op
                 executeQuery·p0.00:   54895.051 ms/op
                 executeQuery·p0.50:   54895.051 ms/op
                 executeQuery·p0.90:   54895.051 ms/op
                 executeQuery·p0.95:   54895.051 ms/op
                 executeQuery·p0.99:   54895.051 ms/op
                 executeQuery·p0.999:  54895.051 ms/op
                 executeQuery·p0.9999: 54895.051 ms/op
                 executeQuery·p1.00:   54895.051 ms/op

Iteration   5: 50398.757 ms/op
                 executeQuery·p0.00:   50398.757 ms/op
                 executeQuery·p0.50:   50398.757 ms/op
                 executeQuery·p0.90:   50398.757 ms/op
                 executeQuery·p0.95:   50398.757 ms/op
                 executeQuery·p0.99:   50398.757 ms/op
                 executeQuery·p0.999:  50398.757 ms/op
                 executeQuery·p0.9999: 50398.757 ms/op
                 executeQuery·p1.00:   50398.757 ms/op


# Run progress: 18.04% complete, ETA 19:41:01
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

53016.003 ms/op
# Warmup Iteration   2: 53217.329 ms/op
# Warmup Iteration   3: 46573.552 ms/op
# Warmup Iteration   4: 52948.894 ms/op
# Warmup Iteration   5: 51136.954 ms/op
Iteration   1: 51271.172 ms/op
                 executeQuery·p0.00:   51271.172 ms/op
                 executeQuery·p0.50:   51271.172 ms/op
                 executeQuery·p0.90:   51271.172 ms/op
                 executeQuery·p0.95:   51271.172 ms/op
                 executeQuery·p0.99:   51271.172 ms/op
                 executeQuery·p0.999:  51271.172 ms/op
                 executeQuery·p0.9999: 51271.172 ms/op
                 executeQuery·p1.00:   51271.172 ms/op

Iteration   2: 51472.499 ms/op
                 executeQuery·p0.00:   51472.499 ms/op
                 executeQuery·p0.50:   51472.499 ms/op
                 executeQuery·p0.90:   51472.499 ms/op
                 executeQuery·p0.95:   51472.499 ms/op
                 executeQuery·p0.99:   51472.499 ms/op
                 executeQuery·p0.999:  51472.499 ms/op
                 executeQuery·p0.9999: 51472.499 ms/op
                 executeQuery·p1.00:   51472.499 ms/op

Iteration   3: 50868.519 ms/op
                 executeQuery·p0.00:   50868.519 ms/op
                 executeQuery·p0.50:   50868.519 ms/op
                 executeQuery·p0.90:   50868.519 ms/op
                 executeQuery·p0.95:   50868.519 ms/op
                 executeQuery·p0.99:   50868.519 ms/op
                 executeQuery·p0.999:  50868.519 ms/op
                 executeQuery·p0.9999: 50868.519 ms/op
                 executeQuery·p1.00:   50868.519 ms/op

Iteration   4: 53284.438 ms/op
                 executeQuery·p0.00:   53284.438 ms/op
                 executeQuery·p0.50:   53284.438 ms/op
                 executeQuery·p0.90:   53284.438 ms/op
                 executeQuery·p0.95:   53284.438 ms/op
                 executeQuery·p0.99:   53284.438 ms/op
                 executeQuery·p0.999:  53284.438 ms/op
                 executeQuery·p0.9999: 53284.438 ms/op
                 executeQuery·p1.00:   53284.438 ms/op

Iteration   5: 45835.354 ms/op
                 executeQuery·p0.00:   45835.354 ms/op
                 executeQuery·p0.50:   45835.354 ms/op
                 executeQuery·p0.90:   45835.354 ms/op
                 executeQuery·p0.95:   45835.354 ms/op
                 executeQuery·p0.99:   45835.354 ms/op
                 executeQuery·p0.999:  45835.354 ms/op
                 executeQuery·p0.9999: 45835.354 ms/op
                 executeQuery·p1.00:   45835.354 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =  51029.580 ±(99.9%) 3525.431 ms/op

  Histogram, ms/op:
    [45000.000, 46000.000) = 1 
    [46000.000, 47000.000) = 0 
    [47000.000, 48000.000) = 0 
    [48000.000, 49000.000) = 0 
    [49000.000, 50000.000) = 1 
    [50000.000, 51000.000) = 2 
    [51000.000, 52000.000) = 4 
    [52000.000, 53000.000) = 0 
    [53000.000, 54000.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  45835.354 ms/op
     p(50.0000) =  51170.509 ms/op
     p(90.0000) =  54733.989 ms/op
     p(95.0000) =  54895.051 ms/op
     p(99.0000) =  54895.051 ms/op
     p(99.9000) =  54895.051 ms/op
     p(99.9900) =  54895.051 ms/op
     p(99.9990) =  54895.051 ms/op
     p(99.9999) =  54895.051 ms/op
    p(100.0000) =  54895.051 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288)

# Run progress: 18.35% complete, ETA 20:00:43
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

105226.699 ms/op
# Warmup Iteration   2: 107239.965 ms/op
# Warmup Iteration   3: 98113.159 ms/op
# Warmup Iteration   4: 99589.554 ms/op
# Warmup Iteration   5: 101871.256 ms/op
Iteration   1: 102005.473 ms/op
                 executeQuery·p0.00:   102005.473 ms/op
                 executeQuery·p0.50:   102005.473 ms/op
                 executeQuery·p0.90:   102005.473 ms/op
                 executeQuery·p0.95:   102005.473 ms/op
                 executeQuery·p0.99:   102005.473 ms/op
                 executeQuery·p0.999:  102005.473 ms/op
                 executeQuery·p0.9999: 102005.473 ms/op
                 executeQuery·p1.00:   102005.473 ms/op

Iteration   2: 100260.643 ms/op
                 executeQuery·p0.00:   100260.643 ms/op
                 executeQuery·p0.50:   100260.643 ms/op
                 executeQuery·p0.90:   100260.643 ms/op
                 executeQuery·p0.95:   100260.643 ms/op
                 executeQuery·p0.99:   100260.643 ms/op
                 executeQuery·p0.999:  100260.643 ms/op
                 executeQuery·p0.9999: 100260.643 ms/op
                 executeQuery·p1.00:   100260.643 ms/op

Iteration   3: 101871.256 ms/op
                 executeQuery·p0.00:   101871.256 ms/op
                 executeQuery·p0.50:   101871.256 ms/op
                 executeQuery·p0.90:   101871.256 ms/op
                 executeQuery·p0.95:   101871.256 ms/op
                 executeQuery·p0.99:   101871.256 ms/op
                 executeQuery·p0.999:  101871.256 ms/op
                 executeQuery·p0.9999: 101871.256 ms/op
                 executeQuery·p1.00:   101871.256 ms/op

Iteration   4: 102139.691 ms/op
                 executeQuery·p0.00:   102139.691 ms/op
                 executeQuery·p0.50:   102139.691 ms/op
                 executeQuery·p0.90:   102139.691 ms/op
                 executeQuery·p0.95:   102139.691 ms/op
                 executeQuery·p0.99:   102139.691 ms/op
                 executeQuery·p0.999:  102139.691 ms/op
                 executeQuery·p0.9999: 102139.691 ms/op
                 executeQuery·p1.00:   102139.691 ms/op

Iteration   5: 100260.643 ms/op
                 executeQuery·p0.00:   100260.643 ms/op
                 executeQuery·p0.50:   100260.643 ms/op
                 executeQuery·p0.90:   100260.643 ms/op
                 executeQuery·p0.95:   100260.643 ms/op
                 executeQuery·p0.99:   100260.643 ms/op
                 executeQuery·p0.999:  100260.643 ms/op
                 executeQuery·p0.9999: 100260.643 ms/op
                 executeQuery·p1.00:   100260.643 ms/op


# Run progress: 18.67% complete, ETA 21:15:46
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

98918.466 ms/op
# Warmup Iteration   2: 105629.352 ms/op
# Warmup Iteration   3: 96636.764 ms/op
# Warmup Iteration   4: 99321.119 ms/op
# Warmup Iteration   5: 100394.861 ms/op
Iteration   1: 99992.207 ms/op
                 executeQuery·p0.00:   99992.207 ms/op
                 executeQuery·p0.50:   99992.207 ms/op
                 executeQuery·p0.90:   99992.207 ms/op
                 executeQuery·p0.95:   99992.207 ms/op
                 executeQuery·p0.99:   99992.207 ms/op
                 executeQuery·p0.999:  99992.207 ms/op
                 executeQuery·p0.9999: 99992.207 ms/op
                 executeQuery·p1.00:   99992.207 ms/op

Iteration   2: 101065.949 ms/op
                 executeQuery·p0.00:   101065.949 ms/op
                 executeQuery·p0.50:   101065.949 ms/op
                 executeQuery·p0.90:   101065.949 ms/op
                 executeQuery·p0.95:   101065.949 ms/op
                 executeQuery·p0.99:   101065.949 ms/op
                 executeQuery·p0.999:  101065.949 ms/op
                 executeQuery·p0.9999: 101065.949 ms/op
                 executeQuery·p1.00:   101065.949 ms/op

Iteration   3: 103213.433 ms/op
                 executeQuery·p0.00:   103213.433 ms/op
                 executeQuery·p0.50:   103213.433 ms/op
                 executeQuery·p0.90:   103213.433 ms/op
                 executeQuery·p0.95:   103213.433 ms/op
                 executeQuery·p0.99:   103213.433 ms/op
                 executeQuery·p0.999:  103213.433 ms/op
                 executeQuery·p0.9999: 103213.433 ms/op
                 executeQuery·p1.00:   103213.433 ms/op

Iteration   4: 101065.949 ms/op
                 executeQuery·p0.00:   101065.949 ms/op
                 executeQuery·p0.50:   101065.949 ms/op
                 executeQuery·p0.90:   101065.949 ms/op
                 executeQuery·p0.95:   101065.949 ms/op
                 executeQuery·p0.99:   101065.949 ms/op
                 executeQuery·p0.999:  101065.949 ms/op
                 executeQuery·p0.9999: 101065.949 ms/op
                 executeQuery·p1.00:   101065.949 ms/op

Iteration   5: 100931.731 ms/op
                 executeQuery·p0.00:   100931.731 ms/op
                 executeQuery·p0.50:   100931.731 ms/op
                 executeQuery·p0.90:   100931.731 ms/op
                 executeQuery·p0.95:   100931.731 ms/op
                 executeQuery·p0.99:   100931.731 ms/op
                 executeQuery·p0.999:  100931.731 ms/op
                 executeQuery·p0.9999: 100931.731 ms/op
                 executeQuery·p1.00:   100931.731 ms/op



Result "benchmarks.aggregation_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean = 101280.698 ±(99.9%) 1537.066 ms/op

  Histogram, ms/op:
    [ 99000.000,  99500.000) = 0 
    [ 99500.000, 100000.000) = 1 
    [100000.000, 100500.000) = 2 
    [100500.000, 101000.000) = 1 
    [101000.000, 101500.000) = 2 
    [101500.000, 102000.000) = 1 
    [102000.000, 102500.000) = 2 
    [102500.000, 103000.000) = 0 
    [103000.000, 103500.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  99992.207 ms/op
     p(50.0000) = 101065.949 ms/op
     p(90.0000) = 103106.059 ms/op
     p(95.0000) = 103213.433 ms/op
     p(99.0000) = 103213.433 ms/op
     p(99.9000) = 103213.433 ms/op
     p(99.9900) = 103213.433 ms/op
     p(99.9990) = 103213.433 ms/op
     p(99.9999) = 103213.433 ms/op
    p(100.0000) = 103213.433 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2)

# Run progress: 18.99% complete, ETA 22:27:13
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

382.710 ±(99.9%) 97.531 ms/op
# Warmup Iteration   2: 345.632 ±(99.9%) 2.885 ms/op
# Warmup Iteration   3: 346.916 ±(99.9%) 2.795 ms/op
# Warmup Iteration   4: 347.549 ±(99.9%) 5.847 ms/op
# Warmup Iteration   5: 347.332 ±(99.9%) 4.447 ms/op
Iteration   1: 345.307 ±(99.9%) 2.950 ms/op
                 executeQuery·p0.00:   342.360 ms/op
                 executeQuery·p0.50:   342.884 ms/op
                 executeQuery·p0.90:   351.273 ms/op
                 executeQuery·p0.95:   356.778 ms/op
                 executeQuery·p0.99:   362.283 ms/op
                 executeQuery·p0.999:  362.283 ms/op
                 executeQuery·p0.9999: 362.283 ms/op
                 executeQuery·p1.00:   362.283 ms/op

Iteration   2: 346.175 ±(99.9%) 2.041 ms/op
                 executeQuery·p0.00:   341.836 ms/op
                 executeQuery·p0.50:   347.079 ms/op
                 executeQuery·p0.90:   349.700 ms/op
                 executeQuery·p0.95:   351.011 ms/op
                 executeQuery·p0.99:   352.322 ms/op
                 executeQuery·p0.999:  352.322 ms/op
                 executeQuery·p0.9999: 352.322 ms/op
                 executeQuery·p1.00:   352.322 ms/op

Iteration   3: 344.982 ±(99.9%) 2.308 ms/op
                 executeQuery·p0.00:   340.787 ms/op
                 executeQuery·p0.50:   343.933 ms/op
                 executeQuery·p0.90:   350.224 ms/op
                 executeQuery·p0.95:   350.749 ms/op
                 executeQuery·p0.99:   350.749 ms/op
                 executeQuery·p0.999:  350.749 ms/op
                 executeQuery·p0.9999: 350.749 ms/op
                 executeQuery·p1.00:   350.749 ms/op

Iteration   4: 346.410 ±(99.9%) 4.049 ms/op
                 executeQuery·p0.00:   341.311 ms/op
                 executeQuery·p0.50:   344.457 ms/op
                 executeQuery·p0.90:   353.370 ms/op
                 executeQuery·p0.95:   365.691 ms/op
                 executeQuery·p0.99:   367.002 ms/op
                 executeQuery·p0.999:  367.002 ms/op
                 executeQuery·p0.9999: 367.002 ms/op
                 executeQuery·p1.00:   367.002 ms/op

Iteration   5: 346.862 ±(99.9%) 4.123 ms/op
                 executeQuery·p0.00:   341.836 ms/op
                 executeQuery·p0.50:   344.457 ms/op
                 executeQuery·p0.90:   350.749 ms/op
                 executeQuery·p0.95:   362.807 ms/op
                 executeQuery·p0.99:   373.817 ms/op
                 executeQuery·p0.999:  373.817 ms/op
                 executeQuery·p0.9999: 373.817 ms/op
                 executeQuery·p1.00:   373.817 ms/op


# Run progress: 19.30% complete, ETA 22:07:05
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

348.579 ±(99.9%) 26.309 ms/op
# Warmup Iteration   2: 340.543 ±(99.9%) 7.876 ms/op
# Warmup Iteration   3: 348.489 ±(99.9%) 6.960 ms/op
# Warmup Iteration   4: 348.959 ±(99.9%) 5.222 ms/op
# Warmup Iteration   5: 352.520 ±(99.9%) 7.301 ms/op
Iteration   1: 344.096 ±(99.9%) 2.203 ms/op
                 executeQuery·p0.00:   340.787 ms/op
                 executeQuery·p0.50:   342.360 ms/op
                 executeQuery·p0.90:   349.700 ms/op
                 executeQuery·p0.95:   351.011 ms/op
                 executeQuery·p0.99:   351.797 ms/op
                 executeQuery·p0.999:  351.797 ms/op
                 executeQuery·p0.9999: 351.797 ms/op
                 executeQuery·p1.00:   351.797 ms/op

Iteration   2: 343.339 ±(99.9%) 1.754 ms/op
                 executeQuery·p0.00:   340.263 ms/op
                 executeQuery·p0.50:   342.360 ms/op
                 executeQuery·p0.90:   348.022 ms/op
                 executeQuery·p0.95:   348.887 ms/op
                 executeQuery·p0.99:   349.176 ms/op
                 executeQuery·p0.999:  349.176 ms/op
                 executeQuery·p0.9999: 349.176 ms/op
                 executeQuery·p1.00:   349.176 ms/op

Iteration   3: 343.535 ±(99.9%) 2.113 ms/op
                 executeQuery·p0.00:   339.214 ms/op
                 executeQuery·p0.50:   342.360 ms/op
                 executeQuery·p0.90:   348.127 ms/op
                 executeQuery·p0.95:   349.176 ms/op
                 executeQuery·p0.99:   349.700 ms/op
                 executeQuery·p0.999:  349.700 ms/op
                 executeQuery·p0.9999: 349.700 ms/op
                 executeQuery·p1.00:   349.700 ms/op

Iteration   4: 343.513 ±(99.9%) 2.109 ms/op
                 executeQuery·p0.00:   340.263 ms/op
                 executeQuery·p0.50:   342.098 ms/op
                 executeQuery·p0.90:   349.071 ms/op
                 executeQuery·p0.95:   350.408 ms/op
                 executeQuery·p0.99:   351.273 ms/op
                 executeQuery·p0.999:  351.273 ms/op
                 executeQuery·p0.9999: 351.273 ms/op
                 executeQuery·p1.00:   351.273 ms/op

Iteration   5: 355.106 ±(99.9%) 37.865 ms/op
                 executeQuery·p0.00:   339.739 ms/op
                 executeQuery·p0.50:   342.884 ms/op
                 executeQuery·p0.90:   350.224 ms/op
                 executeQuery·p0.95:   502.268 ms/op
                 executeQuery·p0.99:   642.777 ms/op
                 executeQuery·p0.999:  642.777 ms/op
                 executeQuery·p0.9999: 642.777 ms/op
                 executeQuery·p1.00:   642.777 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 292
  mean =    345.915 ±(99.9%) 3.488 ms/op

  Histogram, ms/op:
    [300.000, 325.000) = 0 
    [325.000, 350.000) = 270 
    [350.000, 375.000) = 21 
    [375.000, 400.000) = 0 
    [400.000, 425.000) = 0 
    [425.000, 450.000) = 0 
    [450.000, 475.000) = 0 
    [475.000, 500.000) = 0 
    [500.000, 525.000) = 0 
    [525.000, 550.000) = 0 
    [550.000, 575.000) = 0 
    [575.000, 600.000) = 0 
    [600.000, 625.000) = 0 
    [625.000, 650.000) = 1 
    [650.000, 675.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =    339.214 ms/op
     p(50.0000) =    343.409 ms/op
     p(90.0000) =    349.700 ms/op
     p(95.0000) =    350.749 ms/op
     p(99.0000) =    367.479 ms/op
     p(99.9000) =    642.777 ms/op
     p(99.9900) =    642.777 ms/op
     p(99.9990) =    642.777 ms/op
     p(99.9999) =    642.777 ms/op
    p(100.0000) =    642.777 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16)

# Run progress: 19.62% complete, ETA 21:47:38
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

503.133 ±(99.9%) 81.912 ms/op
# Warmup Iteration   2: 479.724 ±(99.9%) 2.683 ms/op
# Warmup Iteration   3: 482.620 ±(99.9%) 2.612 ms/op
# Warmup Iteration   4: 481.147 ±(99.9%) 1.915 ms/op
# Warmup Iteration   5: 475.579 ±(99.9%) 3.946 ms/op
Iteration   1: 470.858 ±(99.9%) 4.472 ms/op
                 executeQuery·p0.00:   466.616 ms/op
                 executeQuery·p0.50:   468.713 ms/op
                 executeQuery·p0.90:   477.993 ms/op
                 executeQuery·p0.95:   487.064 ms/op
                 executeQuery·p0.99:   488.636 ms/op
                 executeQuery·p0.999:  488.636 ms/op
                 executeQuery·p0.9999: 488.636 ms/op
                 executeQuery·p1.00:   488.636 ms/op

Iteration   2: 476.078 ±(99.9%) 4.610 ms/op
                 executeQuery·p0.00:   467.665 ms/op
                 executeQuery·p0.50:   476.578 ms/op
                 executeQuery·p0.90:   484.023 ms/op
                 executeQuery·p0.95:   486.330 ms/op
                 executeQuery·p0.99:   486.539 ms/op
                 executeQuery·p0.999:  486.539 ms/op
                 executeQuery·p0.9999: 486.539 ms/op
                 executeQuery·p1.00:   486.539 ms/op

Iteration   3: 479.349 ±(99.9%) 2.814 ms/op
                 executeQuery·p0.00:   475.529 ms/op
                 executeQuery·p0.50:   478.675 ms/op
                 executeQuery·p0.90:   483.289 ms/op
                 executeQuery·p0.95:   488.584 ms/op
                 executeQuery·p0.99:   489.161 ms/op
                 executeQuery·p0.999:  489.161 ms/op
                 executeQuery·p0.9999: 489.161 ms/op
                 executeQuery·p1.00:   489.161 ms/op

Iteration   4: 475.029 ±(99.9%) 2.821 ms/op
                 executeQuery·p0.00:   470.286 ms/op
                 executeQuery·p0.50:   473.694 ms/op
                 executeQuery·p0.90:   480.458 ms/op
                 executeQuery·p0.95:   480.772 ms/op
                 executeQuery·p0.99:   480.772 ms/op
                 executeQuery·p0.999:  480.772 ms/op
                 executeQuery·p0.9999: 480.772 ms/op
                 executeQuery·p1.00:   480.772 ms/op

Iteration   5: 478.325 ±(99.9%) 1.650 ms/op
                 executeQuery·p0.00:   474.481 ms/op
                 executeQuery·p0.50:   478.151 ms/op
                 executeQuery·p0.90:   481.611 ms/op
                 executeQuery·p0.95:   482.293 ms/op
                 executeQuery·p0.99:   482.345 ms/op
                 executeQuery·p0.999:  482.345 ms/op
                 executeQuery·p0.9999: 482.345 ms/op
                 executeQuery·p1.00:   482.345 ms/op


# Run progress: 19.94% complete, ETA 21:28:43
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

472.789 ±(99.9%) 29.826 ms/op
# Warmup Iteration   2: 463.614 ±(99.9%) 4.148 ms/op
# Warmup Iteration   3: 457.036 ±(99.9%) 0.759 ms/op
# Warmup Iteration   4: 461.111 ±(99.9%) 3.903 ms/op
# Warmup Iteration   5: 462.494 ±(99.9%) 4.138 ms/op
Iteration   1: 464.900 ±(99.9%) 26.088 ms/op
                 executeQuery·p0.00:   455.606 ms/op
                 executeQuery·p0.50:   458.228 ms/op
                 executeQuery·p0.90:   461.216 ms/op
                 executeQuery·p0.95:   586.154 ms/op
                 executeQuery·p0.99:   608.174 ms/op
                 executeQuery·p0.999:  608.174 ms/op
                 executeQuery·p0.9999: 608.174 ms/op
                 executeQuery·p1.00:   608.174 ms/op

Iteration   2: 465.353 ±(99.9%) 3.180 ms/op
                 executeQuery·p0.00:   456.131 ms/op
                 executeQuery·p0.50:   466.092 ms/op
                 executeQuery·p0.90:   468.189 ms/op
                 executeQuery·p0.95:   472.646 ms/op
                 executeQuery·p0.99:   473.432 ms/op
                 executeQuery·p0.999:  473.432 ms/op
                 executeQuery·p0.9999: 473.432 ms/op
                 executeQuery·p1.00:   473.432 ms/op

Iteration   3: 466.855 ±(99.9%) 2.258 ms/op
                 executeQuery·p0.00:   462.946 ms/op
                 executeQuery·p0.50:   466.616 ms/op
                 executeQuery·p0.90:   470.653 ms/op
                 executeQuery·p0.95:   474.376 ms/op
                 executeQuery·p0.99:   475.005 ms/op
                 executeQuery·p0.999:  475.005 ms/op
                 executeQuery·p0.9999: 475.005 ms/op
                 executeQuery·p1.00:   475.005 ms/op

Iteration   4: 465.568 ±(99.9%) 2.104 ms/op
                 executeQuery·p0.00:   458.752 ms/op
                 executeQuery·p0.50:   466.092 ms/op
                 executeQuery·p0.90:   468.713 ms/op
                 executeQuery·p0.95:   469.159 ms/op
                 executeQuery·p0.99:   469.238 ms/op
                 executeQuery·p0.999:  469.238 ms/op
                 executeQuery·p0.9999: 469.238 ms/op
                 executeQuery·p1.00:   469.238 ms/op

Iteration   5: 467.260 ±(99.9%) 2.266 ms/op
                 executeQuery·p0.00:   462.946 ms/op
                 executeQuery·p0.50:   467.665 ms/op
                 executeQuery·p0.90:   470.653 ms/op
                 executeQuery·p0.95:   472.593 ms/op
                 executeQuery·p0.99:   472.908 ms/op
                 executeQuery·p0.999:  472.908 ms/op
                 executeQuery·p0.9999: 472.908 ms/op
                 executeQuery·p1.00:   472.908 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 217
  mean =    470.861 ±(99.9%) 2.690 ms/op

  Histogram, ms/op:
    [400.000, 425.000) = 0 
    [425.000, 450.000) = 0 
    [450.000, 475.000) = 148 
    [475.000, 500.000) = 68 
    [500.000, 525.000) = 0 
    [525.000, 550.000) = 0 
    [550.000, 575.000) = 0 
    [575.000, 600.000) = 0 
    [600.000, 625.000) = 1 
    [625.000, 650.000) = 0 
    [650.000, 675.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =    455.606 ms/op
     p(50.0000) =    468.713 ms/op
     p(90.0000) =    479.724 ms/op
     p(95.0000) =    481.873 ms/op
     p(99.0000) =    489.066 ms/op
     p(99.9000) =    608.174 ms/op
     p(99.9900) =    608.174 ms/op
     p(99.9990) =    608.174 ms/op
     p(99.9999) =    608.174 ms/op
    p(100.0000) =    608.174 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192)

# Run progress: 20.25% complete, ETA 21:10:24
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

713.256 ±(99.9%) 72.349 ms/op
# Warmup Iteration   2: 694.087 ±(99.9%) 9.355 ms/op
# Warmup Iteration   3: 691.431 ±(99.9%) 10.281 ms/op
# Warmup Iteration   4: 693.738 ±(99.9%) 11.801 ms/op
# Warmup Iteration   5: 690.452 ±(99.9%) 13.564 ms/op
Iteration   1: 686.118 ±(99.9%) 8.069 ms/op
                 executeQuery·p0.00:   678.429 ms/op
                 executeQuery·p0.50:   682.623 ms/op
                 executeQuery·p0.90:   697.722 ms/op
                 executeQuery·p0.95:   698.352 ms/op
                 executeQuery·p0.99:   698.352 ms/op
                 executeQuery·p0.999:  698.352 ms/op
                 executeQuery·p0.9999: 698.352 ms/op
                 executeQuery·p1.00:   698.352 ms/op

Iteration   2: 692.130 ±(99.9%) 12.945 ms/op
                 executeQuery·p0.00:   658.506 ms/op
                 executeQuery·p0.50:   696.254 ms/op
                 executeQuery·p0.90:   699.400 ms/op
                 executeQuery·p0.95:   699.400 ms/op
                 executeQuery·p0.99:   699.400 ms/op
                 executeQuery·p0.999:  699.400 ms/op
                 executeQuery·p0.9999: 699.400 ms/op
                 executeQuery·p1.00:   699.400 ms/op

Iteration   3: 693.318 ±(99.9%) 9.938 ms/op
                 executeQuery·p0.00:   677.380 ms/op
                 executeQuery·p0.50:   694.157 ms/op
                 executeQuery·p0.90:   706.111 ms/op
                 executeQuery·p0.95:   716.177 ms/op
                 executeQuery·p0.99:   716.177 ms/op
                 executeQuery·p0.999:  716.177 ms/op
                 executeQuery·p0.9999: 716.177 ms/op
                 executeQuery·p1.00:   716.177 ms/op

Iteration   4: 691.501 ±(99.9%) 8.377 ms/op
                 executeQuery·p0.00:   678.429 ms/op
                 executeQuery·p0.50:   694.157 ms/op
                 executeQuery·p0.90:   701.288 ms/op
                 executeQuery·p0.95:   702.546 ms/op
                 executeQuery·p0.99:   702.546 ms/op
                 executeQuery·p0.999:  702.546 ms/op
                 executeQuery·p0.9999: 702.546 ms/op
                 executeQuery·p1.00:   702.546 ms/op

Iteration   5: 685.419 ±(99.9%) 8.628 ms/op
                 executeQuery·p0.00:   676.332 ms/op
                 executeQuery·p0.50:   681.574 ms/op
                 executeQuery·p0.90:   697.722 ms/op
                 executeQuery·p0.95:   698.352 ms/op
                 executeQuery·p0.99:   698.352 ms/op
                 executeQuery·p0.999:  698.352 ms/op
                 executeQuery·p0.9999: 698.352 ms/op
                 executeQuery·p1.00:   698.352 ms/op


# Run progress: 20.57% complete, ETA 20:52:45
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

695.416 ±(99.9%) 36.850 ms/op
# Warmup Iteration   2: 671.718 ±(99.9%) 23.715 ms/op
# Warmup Iteration   3: 679.827 ±(99.9%) 15.345 ms/op
# Warmup Iteration   4: 675.772 ±(99.9%) 17.053 ms/op
# Warmup Iteration   5: 670.110 ±(99.9%) 13.687 ms/op
Iteration   1: 679.337 ±(99.9%) 12.539 ms/op
                 executeQuery·p0.00:   652.214 ms/op
                 executeQuery·p0.50:   681.574 ms/op
                 executeQuery·p0.90:   693.738 ms/op
                 executeQuery·p0.95:   702.546 ms/op
                 executeQuery·p0.99:   702.546 ms/op
                 executeQuery·p0.999:  702.546 ms/op
                 executeQuery·p0.9999: 702.546 ms/op
                 executeQuery·p1.00:   702.546 ms/op

Iteration   2: 669.481 ±(99.9%) 14.223 ms/op
                 executeQuery·p0.00:   651.166 ms/op
                 executeQuery·p0.50:   677.380 ms/op
                 executeQuery·p0.90:   684.301 ms/op
                 executeQuery·p0.95:   686.817 ms/op
                 executeQuery·p0.99:   686.817 ms/op
                 executeQuery·p0.999:  686.817 ms/op
                 executeQuery·p0.9999: 686.817 ms/op
                 executeQuery·p1.00:   686.817 ms/op

Iteration   3: 674.514 ±(99.9%) 13.274 ms/op
                 executeQuery·p0.00:   652.214 ms/op
                 executeQuery·p0.50:   679.477 ms/op
                 executeQuery·p0.90:   686.817 ms/op
                 executeQuery·p0.95:   689.963 ms/op
                 executeQuery·p0.99:   689.963 ms/op
                 executeQuery·p0.999:  689.963 ms/op
                 executeQuery·p0.9999: 689.963 ms/op
                 executeQuery·p1.00:   689.963 ms/op

Iteration   4: 673.256 ±(99.9%) 14.138 ms/op
                 executeQuery·p0.00:   653.263 ms/op
                 executeQuery·p0.50:   677.380 ms/op
                 executeQuery·p0.90:   687.237 ms/op
                 executeQuery·p0.95:   691.012 ms/op
                 executeQuery·p0.99:   691.012 ms/op
                 executeQuery·p0.999:  691.012 ms/op
                 executeQuery·p0.9999: 691.012 ms/op
                 executeQuery·p1.00:   691.012 ms/op

Iteration   5: 667.803 ±(99.9%) 22.670 ms/op
                 executeQuery·p0.00:   642.777 ms/op
                 executeQuery·p0.50:   670.040 ms/op
                 executeQuery·p0.90:   690.802 ms/op
                 executeQuery·p0.95:   692.060 ms/op
                 executeQuery·p0.99:   692.060 ms/op
                 executeQuery·p0.999:  692.060 ms/op
                 executeQuery·p0.9999: 692.060 ms/op
                 executeQuery·p1.00:   692.060 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 150
  mean =    681.288 ±(99.9%) 4.127 ms/op

  Histogram, ms/op:
    [640.000, 645.000) = 5 
    [645.000, 650.000) = 1 
    [650.000, 655.000) = 8 
    [655.000, 660.000) = 10 
    [660.000, 665.000) = 0 
    [665.000, 670.000) = 3 
    [670.000, 675.000) = 1 
    [675.000, 680.000) = 25 
    [680.000, 685.000) = 40 
    [685.000, 690.000) = 11 
    [690.000, 695.000) = 14 
    [695.000, 700.000) = 27 
    [700.000, 705.000) = 4 
    [705.000, 710.000) = 0 
    [710.000, 715.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =    642.777 ms/op
     p(50.0000) =    682.623 ms/op
     p(90.0000) =    697.303 ms/op
     p(95.0000) =    699.400 ms/op
     p(99.0000) =    709.225 ms/op
     p(99.9000) =    716.177 ms/op
     p(99.9900) =    716.177 ms/op
     p(99.9990) =    716.177 ms/op
     p(99.9999) =    716.177 ms/op
    p(100.0000) =    716.177 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144)

# Run progress: 20.89% complete, ETA 20:35:27
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3296.723 ms/op
# Warmup Iteration   2: 2445.279 ms/op
# Warmup Iteration   3: 2560.623 ms/op
# Warmup Iteration   4: 2575.303 ms/op
# Warmup Iteration   5: 2659.189 ms/op
Iteration   1: 2499.805 ms/op
                 executeQuery·p0.00:   2499.805 ms/op
                 executeQuery·p0.50:   2499.805 ms/op
                 executeQuery·p0.90:   2499.805 ms/op
                 executeQuery·p0.95:   2499.805 ms/op
                 executeQuery·p0.99:   2499.805 ms/op
                 executeQuery·p0.999:  2499.805 ms/op
                 executeQuery·p0.9999: 2499.805 ms/op
                 executeQuery·p1.00:   2499.805 ms/op

Iteration   2: 2495.611 ms/op
                 executeQuery·p0.00:   2495.611 ms/op
                 executeQuery·p0.50:   2495.611 ms/op
                 executeQuery·p0.90:   2495.611 ms/op
                 executeQuery·p0.95:   2495.611 ms/op
                 executeQuery·p0.99:   2495.611 ms/op
                 executeQuery·p0.999:  2495.611 ms/op
                 executeQuery·p0.9999: 2495.611 ms/op
                 executeQuery·p1.00:   2495.611 ms/op

Iteration   3: 2541.748 ms/op
                 executeQuery·p0.00:   2541.748 ms/op
                 executeQuery·p0.50:   2541.748 ms/op
                 executeQuery·p0.90:   2541.748 ms/op
                 executeQuery·p0.95:   2541.748 ms/op
                 executeQuery·p0.99:   2541.748 ms/op
                 executeQuery·p0.999:  2541.748 ms/op
                 executeQuery·p0.9999: 2541.748 ms/op
                 executeQuery·p1.00:   2541.748 ms/op

Iteration   4: 2487.222 ms/op
                 executeQuery·p0.00:   2487.222 ms/op
                 executeQuery·p0.50:   2487.222 ms/op
                 executeQuery·p0.90:   2487.222 ms/op
                 executeQuery·p0.95:   2487.222 ms/op
                 executeQuery·p0.99:   2487.222 ms/op
                 executeQuery·p0.999:  2487.222 ms/op
                 executeQuery·p0.9999: 2487.222 ms/op
                 executeQuery·p1.00:   2487.222 ms/op

Iteration   5: 2571.108 ms/op
                 executeQuery·p0.00:   2571.108 ms/op
                 executeQuery·p0.50:   2571.108 ms/op
                 executeQuery·p0.90:   2571.108 ms/op
                 executeQuery·p0.95:   2571.108 ms/op
                 executeQuery·p0.99:   2571.108 ms/op
                 executeQuery·p0.999:  2571.108 ms/op
                 executeQuery·p0.9999: 2571.108 ms/op
                 executeQuery·p1.00:   2571.108 ms/op


# Run progress: 21.20% complete, ETA 20:21:22
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

2902.458 ms/op
# Warmup Iteration   2: 2684.355 ms/op
# Warmup Iteration   3: 2759.852 ms/op
# Warmup Iteration   4: 2529.165 ms/op
# Warmup Iteration   5: 2613.051 ms/op
Iteration   1: 2537.554 ms/op
                 executeQuery·p0.00:   2537.554 ms/op
                 executeQuery·p0.50:   2537.554 ms/op
                 executeQuery·p0.90:   2537.554 ms/op
                 executeQuery·p0.95:   2537.554 ms/op
                 executeQuery·p0.99:   2537.554 ms/op
                 executeQuery·p0.999:  2537.554 ms/op
                 executeQuery·p0.9999: 2537.554 ms/op
                 executeQuery·p1.00:   2537.554 ms/op

Iteration   2: 2596.274 ms/op
                 executeQuery·p0.00:   2596.274 ms/op
                 executeQuery·p0.50:   2596.274 ms/op
                 executeQuery·p0.90:   2596.274 ms/op
                 executeQuery·p0.95:   2596.274 ms/op
                 executeQuery·p0.99:   2596.274 ms/op
                 executeQuery·p0.999:  2596.274 ms/op
                 executeQuery·p0.9999: 2596.274 ms/op
                 executeQuery·p1.00:   2596.274 ms/op

Iteration   3: 2571.108 ms/op
                 executeQuery·p0.00:   2571.108 ms/op
                 executeQuery·p0.50:   2571.108 ms/op
                 executeQuery·p0.90:   2571.108 ms/op
                 executeQuery·p0.95:   2571.108 ms/op
                 executeQuery·p0.99:   2571.108 ms/op
                 executeQuery·p0.999:  2571.108 ms/op
                 executeQuery·p0.9999: 2571.108 ms/op
                 executeQuery·p1.00:   2571.108 ms/op

Iteration   4: 2571.108 ms/op
                 executeQuery·p0.00:   2571.108 ms/op
                 executeQuery·p0.50:   2571.108 ms/op
                 executeQuery·p0.90:   2571.108 ms/op
                 executeQuery·p0.95:   2571.108 ms/op
                 executeQuery·p0.99:   2571.108 ms/op
                 executeQuery·p0.999:  2571.108 ms/op
                 executeQuery·p0.9999: 2571.108 ms/op
                 executeQuery·p1.00:   2571.108 ms/op

Iteration   5: 2537.554 ms/op
                 executeQuery·p0.00:   2537.554 ms/op
                 executeQuery·p0.50:   2537.554 ms/op
                 executeQuery·p0.90:   2537.554 ms/op
                 executeQuery·p0.95:   2537.554 ms/op
                 executeQuery·p0.99:   2537.554 ms/op
                 executeQuery·p0.999:  2537.554 ms/op
                 executeQuery·p0.9999: 2537.554 ms/op
                 executeQuery·p1.00:   2537.554 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =   2540.909 ±(99.9%) 56.227 ms/op

  Histogram, ms/op:
    [2400.000, 2412.500) = 0 
    [2412.500, 2425.000) = 0 
    [2425.000, 2437.500) = 0 
    [2437.500, 2450.000) = 0 
    [2450.000, 2462.500) = 0 
    [2462.500, 2475.000) = 0 
    [2475.000, 2487.500) = 1 
    [2487.500, 2500.000) = 2 
    [2500.000, 2512.500) = 0 
    [2512.500, 2525.000) = 0 
    [2525.000, 2537.500) = 0 
    [2537.500, 2550.000) = 3 
    [2550.000, 2562.500) = 0 
    [2562.500, 2575.000) = 3 
    [2575.000, 2587.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   2487.222 ms/op
     p(50.0000) =   2539.651 ms/op
     p(90.0000) =   2593.758 ms/op
     p(95.0000) =   2596.274 ms/op
     p(99.0000) =   2596.274 ms/op
     p(99.9000) =   2596.274 ms/op
     p(99.9900) =   2596.274 ms/op
     p(99.9990) =   2596.274 ms/op
     p(99.9999) =   2596.274 ms/op
    p(100.0000) =   2596.274 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288)

# Run progress: 21.52% complete, ETA 20:06:26
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5502.927 ms/op
# Warmup Iteration   2: 5150.605 ms/op
# Warmup Iteration   3: 5049.942 ms/op
# Warmup Iteration   4: 5209.326 ms/op
# Warmup Iteration   5: 4949.279 ms/op
Iteration   1: 5016.388 ms/op
                 executeQuery·p0.00:   5016.388 ms/op
                 executeQuery·p0.50:   5016.388 ms/op
                 executeQuery·p0.90:   5016.388 ms/op
                 executeQuery·p0.95:   5016.388 ms/op
                 executeQuery·p0.99:   5016.388 ms/op
                 executeQuery·p0.999:  5016.388 ms/op
                 executeQuery·p0.9999: 5016.388 ms/op
                 executeQuery·p1.00:   5016.388 ms/op

Iteration   2: 4890.558 ms/op
                 executeQuery·p0.00:   4890.558 ms/op
                 executeQuery·p0.50:   4890.558 ms/op
                 executeQuery·p0.90:   4890.558 ms/op
                 executeQuery·p0.95:   4890.558 ms/op
                 executeQuery·p0.99:   4890.558 ms/op
                 executeQuery·p0.999:  4890.558 ms/op
                 executeQuery·p0.9999: 4890.558 ms/op
                 executeQuery·p1.00:   4890.558 ms/op

Iteration   3: 4982.833 ms/op
                 executeQuery·p0.00:   4982.833 ms/op
                 executeQuery·p0.50:   4982.833 ms/op
                 executeQuery·p0.90:   4982.833 ms/op
                 executeQuery·p0.95:   4982.833 ms/op
                 executeQuery·p0.99:   4982.833 ms/op
                 executeQuery·p0.999:  4982.833 ms/op
                 executeQuery·p0.9999: 4982.833 ms/op
                 executeQuery·p1.00:   4982.833 ms/op

Iteration   4: 4857.004 ms/op
                 executeQuery·p0.00:   4857.004 ms/op
                 executeQuery·p0.50:   4857.004 ms/op
                 executeQuery·p0.90:   4857.004 ms/op
                 executeQuery·p0.95:   4857.004 ms/op
                 executeQuery·p0.99:   4857.004 ms/op
                 executeQuery·p0.999:  4857.004 ms/op
                 executeQuery·p0.9999: 4857.004 ms/op
                 executeQuery·p1.00:   4857.004 ms/op

Iteration   5: 4857.004 ms/op
                 executeQuery·p0.00:   4857.004 ms/op
                 executeQuery·p0.50:   4857.004 ms/op
                 executeQuery·p0.90:   4857.004 ms/op
                 executeQuery·p0.95:   4857.004 ms/op
                 executeQuery·p0.99:   4857.004 ms/op
                 executeQuery·p0.999:  4857.004 ms/op
                 executeQuery·p0.9999: 4857.004 ms/op
                 executeQuery·p1.00:   4857.004 ms/op


# Run progress: 21.84% complete, ETA 20:08:39
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_2000579107 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_2000579107() {
        this(4);
    }
    public KeyValueMap_2000579107(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_2000579107 aggregation_state_map = new KeyValueMap_2000579107();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5360.321 ms/op
# Warmup Iteration   2: 5142.217 ms/op
# Warmup Iteration   3: 5066.719 ms/op
# Warmup Iteration   4: 5335.155 ms/op
# Warmup Iteration   5: 5016.388 ms/op
Iteration   1: 5318.377 ms/op
                 executeQuery·p0.00:   5318.377 ms/op
                 executeQuery·p0.50:   5318.377 ms/op
                 executeQuery·p0.90:   5318.377 ms/op
                 executeQuery·p0.95:   5318.377 ms/op
                 executeQuery·p0.99:   5318.377 ms/op
                 executeQuery·p0.999:  5318.377 ms/op
                 executeQuery·p0.9999: 5318.377 ms/op
                 executeQuery·p1.00:   5318.377 ms/op

Iteration   2: 5385.486 ms/op
                 executeQuery·p0.00:   5385.486 ms/op
                 executeQuery·p0.50:   5385.486 ms/op
                 executeQuery·p0.90:   5385.486 ms/op
                 executeQuery·p0.95:   5385.486 ms/op
                 executeQuery·p0.99:   5385.486 ms/op
                 executeQuery·p0.999:  5385.486 ms/op
                 executeQuery·p0.9999: 5385.486 ms/op
                 executeQuery·p1.00:   5385.486 ms/op

Iteration   3: 4966.056 ms/op
                 executeQuery·p0.00:   4966.056 ms/op
                 executeQuery·p0.50:   4966.056 ms/op
                 executeQuery·p0.90:   4966.056 ms/op
                 executeQuery·p0.95:   4966.056 ms/op
                 executeQuery·p0.99:   4966.056 ms/op
                 executeQuery·p0.999:  4966.056 ms/op
                 executeQuery·p0.9999: 4966.056 ms/op
                 executeQuery·p1.00:   4966.056 ms/op

Iteration   4: 5007.999 ms/op
                 executeQuery·p0.00:   5007.999 ms/op
                 executeQuery·p0.50:   5007.999 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   5: 4848.615 ms/op
                 executeQuery·p0.00:   4848.615 ms/op
                 executeQuery·p0.50:   4848.615 ms/op
                 executeQuery·p0.90:   4848.615 ms/op
                 executeQuery·p0.95:   4848.615 ms/op
                 executeQuery·p0.99:   4848.615 ms/op
                 executeQuery·p0.999:  4848.615 ms/op
                 executeQuery·p0.9999: 4848.615 ms/op
                 executeQuery·p1.00:   4848.615 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =   5013.032 ±(99.9%) 287.666 ms/op

  Histogram, ms/op:
    [4800.000, 4850.000) = 1 
    [4850.000, 4900.000) = 3 
    [4900.000, 4950.000) = 0 
    [4950.000, 5000.000) = 2 
    [5000.000, 5050.000) = 2 
    [5050.000, 5100.000) = 0 
    [5100.000, 5150.000) = 0 
    [5150.000, 5200.000) = 0 
    [5200.000, 5250.000) = 0 
    [5250.000, 5300.000) = 0 
    [5300.000, 5350.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4848.615 ms/op
     p(50.0000) =   4974.445 ms/op
     p(90.0000) =   5378.775 ms/op
     p(95.0000) =   5385.486 ms/op
     p(99.0000) =   5385.486 ms/op
     p(99.9000) =   5385.486 ms/op
     p(99.9900) =   5385.486 ms/op
     p(99.9990) =   5385.486 ms/op
     p(99.9999) =   5385.486 ms/op
    p(100.0000) =   5385.486 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2)

# Run progress: 22.15% complete, ETA 20:10:45
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6543.114 ms/op
# Warmup Iteration   2: 3738.523 ±(99.9%) 7187.289 ms/op
# Warmup Iteration   3: 3447.718 ±(99.9%) 2584.736 ms/op
# Warmup Iteration   4: 3450.514 ±(99.9%) 2739.078 ms/op
# Warmup Iteration   5: 3509.234 ±(99.9%) 4529.769 ms/op
Iteration   1: 3437.931 ±(99.9%) 2275.524 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3581.936 ms/op
                 executeQuery·p0.95:   3581.936 ms/op
                 executeQuery·p0.99:   3581.936 ms/op
                 executeQuery·p0.999:  3581.936 ms/op
                 executeQuery·p0.9999: 3581.936 ms/op
                 executeQuery·p1.00:   3581.936 ms/op

Iteration   2: 3432.339 ±(99.9%) 2032.219 ms/op
                 executeQuery·p0.00:   3368.026 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3560.964 ms/op
                 executeQuery·p0.95:   3560.964 ms/op
                 executeQuery·p0.99:   3560.964 ms/op
                 executeQuery·p0.999:  3560.964 ms/op
                 executeQuery·p0.9999: 3560.964 ms/op
                 executeQuery·p1.00:   3560.964 ms/op

Iteration   3: 3384.803 ±(99.9%) 597.638 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3422.552 ms/op
                 executeQuery·p0.95:   3422.552 ms/op
                 executeQuery·p0.99:   3422.552 ms/op
                 executeQuery·p0.999:  3422.552 ms/op
                 executeQuery·p0.9999: 3422.552 ms/op
                 executeQuery·p1.00:   3422.552 ms/op

Iteration   4: 3363.832 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3363.832 ms/op
                 executeQuery·p0.90:   3363.832 ms/op
                 executeQuery·p0.95:   3363.832 ms/op
                 executeQuery·p0.99:   3363.832 ms/op
                 executeQuery·p0.999:  3363.832 ms/op
                 executeQuery·p0.9999: 3363.832 ms/op
                 executeQuery·p1.00:   3363.832 ms/op

Iteration   5: 3366.628 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   3363.832 ms/op
                 executeQuery·p0.50:   3368.026 ms/op
                 executeQuery·p0.90:   3368.026 ms/op
                 executeQuery·p0.95:   3368.026 ms/op
                 executeQuery·p0.99:   3368.026 ms/op
                 executeQuery·p0.999:  3368.026 ms/op
                 executeQuery·p0.9999: 3368.026 ms/op
                 executeQuery·p1.00:   3368.026 ms/op


# Run progress: 22.47% complete, ETA 19:55:04
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3449.815 ±(99.9%) 6752.737 ms/op
# Warmup Iteration   2: 3709.163 ±(99.9%) 1572.538 ms/op
# Warmup Iteration   3: 3656.035 ±(99.9%) 44.179 ms/op
# Warmup Iteration   4: 3664.424 ±(99.9%) 159.288 ms/op
# Warmup Iteration   5: 3663.025 ±(99.9%) 245.976 ms/op
Iteration   1: 3661.627 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   3661.627 ms/op
                 executeQuery·p0.50:   3661.627 ms/op
                 executeQuery·p0.90:   3661.627 ms/op
                 executeQuery·p0.95:   3661.627 ms/op
                 executeQuery·p0.99:   3661.627 ms/op
                 executeQuery·p0.999:  3661.627 ms/op
                 executeQuery·p0.9999: 3661.627 ms/op
                 executeQuery·p1.00:   3661.627 ms/op

Iteration   2: 3714.755 ±(99.9%) 1553.809 ms/op
                 executeQuery·p0.00:   3657.433 ms/op
                 executeQuery·p0.50:   3674.210 ms/op
                 executeQuery·p0.90:   3812.622 ms/op
                 executeQuery·p0.95:   3812.622 ms/op
                 executeQuery·p0.99:   3812.622 ms/op
                 executeQuery·p0.999:  3812.622 ms/op
                 executeQuery·p0.9999: 3812.622 ms/op
                 executeQuery·p1.00:   3812.622 ms/op

Iteration   3: 3658.831 ±(99.9%) 116.886 ms/op
                 executeQuery·p0.00:   3653.239 ms/op
                 executeQuery·p0.50:   3657.433 ms/op
                 executeQuery·p0.90:   3665.822 ms/op
                 executeQuery·p0.95:   3665.822 ms/op
                 executeQuery·p0.99:   3665.822 ms/op
                 executeQuery·p0.999:  3665.822 ms/op
                 executeQuery·p0.9999: 3665.822 ms/op
                 executeQuery·p1.00:   3665.822 ms/op

Iteration   4: 3664.424 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   3661.627 ms/op
                 executeQuery·p0.50:   3665.822 ms/op
                 executeQuery·p0.90:   3665.822 ms/op
                 executeQuery·p0.95:   3665.822 ms/op
                 executeQuery·p0.99:   3665.822 ms/op
                 executeQuery·p0.999:  3665.822 ms/op
                 executeQuery·p0.9999: 3665.822 ms/op
                 executeQuery·p1.00:   3665.822 ms/op

Iteration   5: 3686.793 ±(99.9%) 930.903 ms/op
                 executeQuery·p0.00:   3653.239 ms/op
                 executeQuery·p0.50:   3661.627 ms/op
                 executeQuery·p0.90:   3745.513 ms/op
                 executeQuery·p0.95:   3745.513 ms/op
                 executeQuery·p0.99:   3745.513 ms/op
                 executeQuery·p0.999:  3745.513 ms/op
                 executeQuery·p0.9999: 3745.513 ms/op
                 executeQuery·p1.00:   3745.513 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 30
  mean =   3537.196 ±(99.9%) 102.958 ms/op

  Histogram, ms/op:
    [3300.000, 3350.000) = 0 
    [3350.000, 3400.000) = 12 
    [3400.000, 3450.000) = 1 
    [3450.000, 3500.000) = 0 
    [3500.000, 3550.000) = 0 
    [3550.000, 3600.000) = 2 
    [3600.000, 3650.000) = 0 
    [3650.000, 3700.000) = 13 
    [3700.000, 3750.000) = 1 
    [3750.000, 3800.000) = 0 
    [3800.000, 3850.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   3363.832 ms/op
     p(50.0000) =   3617.587 ms/op
     p(90.0000) =   3673.371 ms/op
     p(95.0000) =   3775.712 ms/op
     p(99.0000) =   3812.622 ms/op
     p(99.9000) =   3812.622 ms/op
     p(99.9900) =   3812.622 ms/op
     p(99.9990) =   3812.622 ms/op
     p(99.9999) =   3812.622 ms/op
    p(100.0000) =   3812.622 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16)

# Run progress: 22.78% complete, ETA 19:40:09
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6949.962 ms/op
# Warmup Iteration   2: 4644.493 ±(99.9%) 4026.809 ms/op
# Warmup Iteration   3: 4535.441 ±(99.9%) 353.429 ms/op
# Warmup Iteration   4: 4535.441 ±(99.9%) 176.715 ms/op
# Warmup Iteration   5: 4532.645 ±(99.9%) 176.715 ms/op
Iteration   1: 4552.218 ±(99.9%) 318.577 ms/op
                 executeQuery·p0.00:   4538.237 ms/op
                 executeQuery·p0.50:   4546.626 ms/op
                 executeQuery·p0.90:   4571.791 ms/op
                 executeQuery·p0.95:   4571.791 ms/op
                 executeQuery·p0.99:   4571.791 ms/op
                 executeQuery·p0.999:  4571.791 ms/op
                 executeQuery·p0.9999: 4571.791 ms/op
                 executeQuery·p1.00:   4571.791 ms/op

Iteration   2: 4529.848 ±(99.9%) 153.039 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4538.237 ms/op
                 executeQuery·p0.95:   4538.237 ms/op
                 executeQuery·p0.99:   4538.237 ms/op
                 executeQuery·p0.999:  4538.237 ms/op
                 executeQuery·p0.9999: 4538.237 ms/op
                 executeQuery·p1.00:   4538.237 ms/op

Iteration   3: 4538.237 ±(99.9%) 153.039 ms/op
                 executeQuery·p0.00:   4529.848 ms/op
                 executeQuery·p0.50:   4538.237 ms/op
                 executeQuery·p0.90:   4546.626 ms/op
                 executeQuery·p0.95:   4546.626 ms/op
                 executeQuery·p0.99:   4546.626 ms/op
                 executeQuery·p0.999:  4546.626 ms/op
                 executeQuery·p0.9999: 4546.626 ms/op
                 executeQuery·p1.00:   4546.626 ms/op

Iteration   4: 4535.441 ±(99.9%) 176.715 ms/op
                 executeQuery·p0.00:   4529.848 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4546.626 ms/op
                 executeQuery·p0.95:   4546.626 ms/op
                 executeQuery·p0.99:   4546.626 ms/op
                 executeQuery·p0.999:  4546.626 ms/op
                 executeQuery·p0.9999: 4546.626 ms/op
                 executeQuery·p1.00:   4546.626 ms/op

Iteration   5: 4555.014 ±(99.9%) 930.903 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4613.734 ms/op
                 executeQuery·p0.95:   4613.734 ms/op
                 executeQuery·p0.99:   4613.734 ms/op
                 executeQuery·p0.999:  4613.734 ms/op
                 executeQuery·p0.9999: 4613.734 ms/op
                 executeQuery·p1.00:   4613.734 ms/op


# Run progress: 23.10% complete, ETA 19:26:54
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

4571.791 ±(99.9%) 5473.166 ms/op
# Warmup Iteration   2: 4644.493 ±(99.9%) 4020.988 ms/op
# Warmup Iteration   3: 4527.052 ±(99.9%) 318.577 ms/op
# Warmup Iteration   4: 4532.645 ±(99.9%) 88.357 ms/op
# Warmup Iteration   5: 4532.645 ±(99.9%) 88.357 ms/op
Iteration   1: 4521.460 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4521.460 ms/op
                 executeQuery·p0.90:   4521.460 ms/op
                 executeQuery·p0.95:   4521.460 ms/op
                 executeQuery·p0.99:   4521.460 ms/op
                 executeQuery·p0.999:  4521.460 ms/op
                 executeQuery·p0.9999: 4521.460 ms/op
                 executeQuery·p1.00:   4521.460 ms/op

Iteration   2: 4527.052 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4529.848 ms/op
                 executeQuery·p0.95:   4529.848 ms/op
                 executeQuery·p0.99:   4529.848 ms/op
                 executeQuery·p0.999:  4529.848 ms/op
                 executeQuery·p0.9999: 4529.848 ms/op
                 executeQuery·p1.00:   4529.848 ms/op

Iteration   3: 4529.848 ±(99.9%) 153.039 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4538.237 ms/op
                 executeQuery·p0.95:   4538.237 ms/op
                 executeQuery·p0.99:   4538.237 ms/op
                 executeQuery·p0.999:  4538.237 ms/op
                 executeQuery·p0.9999: 4538.237 ms/op
                 executeQuery·p1.00:   4538.237 ms/op

Iteration   4: 4535.441 ±(99.9%) 318.577 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4529.848 ms/op
                 executeQuery·p0.90:   4555.014 ms/op
                 executeQuery·p0.95:   4555.014 ms/op
                 executeQuery·p0.99:   4555.014 ms/op
                 executeQuery·p0.999:  4555.014 ms/op
                 executeQuery·p0.9999: 4555.014 ms/op
                 executeQuery·p1.00:   4555.014 ms/op

Iteration   5: 4524.256 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4521.460 ms/op
                 executeQuery·p0.50:   4521.460 ms/op
                 executeQuery·p0.90:   4529.848 ms/op
                 executeQuery·p0.95:   4529.848 ms/op
                 executeQuery·p0.99:   4529.848 ms/op
                 executeQuery·p0.999:  4529.848 ms/op
                 executeQuery·p0.9999: 4529.848 ms/op
                 executeQuery·p1.00:   4529.848 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 30
  mean =   4534.881 ±(99.9%) 12.712 ms/op

  Histogram, ms/op:
    [4520.000, 4530.000) = 20 
    [4530.000, 4540.000) = 4 
    [4540.000, 4550.000) = 3 
    [4550.000, 4560.000) = 1 
    [4560.000, 4570.000) = 0 
    [4570.000, 4580.000) = 1 
    [4580.000, 4590.000) = 0 
    [4590.000, 4600.000) = 0 
    [4600.000, 4610.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   4521.460 ms/op
     p(50.0000) =   4529.848 ms/op
     p(90.0000) =   4554.175 ms/op
     p(95.0000) =   4590.666 ms/op
     p(99.0000) =   4613.734 ms/op
     p(99.9000) =   4613.734 ms/op
     p(99.9900) =   4613.734 ms/op
     p(99.9990) =   4613.734 ms/op
     p(99.9999) =   4613.734 ms/op
    p(100.0000) =   4613.734 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192)

# Run progress: 23.42% complete, ETA 19:13:56
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

7662.993 ms/op
# Warmup Iteration   2: 6186.598 ms/op
# Warmup Iteration   3: 6220.153 ms/op
# Warmup Iteration   4: 6153.044 ms/op
# Warmup Iteration   5: 5943.329 ms/op
Iteration   1: 6278.873 ms/op
                 executeQuery·p0.00:   6241.124 ms/op
                 executeQuery·p0.50:   6278.873 ms/op
                 executeQuery·p0.90:   6316.622 ms/op
                 executeQuery·p0.95:   6316.622 ms/op
                 executeQuery·p0.99:   6316.622 ms/op
                 executeQuery·p0.999:  6316.622 ms/op
                 executeQuery·p0.9999: 6316.622 ms/op
                 executeQuery·p1.00:   6316.622 ms/op

Iteration   2: 6186.598 ms/op
                 executeQuery·p0.00:   6123.684 ms/op
                 executeQuery·p0.50:   6186.598 ms/op
                 executeQuery·p0.90:   6249.513 ms/op
                 executeQuery·p0.95:   6249.513 ms/op
                 executeQuery·p0.99:   6249.513 ms/op
                 executeQuery·p0.999:  6249.513 ms/op
                 executeQuery·p0.9999: 6249.513 ms/op
                 executeQuery·p1.00:   6249.513 ms/op

Iteration   3: 6098.518 ms/op
                 executeQuery·p0.00:   5964.300 ms/op
                 executeQuery·p0.50:   6098.518 ms/op
                 executeQuery·p0.90:   6232.736 ms/op
                 executeQuery·p0.95:   6232.736 ms/op
                 executeQuery·p0.99:   6232.736 ms/op
                 executeQuery·p0.999:  6232.736 ms/op
                 executeQuery·p0.9999: 6232.736 ms/op
                 executeQuery·p1.00:   6232.736 ms/op

Iteration   4: 6098.518 ms/op
                 executeQuery·p0.00:   5972.689 ms/op
                 executeQuery·p0.50:   6098.518 ms/op
                 executeQuery·p0.90:   6224.347 ms/op
                 executeQuery·p0.95:   6224.347 ms/op
                 executeQuery·p0.99:   6224.347 ms/op
                 executeQuery·p0.999:  6224.347 ms/op
                 executeQuery·p0.9999: 6224.347 ms/op
                 executeQuery·p1.00:   6224.347 ms/op

Iteration   5: 6215.959 ms/op
                 executeQuery·p0.00:   6215.959 ms/op
                 executeQuery·p0.50:   6215.959 ms/op
                 executeQuery·p0.90:   6215.959 ms/op
                 executeQuery·p0.95:   6215.959 ms/op
                 executeQuery·p0.99:   6215.959 ms/op
                 executeQuery·p0.999:  6215.959 ms/op
                 executeQuery·p0.9999: 6215.959 ms/op
                 executeQuery·p1.00:   6215.959 ms/op


# Run progress: 23.73% complete, ETA 19:00:42
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

7327.449 ms/op
# Warmup Iteration   2: 6819.938 ms/op
# Warmup Iteration   3: 6710.886 ms/op
# Warmup Iteration   4: 6631.195 ms/op
# Warmup Iteration   5: 6631.195 ms/op
Iteration   1: 6572.474 ms/op
                 executeQuery·p0.00:   6417.285 ms/op
                 executeQuery·p0.50:   6572.474 ms/op
                 executeQuery·p0.90:   6727.664 ms/op
                 executeQuery·p0.95:   6727.664 ms/op
                 executeQuery·p0.99:   6727.664 ms/op
                 executeQuery·p0.999:  6727.664 ms/op
                 executeQuery·p0.9999: 6727.664 ms/op
                 executeQuery·p1.00:   6727.664 ms/op

Iteration   2: 6706.692 ms/op
                 executeQuery·p0.00:   6702.498 ms/op
                 executeQuery·p0.50:   6706.692 ms/op
                 executeQuery·p0.90:   6710.886 ms/op
                 executeQuery·p0.95:   6710.886 ms/op
                 executeQuery·p0.99:   6710.886 ms/op
                 executeQuery·p0.999:  6710.886 ms/op
                 executeQuery·p0.9999: 6710.886 ms/op
                 executeQuery·p1.00:   6710.886 ms/op

Iteration   3: 6559.891 ms/op
                 executeQuery·p0.00:   6484.394 ms/op
                 executeQuery·p0.50:   6559.891 ms/op
                 executeQuery·p0.90:   6635.389 ms/op
                 executeQuery·p0.95:   6635.389 ms/op
                 executeQuery·p0.99:   6635.389 ms/op
                 executeQuery·p0.999:  6635.389 ms/op
                 executeQuery·p0.9999: 6635.389 ms/op
                 executeQuery·p1.00:   6635.389 ms/op

Iteration   4: 6736.052 ms/op
                 executeQuery·p0.00:   6736.052 ms/op
                 executeQuery·p0.50:   6736.052 ms/op
                 executeQuery·p0.90:   6736.052 ms/op
                 executeQuery·p0.95:   6736.052 ms/op
                 executeQuery·p0.99:   6736.052 ms/op
                 executeQuery·p0.999:  6736.052 ms/op
                 executeQuery·p0.9999: 6736.052 ms/op
                 executeQuery·p1.00:   6736.052 ms/op

Iteration   5: 6606.029 ms/op
                 executeQuery·p0.00:   6492.783 ms/op
                 executeQuery·p0.50:   6606.029 ms/op
                 executeQuery·p0.90:   6719.275 ms/op
                 executeQuery·p0.95:   6719.275 ms/op
                 executeQuery·p0.99:   6719.275 ms/op
                 executeQuery·p0.999:  6719.275 ms/op
                 executeQuery·p0.9999: 6719.275 ms/op
                 executeQuery·p1.00:   6719.275 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 20
  mean =   6405.960 ±(99.9%) 229.247 ms/op

  Histogram, ms/op:
    [5900.000, 5950.000) = 0 
    [5950.000, 6000.000) = 2 
    [6000.000, 6050.000) = 0 
    [6050.000, 6100.000) = 0 
    [6100.000, 6150.000) = 1 
    [6150.000, 6200.000) = 0 
    [6200.000, 6250.000) = 6 
    [6250.000, 6300.000) = 0 
    [6300.000, 6350.000) = 1 
    [6350.000, 6400.000) = 0 
    [6400.000, 6450.000) = 1 
    [6450.000, 6500.000) = 2 
    [6500.000, 6550.000) = 0 
    [6550.000, 6600.000) = 0 
    [6600.000, 6650.000) = 1 
    [6650.000, 6700.000) = 0 
    [6700.000, 6750.000) = 6 

  Percentiles, ms/op:
      p(0.0000) =   5964.300 ms/op
     p(50.0000) =   6366.953 ms/op
     p(90.0000) =   6735.213 ms/op
     p(95.0000) =   6736.052 ms/op
     p(99.0000) =   6736.052 ms/op
     p(99.9000) =   6736.052 ms/op
     p(99.9900) =   6736.052 ms/op
     p(99.9990) =   6736.052 ms/op
     p(99.9999) =   6736.052 ms/op
    p(100.0000) =   6736.052 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144)

# Run progress: 24.05% complete, ETA 18:48:13
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

28991.029 ms/op
# Warmup Iteration   2: 26508.001 ms/op
# Warmup Iteration   3: 25669.140 ms/op
# Warmup Iteration   4: 26709.328 ms/op
# Warmup Iteration   5: 26776.437 ms/op
Iteration   1: 25702.695 ms/op
                 executeQuery·p0.00:   25702.695 ms/op
                 executeQuery·p0.50:   25702.695 ms/op
                 executeQuery·p0.90:   25702.695 ms/op
                 executeQuery·p0.95:   25702.695 ms/op
                 executeQuery·p0.99:   25702.695 ms/op
                 executeQuery·p0.999:  25702.695 ms/op
                 executeQuery·p0.9999: 25702.695 ms/op
                 executeQuery·p1.00:   25702.695 ms/op

Iteration   2: 25669.140 ms/op
                 executeQuery·p0.00:   25669.140 ms/op
                 executeQuery·p0.50:   25669.140 ms/op
                 executeQuery·p0.90:   25669.140 ms/op
                 executeQuery·p0.95:   25669.140 ms/op
                 executeQuery·p0.99:   25669.140 ms/op
                 executeQuery·p0.999:  25669.140 ms/op
                 executeQuery·p0.9999: 25669.140 ms/op
                 executeQuery·p1.00:   25669.140 ms/op

Iteration   3: 25937.576 ms/op
                 executeQuery·p0.00:   25937.576 ms/op
                 executeQuery·p0.50:   25937.576 ms/op
                 executeQuery·p0.90:   25937.576 ms/op
                 executeQuery·p0.95:   25937.576 ms/op
                 executeQuery·p0.99:   25937.576 ms/op
                 executeQuery·p0.999:  25937.576 ms/op
                 executeQuery·p0.9999: 25937.576 ms/op
                 executeQuery·p1.00:   25937.576 ms/op

Iteration   4: 27279.753 ms/op
                 executeQuery·p0.00:   27279.753 ms/op
                 executeQuery·p0.50:   27279.753 ms/op
                 executeQuery·p0.90:   27279.753 ms/op
                 executeQuery·p0.95:   27279.753 ms/op
                 executeQuery·p0.99:   27279.753 ms/op
                 executeQuery·p0.999:  27279.753 ms/op
                 executeQuery·p0.9999: 27279.753 ms/op
                 executeQuery·p1.00:   27279.753 ms/op

Iteration   5: 25937.576 ms/op
                 executeQuery·p0.00:   25937.576 ms/op
                 executeQuery·p0.50:   25937.576 ms/op
                 executeQuery·p0.90:   25937.576 ms/op
                 executeQuery·p0.95:   25937.576 ms/op
                 executeQuery·p0.99:   25937.576 ms/op
                 executeQuery·p0.999:  25937.576 ms/op
                 executeQuery·p0.9999: 25937.576 ms/op
                 executeQuery·p1.00:   25937.576 ms/op


# Run progress: 24.37% complete, ETA 18:47:00
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

26809.991 ms/op
# Warmup Iteration   2: 25769.804 ms/op
# Warmup Iteration   3: 26206.011 ms/op
# Warmup Iteration   4: 26642.219 ms/op
# Warmup Iteration   5: 21407.728 ms/op
Iteration   1: 25065.161 ms/op
                 executeQuery·p0.00:   25065.161 ms/op
                 executeQuery·p0.50:   25065.161 ms/op
                 executeQuery·p0.90:   25065.161 ms/op
                 executeQuery·p0.95:   25065.161 ms/op
                 executeQuery·p0.99:   25065.161 ms/op
                 executeQuery·p0.999:  25065.161 ms/op
                 executeQuery·p0.9999: 25065.161 ms/op
                 executeQuery·p1.00:   25065.161 ms/op

Iteration   2: 25602.032 ms/op
                 executeQuery·p0.00:   25602.032 ms/op
                 executeQuery·p0.50:   25602.032 ms/op
                 executeQuery·p0.90:   25602.032 ms/op
                 executeQuery·p0.95:   25602.032 ms/op
                 executeQuery·p0.99:   25602.032 ms/op
                 executeQuery·p0.999:  25602.032 ms/op
                 executeQuery·p0.9999: 25602.032 ms/op
                 executeQuery·p1.00:   25602.032 ms/op

Iteration   3: 25165.824 ms/op
                 executeQuery·p0.00:   25165.824 ms/op
                 executeQuery·p0.50:   25165.824 ms/op
                 executeQuery·p0.90:   25165.824 ms/op
                 executeQuery·p0.95:   25165.824 ms/op
                 executeQuery·p0.99:   25165.824 ms/op
                 executeQuery·p0.999:  25165.824 ms/op
                 executeQuery·p0.9999: 25165.824 ms/op
                 executeQuery·p1.00:   25165.824 ms/op

Iteration   4: 24998.052 ms/op
                 executeQuery·p0.00:   24998.052 ms/op
                 executeQuery·p0.50:   24998.052 ms/op
                 executeQuery·p0.90:   24998.052 ms/op
                 executeQuery·p0.95:   24998.052 ms/op
                 executeQuery·p0.99:   24998.052 ms/op
                 executeQuery·p0.999:  24998.052 ms/op
                 executeQuery·p0.9999: 24998.052 ms/op
                 executeQuery·p1.00:   24998.052 ms/op

Iteration   5: 25232.933 ms/op
                 executeQuery·p0.00:   25232.933 ms/op
                 executeQuery·p0.50:   25232.933 ms/op
                 executeQuery·p0.90:   25232.933 ms/op
                 executeQuery·p0.95:   25232.933 ms/op
                 executeQuery·p0.99:   25232.933 ms/op
                 executeQuery·p0.999:  25232.933 ms/op
                 executeQuery·p0.9999: 25232.933 ms/op
                 executeQuery·p1.00:   25232.933 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =  25659.074 ±(99.9%) 1008.102 ms/op

  Histogram, ms/op:
    [24000.000, 24250.000) = 0 
    [24250.000, 24500.000) = 0 
    [24500.000, 24750.000) = 0 
    [24750.000, 25000.000) = 1 
    [25000.000, 25250.000) = 3 
    [25250.000, 25500.000) = 0 
    [25500.000, 25750.000) = 3 
    [25750.000, 26000.000) = 2 
    [26000.000, 26250.000) = 0 
    [26250.000, 26500.000) = 0 
    [26500.000, 26750.000) = 0 
    [26750.000, 27000.000) = 0 
    [27000.000, 27250.000) = 0 
    [27250.000, 27500.000) = 1 
    [27500.000, 27750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  24998.052 ms/op
     p(50.0000) =  25635.586 ms/op
     p(90.0000) =  27145.535 ms/op
     p(95.0000) =  27279.753 ms/op
     p(99.0000) =  27279.753 ms/op
     p(99.9000) =  27279.753 ms/op
     p(99.9900) =  27279.753 ms/op
     p(99.9990) =  27279.753 ms/op
     p(99.9999) =  27279.753 ms/op
    p(100.0000) =  27279.753 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288)

# Run progress: 24.68% complete, ETA 18:45:19
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

52613.349 ms/op
# Warmup Iteration   2: 50063.213 ms/op
# Warmup Iteration   3: 49996.104 ms/op
# Warmup Iteration   4: 48788.144 ms/op
# Warmup Iteration   5: 50600.083 ms/op
Iteration   1: 49123.688 ms/op
                 executeQuery·p0.00:   49123.688 ms/op
                 executeQuery·p0.50:   49123.688 ms/op
                 executeQuery·p0.90:   49123.688 ms/op
                 executeQuery·p0.95:   49123.688 ms/op
                 executeQuery·p0.99:   49123.688 ms/op
                 executeQuery·p0.999:  49123.688 ms/op
                 executeQuery·p0.9999: 49123.688 ms/op
                 executeQuery·p1.00:   49123.688 ms/op

Iteration   2: 50801.410 ms/op
                 executeQuery·p0.00:   50801.410 ms/op
                 executeQuery·p0.50:   50801.410 ms/op
                 executeQuery·p0.90:   50801.410 ms/op
                 executeQuery·p0.95:   50801.410 ms/op
                 executeQuery·p0.99:   50801.410 ms/op
                 executeQuery·p0.999:  50801.410 ms/op
                 executeQuery·p0.9999: 50801.410 ms/op
                 executeQuery·p1.00:   50801.410 ms/op

Iteration   3: 49325.015 ms/op
                 executeQuery·p0.00:   49325.015 ms/op
                 executeQuery·p0.50:   49325.015 ms/op
                 executeQuery·p0.90:   49325.015 ms/op
                 executeQuery·p0.95:   49325.015 ms/op
                 executeQuery·p0.99:   49325.015 ms/op
                 executeQuery·p0.999:  49325.015 ms/op
                 executeQuery·p0.9999: 49325.015 ms/op
                 executeQuery·p1.00:   49325.015 ms/op

Iteration   4: 47513.076 ms/op
                 executeQuery·p0.00:   47513.076 ms/op
                 executeQuery·p0.50:   47513.076 ms/op
                 executeQuery·p0.90:   47513.076 ms/op
                 executeQuery·p0.95:   47513.076 ms/op
                 executeQuery·p0.99:   47513.076 ms/op
                 executeQuery·p0.999:  47513.076 ms/op
                 executeQuery·p0.9999: 47513.076 ms/op
                 executeQuery·p1.00:   47513.076 ms/op

Iteration   5: 50667.192 ms/op
                 executeQuery·p0.00:   50667.192 ms/op
                 executeQuery·p0.50:   50667.192 ms/op
                 executeQuery·p0.90:   50667.192 ms/op
                 executeQuery·p0.95:   50667.192 ms/op
                 executeQuery·p0.99:   50667.192 ms/op
                 executeQuery·p0.999:  50667.192 ms/op
                 executeQuery·p0.9999: 50667.192 ms/op
                 executeQuery·p1.00:   50667.192 ms/op


# Run progress: 25.00% complete, ETA 19:08:52
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

51136.954 ms/op
# Warmup Iteration   2: 49526.342 ms/op
# Warmup Iteration   3: 52210.696 ms/op
# Warmup Iteration   4: 48519.709 ms/op
# Warmup Iteration   5: 51069.846 ms/op
Iteration   1: 49257.906 ms/op
                 executeQuery·p0.00:   49257.906 ms/op
                 executeQuery·p0.50:   49257.906 ms/op
                 executeQuery·p0.90:   49257.906 ms/op
                 executeQuery·p0.95:   49257.906 ms/op
                 executeQuery·p0.99:   49257.906 ms/op
                 executeQuery·p0.999:  49257.906 ms/op
                 executeQuery·p0.9999: 49257.906 ms/op
                 executeQuery·p1.00:   49257.906 ms/op

Iteration   2: 50935.628 ms/op
                 executeQuery·p0.00:   50935.628 ms/op
                 executeQuery·p0.50:   50935.628 ms/op
                 executeQuery·p0.90:   50935.628 ms/op
                 executeQuery·p0.95:   50935.628 ms/op
                 executeQuery·p0.99:   50935.628 ms/op
                 executeQuery·p0.999:  50935.628 ms/op
                 executeQuery·p0.9999: 50935.628 ms/op
                 executeQuery·p1.00:   50935.628 ms/op

Iteration   3: 48653.926 ms/op
                 executeQuery·p0.00:   48653.926 ms/op
                 executeQuery·p0.50:   48653.926 ms/op
                 executeQuery·p0.90:   48653.926 ms/op
                 executeQuery·p0.95:   48653.926 ms/op
                 executeQuery·p0.99:   48653.926 ms/op
                 executeQuery·p0.999:  48653.926 ms/op
                 executeQuery·p0.9999: 48653.926 ms/op
                 executeQuery·p1.00:   48653.926 ms/op

Iteration   4: 48318.382 ms/op
                 executeQuery·p0.00:   48318.382 ms/op
                 executeQuery·p0.50:   48318.382 ms/op
                 executeQuery·p0.90:   48318.382 ms/op
                 executeQuery·p0.95:   48318.382 ms/op
                 executeQuery·p0.99:   48318.382 ms/op
                 executeQuery·p0.999:  48318.382 ms/op
                 executeQuery·p0.9999: 48318.382 ms/op
                 executeQuery·p1.00:   48318.382 ms/op

Iteration   5: 51069.846 ms/op
                 executeQuery·p0.00:   51069.846 ms/op
                 executeQuery·p0.50:   51069.846 ms/op
                 executeQuery·p0.90:   51069.846 ms/op
                 executeQuery·p0.95:   51069.846 ms/op
                 executeQuery·p0.99:   51069.846 ms/op
                 executeQuery·p0.999:  51069.846 ms/op
                 executeQuery·p0.9999: 51069.846 ms/op
                 executeQuery·p1.00:   51069.846 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =  49566.607 ±(99.9%) 1873.988 ms/op

  Histogram, ms/op:
    [47000.000, 47500.000) = 0 
    [47500.000, 48000.000) = 1 
    [48000.000, 48500.000) = 1 
    [48500.000, 49000.000) = 1 
    [49000.000, 49500.000) = 3 
    [49500.000, 50000.000) = 0 
    [50000.000, 50500.000) = 0 
    [50500.000, 51000.000) = 3 
    [51000.000, 51500.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  47513.076 ms/op
     p(50.0000) =  49291.461 ms/op
     p(90.0000) =  51056.424 ms/op
     p(95.0000) =  51069.846 ms/op
     p(99.0000) =  51069.846 ms/op
     p(99.9000) =  51069.846 ms/op
     p(99.9900) =  51069.846 ms/op
     p(99.9990) =  51069.846 ms/op
     p(99.9999) =  51069.846 ms/op
    p(100.0000) =  51069.846 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2)

# Run progress: 25.32% complete, ETA 19:31:50
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

17918.067 ms/op
# Warmup Iteration   2: 7721.714 ms/op
# Warmup Iteration   3: 7465.861 ms/op
# Warmup Iteration   4: 6706.692 ms/op
# Warmup Iteration   5: 6723.469 ms/op
Iteration   1: 6723.469 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6723.469 ms/op
                 executeQuery·p0.90:   6727.664 ms/op
                 executeQuery·p0.95:   6727.664 ms/op
                 executeQuery·p0.99:   6727.664 ms/op
                 executeQuery·p0.999:  6727.664 ms/op
                 executeQuery·p0.9999: 6727.664 ms/op
                 executeQuery·p1.00:   6727.664 ms/op

Iteration   2: 6719.275 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6719.275 ms/op
                 executeQuery·p0.90:   6719.275 ms/op
                 executeQuery·p0.95:   6719.275 ms/op
                 executeQuery·p0.99:   6719.275 ms/op
                 executeQuery·p0.999:  6719.275 ms/op
                 executeQuery·p0.9999: 6719.275 ms/op
                 executeQuery·p1.00:   6719.275 ms/op

Iteration   3: 6849.298 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6849.298 ms/op
                 executeQuery·p0.90:   6979.322 ms/op
                 executeQuery·p0.95:   6979.322 ms/op
                 executeQuery·p0.99:   6979.322 ms/op
                 executeQuery·p0.999:  6979.322 ms/op
                 executeQuery·p0.9999: 6979.322 ms/op
                 executeQuery·p1.00:   6979.322 ms/op

Iteration   4: 6723.469 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6723.469 ms/op
                 executeQuery·p0.90:   6727.664 ms/op
                 executeQuery·p0.95:   6727.664 ms/op
                 executeQuery·p0.99:   6727.664 ms/op
                 executeQuery·p0.999:  6727.664 ms/op
                 executeQuery·p0.9999: 6727.664 ms/op
                 executeQuery·p1.00:   6727.664 ms/op

Iteration   5: 6723.469 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6723.469 ms/op
                 executeQuery·p0.90:   6727.664 ms/op
                 executeQuery·p0.95:   6727.664 ms/op
                 executeQuery·p0.99:   6727.664 ms/op
                 executeQuery·p0.999:  6727.664 ms/op
                 executeQuery·p0.9999: 6727.664 ms/op
                 executeQuery·p1.00:   6727.664 ms/op


# Run progress: 25.63% complete, ETA 19:19:27
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5695.865 ms/op
# Warmup Iteration   2: 7654.605 ms/op
# Warmup Iteration   3: 6740.247 ms/op
# Warmup Iteration   4: 6723.469 ms/op
# Warmup Iteration   5: 6627.000 ms/op
Iteration   1: 6618.612 ms/op
                 executeQuery·p0.00:   6618.612 ms/op
                 executeQuery·p0.50:   6618.612 ms/op
                 executeQuery·p0.90:   6618.612 ms/op
                 executeQuery·p0.95:   6618.612 ms/op
                 executeQuery·p0.99:   6618.612 ms/op
                 executeQuery·p0.999:  6618.612 ms/op
                 executeQuery·p0.9999: 6618.612 ms/op
                 executeQuery·p1.00:   6618.612 ms/op

Iteration   2: 6610.223 ms/op
                 executeQuery·p0.00:   6610.223 ms/op
                 executeQuery·p0.50:   6610.223 ms/op
                 executeQuery·p0.90:   6610.223 ms/op
                 executeQuery·p0.95:   6610.223 ms/op
                 executeQuery·p0.99:   6610.223 ms/op
                 executeQuery·p0.999:  6610.223 ms/op
                 executeQuery·p0.9999: 6610.223 ms/op
                 executeQuery·p1.00:   6610.223 ms/op

Iteration   3: 6765.412 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6765.412 ms/op
                 executeQuery·p0.90:   6811.550 ms/op
                 executeQuery·p0.95:   6811.550 ms/op
                 executeQuery·p0.99:   6811.550 ms/op
                 executeQuery·p0.999:  6811.550 ms/op
                 executeQuery·p0.9999: 6811.550 ms/op
                 executeQuery·p1.00:   6811.550 ms/op

Iteration   4: 6748.635 ms/op
                 executeQuery·p0.00:   6719.275 ms/op
                 executeQuery·p0.50:   6748.635 ms/op
                 executeQuery·p0.90:   6777.995 ms/op
                 executeQuery·p0.95:   6777.995 ms/op
                 executeQuery·p0.99:   6777.995 ms/op
                 executeQuery·p0.999:  6777.995 ms/op
                 executeQuery·p0.9999: 6777.995 ms/op
                 executeQuery·p1.00:   6777.995 ms/op

Iteration   5: 7151.288 ms/op
                 executeQuery·p0.00:   6727.664 ms/op
                 executeQuery·p0.50:   7151.288 ms/op
                 executeQuery·p0.90:   7574.913 ms/op
                 executeQuery·p0.95:   7574.913 ms/op
                 executeQuery·p0.99:   7574.913 ms/op
                 executeQuery·p0.999:  7574.913 ms/op
                 executeQuery·p0.9999: 7574.913 ms/op
                 executeQuery·p1.00:   7574.913 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 20
  mean =   6763.315 ±(99.9%) 180.093 ms/op

  Histogram, ms/op:
    [6600.000, 6700.000) = 4 
    [6700.000, 6800.000) = 13 
    [6800.000, 6900.000) = 1 
    [6900.000, 7000.000) = 1 
    [7000.000, 7100.000) = 0 
    [7100.000, 7200.000) = 0 
    [7200.000, 7300.000) = 0 
    [7300.000, 7400.000) = 0 
    [7400.000, 7500.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   6610.223 ms/op
     p(50.0000) =   6719.275 ms/op
     p(90.0000) =   6962.545 ms/op
     p(95.0000) =   7545.133 ms/op
     p(99.0000) =   7574.913 ms/op
     p(99.9000) =   7574.913 ms/op
     p(99.9900) =   7574.913 ms/op
     p(99.9990) =   7574.913 ms/op
     p(99.9999) =   7574.913 ms/op
    p(100.0000) =   7574.913 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16)

# Run progress: 25.95% complete, ETA 19:06:56
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

17179.869 ms/op
# Warmup Iteration   2: 11609.833 ms/op
# Warmup Iteration   3: 10670.309 ms/op
# Warmup Iteration   4: 11827.937 ms/op
# Warmup Iteration   5: 10804.527 ms/op
Iteration   1: 10804.527 ms/op
                 executeQuery·p0.00:   10804.527 ms/op
                 executeQuery·p0.50:   10804.527 ms/op
                 executeQuery·p0.90:   10804.527 ms/op
                 executeQuery·p0.95:   10804.527 ms/op
                 executeQuery·p0.99:   10804.527 ms/op
                 executeQuery·p0.999:  10804.527 ms/op
                 executeQuery·p0.9999: 10804.527 ms/op
                 executeQuery·p1.00:   10804.527 ms/op

Iteration   2: 10770.973 ms/op
                 executeQuery·p0.00:   10770.973 ms/op
                 executeQuery·p0.50:   10770.973 ms/op
                 executeQuery·p0.90:   10770.973 ms/op
                 executeQuery·p0.95:   10770.973 ms/op
                 executeQuery·p0.99:   10770.973 ms/op
                 executeQuery·p0.999:  10770.973 ms/op
                 executeQuery·p0.9999: 10770.973 ms/op
                 executeQuery·p1.00:   10770.973 ms/op

Iteration   3: 10754.195 ms/op
                 executeQuery·p0.00:   10754.195 ms/op
                 executeQuery·p0.50:   10754.195 ms/op
                 executeQuery·p0.90:   10754.195 ms/op
                 executeQuery·p0.95:   10754.195 ms/op
                 executeQuery·p0.99:   10754.195 ms/op
                 executeQuery·p0.999:  10754.195 ms/op
                 executeQuery·p0.9999: 10754.195 ms/op
                 executeQuery·p1.00:   10754.195 ms/op

Iteration   4: 10804.527 ms/op
                 executeQuery·p0.00:   10804.527 ms/op
                 executeQuery·p0.50:   10804.527 ms/op
                 executeQuery·p0.90:   10804.527 ms/op
                 executeQuery·p0.95:   10804.527 ms/op
                 executeQuery·p0.99:   10804.527 ms/op
                 executeQuery·p0.999:  10804.527 ms/op
                 executeQuery·p0.9999: 10804.527 ms/op
                 executeQuery·p1.00:   10804.527 ms/op

Iteration   5: 10787.750 ms/op
                 executeQuery·p0.00:   10787.750 ms/op
                 executeQuery·p0.50:   10787.750 ms/op
                 executeQuery·p0.90:   10787.750 ms/op
                 executeQuery·p0.95:   10787.750 ms/op
                 executeQuery·p0.99:   10787.750 ms/op
                 executeQuery·p0.999:  10787.750 ms/op
                 executeQuery·p0.9999: 10787.750 ms/op
                 executeQuery·p1.00:   10787.750 ms/op


# Run progress: 26.27% complete, ETA 18:53:47
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

10502.537 ms/op
# Warmup Iteration   2: 10821.304 ms/op
# Warmup Iteration   3: 11777.606 ms/op
# Warmup Iteration   4: 10804.527 ms/op
# Warmup Iteration   5: 10888.413 ms/op
Iteration   1: 10787.750 ms/op
                 executeQuery·p0.00:   10787.750 ms/op
                 executeQuery·p0.50:   10787.750 ms/op
                 executeQuery·p0.90:   10787.750 ms/op
                 executeQuery·p0.95:   10787.750 ms/op
                 executeQuery·p0.99:   10787.750 ms/op
                 executeQuery·p0.999:  10787.750 ms/op
                 executeQuery·p0.9999: 10787.750 ms/op
                 executeQuery·p1.00:   10787.750 ms/op

Iteration   2: 10804.527 ms/op
                 executeQuery·p0.00:   10804.527 ms/op
                 executeQuery·p0.50:   10804.527 ms/op
                 executeQuery·p0.90:   10804.527 ms/op
                 executeQuery·p0.95:   10804.527 ms/op
                 executeQuery·p0.99:   10804.527 ms/op
                 executeQuery·p0.999:  10804.527 ms/op
                 executeQuery·p0.9999: 10804.527 ms/op
                 executeQuery·p1.00:   10804.527 ms/op

Iteration   3: 10787.750 ms/op
                 executeQuery·p0.00:   10787.750 ms/op
                 executeQuery·p0.50:   10787.750 ms/op
                 executeQuery·p0.90:   10787.750 ms/op
                 executeQuery·p0.95:   10787.750 ms/op
                 executeQuery·p0.99:   10787.750 ms/op
                 executeQuery·p0.999:  10787.750 ms/op
                 executeQuery·p0.9999: 10787.750 ms/op
                 executeQuery·p1.00:   10787.750 ms/op

Iteration   4: 10804.527 ms/op
                 executeQuery·p0.00:   10804.527 ms/op
                 executeQuery·p0.50:   10804.527 ms/op
                 executeQuery·p0.90:   10804.527 ms/op
                 executeQuery·p0.95:   10804.527 ms/op
                 executeQuery·p0.99:   10804.527 ms/op
                 executeQuery·p0.999:  10804.527 ms/op
                 executeQuery·p0.9999: 10804.527 ms/op
                 executeQuery·p1.00:   10804.527 ms/op

Iteration   5: 10854.859 ms/op
                 executeQuery·p0.00:   10854.859 ms/op
                 executeQuery·p0.50:   10854.859 ms/op
                 executeQuery·p0.90:   10854.859 ms/op
                 executeQuery·p0.95:   10854.859 ms/op
                 executeQuery·p0.99:   10854.859 ms/op
                 executeQuery·p0.999:  10854.859 ms/op
                 executeQuery·p0.9999: 10854.859 ms/op
                 executeQuery·p1.00:   10854.859 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =  10796.138 ±(99.9%) 40.105 ms/op

  Histogram, ms/op:
    [10700.000, 10712.500) = 0 
    [10712.500, 10725.000) = 0 
    [10725.000, 10737.500) = 0 
    [10737.500, 10750.000) = 0 
    [10750.000, 10762.500) = 1 
    [10762.500, 10775.000) = 1 
    [10775.000, 10787.500) = 0 
    [10787.500, 10800.000) = 3 
    [10800.000, 10812.500) = 4 
    [10812.500, 10825.000) = 0 
    [10825.000, 10837.500) = 0 
    [10837.500, 10850.000) = 0 
    [10850.000, 10862.500) = 1 
    [10862.500, 10875.000) = 0 
    [10875.000, 10887.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =  10754.195 ms/op
     p(50.0000) =  10796.138 ms/op
     p(90.0000) =  10849.826 ms/op
     p(95.0000) =  10854.859 ms/op
     p(99.0000) =  10854.859 ms/op
     p(99.9000) =  10854.859 ms/op
     p(99.9900) =  10854.859 ms/op
     p(99.9990) =  10854.859 ms/op
     p(99.9999) =  10854.859 ms/op
    p(100.0000) =  10854.859 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192)

# Run progress: 26.58% complete, ETA 18:41:03
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

16978.543 ms/op
# Warmup Iteration   2: 13555.991 ms/op
# Warmup Iteration   3: 12767.461 ms/op
# Warmup Iteration   4: 13220.446 ms/op
# Warmup Iteration   5: 13757.317 ms/op
Iteration   1: 13354.664 ms/op
                 executeQuery·p0.00:   13354.664 ms/op
                 executeQuery·p0.50:   13354.664 ms/op
                 executeQuery·p0.90:   13354.664 ms/op
                 executeQuery·p0.95:   13354.664 ms/op
                 executeQuery·p0.99:   13354.664 ms/op
                 executeQuery·p0.999:  13354.664 ms/op
                 executeQuery·p0.9999: 13354.664 ms/op
                 executeQuery·p1.00:   13354.664 ms/op

Iteration   2: 13388.218 ms/op
                 executeQuery·p0.00:   13388.218 ms/op
                 executeQuery·p0.50:   13388.218 ms/op
                 executeQuery·p0.90:   13388.218 ms/op
                 executeQuery·p0.95:   13388.218 ms/op
                 executeQuery·p0.99:   13388.218 ms/op
                 executeQuery·p0.999:  13388.218 ms/op
                 executeQuery·p0.9999: 13388.218 ms/op
                 executeQuery·p1.00:   13388.218 ms/op

Iteration   3: 13388.218 ms/op
                 executeQuery·p0.00:   13388.218 ms/op
                 executeQuery·p0.50:   13388.218 ms/op
                 executeQuery·p0.90:   13388.218 ms/op
                 executeQuery·p0.95:   13388.218 ms/op
                 executeQuery·p0.99:   13388.218 ms/op
                 executeQuery·p0.999:  13388.218 ms/op
                 executeQuery·p0.9999: 13388.218 ms/op
                 executeQuery·p1.00:   13388.218 ms/op

Iteration   4: 13589.545 ms/op
                 executeQuery·p0.00:   13589.545 ms/op
                 executeQuery·p0.50:   13589.545 ms/op
                 executeQuery·p0.90:   13589.545 ms/op
                 executeQuery·p0.95:   13589.545 ms/op
                 executeQuery·p0.99:   13589.545 ms/op
                 executeQuery·p0.999:  13589.545 ms/op
                 executeQuery·p0.9999: 13589.545 ms/op
                 executeQuery·p1.00:   13589.545 ms/op

Iteration   5: 13539.213 ms/op
                 executeQuery·p0.00:   13539.213 ms/op
                 executeQuery·p0.50:   13539.213 ms/op
                 executeQuery·p0.90:   13539.213 ms/op
                 executeQuery·p0.95:   13539.213 ms/op
                 executeQuery·p0.99:   13539.213 ms/op
                 executeQuery·p0.999:  13539.213 ms/op
                 executeQuery·p0.9999: 13539.213 ms/op
                 executeQuery·p1.00:   13539.213 ms/op


# Run progress: 26.90% complete, ETA 18:29:24
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

13706.985 ms/op
# Warmup Iteration   2: 12985.565 ms/op
# Warmup Iteration   3: 12398.363 ms/op
# Warmup Iteration   4: 12834.570 ms/op
# Warmup Iteration   5: 12113.150 ms/op
Iteration   1: 12582.912 ms/op
                 executeQuery·p0.00:   12582.912 ms/op
                 executeQuery·p0.50:   12582.912 ms/op
                 executeQuery·p0.90:   12582.912 ms/op
                 executeQuery·p0.95:   12582.912 ms/op
                 executeQuery·p0.99:   12582.912 ms/op
                 executeQuery·p0.999:  12582.912 ms/op
                 executeQuery·p0.9999: 12582.912 ms/op
                 executeQuery·p1.00:   12582.912 ms/op

Iteration   2: 12348.031 ms/op
                 executeQuery·p0.00:   12348.031 ms/op
                 executeQuery·p0.50:   12348.031 ms/op
                 executeQuery·p0.90:   12348.031 ms/op
                 executeQuery·p0.95:   12348.031 ms/op
                 executeQuery·p0.99:   12348.031 ms/op
                 executeQuery·p0.999:  12348.031 ms/op
                 executeQuery·p0.9999: 12348.031 ms/op
                 executeQuery·p1.00:   12348.031 ms/op

Iteration   3: 11593.056 ms/op
                 executeQuery·p0.00:   11593.056 ms/op
                 executeQuery·p0.50:   11593.056 ms/op
                 executeQuery·p0.90:   11593.056 ms/op
                 executeQuery·p0.95:   11593.056 ms/op
                 executeQuery·p0.99:   11593.056 ms/op
                 executeQuery·p0.999:  11593.056 ms/op
                 executeQuery·p0.9999: 11593.056 ms/op
                 executeQuery·p1.00:   11593.056 ms/op

Iteration   4: 11861.492 ms/op
                 executeQuery·p0.00:   11861.492 ms/op
                 executeQuery·p0.50:   11861.492 ms/op
                 executeQuery·p0.90:   11861.492 ms/op
                 executeQuery·p0.95:   11861.492 ms/op
                 executeQuery·p0.99:   11861.492 ms/op
                 executeQuery·p0.999:  11861.492 ms/op
                 executeQuery·p0.9999: 11861.492 ms/op
                 executeQuery·p1.00:   11861.492 ms/op

Iteration   5: 12113.150 ms/op
                 executeQuery·p0.00:   12113.150 ms/op
                 executeQuery·p0.50:   12113.150 ms/op
                 executeQuery·p0.90:   12113.150 ms/op
                 executeQuery·p0.95:   12113.150 ms/op
                 executeQuery·p0.99:   12113.150 ms/op
                 executeQuery·p0.999:  12113.150 ms/op
                 executeQuery·p0.9999: 12113.150 ms/op
                 executeQuery·p1.00:   12113.150 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =  12775.850 ±(99.9%) 1151.872 ms/op

  Histogram, ms/op:
    [11000.000, 11250.000) = 0 
    [11250.000, 11500.000) = 0 
    [11500.000, 11750.000) = 1 
    [11750.000, 12000.000) = 1 
    [12000.000, 12250.000) = 1 
    [12250.000, 12500.000) = 1 
    [12500.000, 12750.000) = 1 
    [12750.000, 13000.000) = 0 
    [13000.000, 13250.000) = 0 
    [13250.000, 13500.000) = 3 
    [13500.000, 13750.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =  11593.056 ms/op
     p(50.0000) =  12968.788 ms/op
     p(90.0000) =  13584.512 ms/op
     p(95.0000) =  13589.545 ms/op
     p(99.0000) =  13589.545 ms/op
     p(99.9000) =  13589.545 ms/op
     p(99.9900) =  13589.545 ms/op
     p(99.9990) =  13589.545 ms/op
     p(99.9999) =  13589.545 ms/op
    p(100.0000) =  13589.545 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144)

# Run progress: 27.22% complete, ETA 18:17:24
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

58720.256 ms/op
# Warmup Iteration   2: 53821.309 ms/op
# Warmup Iteration   3: 52412.023 ms/op
# Warmup Iteration   4: 50532.975 ms/op
# Warmup Iteration   5: 51002.737 ms/op
Iteration   1: 51405.390 ms/op
                 executeQuery·p0.00:   51405.390 ms/op
                 executeQuery·p0.50:   51405.390 ms/op
                 executeQuery·p0.90:   51405.390 ms/op
                 executeQuery·p0.95:   51405.390 ms/op
                 executeQuery·p0.99:   51405.390 ms/op
                 executeQuery·p0.999:  51405.390 ms/op
                 executeQuery·p0.9999: 51405.390 ms/op
                 executeQuery·p1.00:   51405.390 ms/op

Iteration   2: 50734.301 ms/op
                 executeQuery·p0.00:   50734.301 ms/op
                 executeQuery·p0.50:   50734.301 ms/op
                 executeQuery·p0.90:   50734.301 ms/op
                 executeQuery·p0.95:   50734.301 ms/op
                 executeQuery·p0.99:   50734.301 ms/op
                 executeQuery·p0.999:  50734.301 ms/op
                 executeQuery·p0.9999: 50734.301 ms/op
                 executeQuery·p1.00:   50734.301 ms/op

Iteration   3: 49861.886 ms/op
                 executeQuery·p0.00:   49861.886 ms/op
                 executeQuery·p0.50:   49861.886 ms/op
                 executeQuery·p0.90:   49861.886 ms/op
                 executeQuery·p0.95:   49861.886 ms/op
                 executeQuery·p0.99:   49861.886 ms/op
                 executeQuery·p0.999:  49861.886 ms/op
                 executeQuery·p0.9999: 49861.886 ms/op
                 executeQuery·p1.00:   49861.886 ms/op

Iteration   4: 51271.172 ms/op
                 executeQuery·p0.00:   51271.172 ms/op
                 executeQuery·p0.50:   51271.172 ms/op
                 executeQuery·p0.90:   51271.172 ms/op
                 executeQuery·p0.95:   51271.172 ms/op
                 executeQuery·p0.99:   51271.172 ms/op
                 executeQuery·p0.999:  51271.172 ms/op
                 executeQuery·p0.9999: 51271.172 ms/op
                 executeQuery·p1.00:   51271.172 ms/op

Iteration   5: 50331.648 ms/op
                 executeQuery·p0.00:   50331.648 ms/op
                 executeQuery·p0.50:   50331.648 ms/op
                 executeQuery·p0.90:   50331.648 ms/op
                 executeQuery·p0.95:   50331.648 ms/op
                 executeQuery·p0.99:   50331.648 ms/op
                 executeQuery·p0.999:  50331.648 ms/op
                 executeQuery·p0.9999: 50331.648 ms/op
                 executeQuery·p1.00:   50331.648 ms/op


# Run progress: 27.53% complete, ETA 18:26:52
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

51942.261 ms/op
# Warmup Iteration   2: 51942.261 ms/op
# Warmup Iteration   3: 43083.891 ms/op
# Warmup Iteration   4: 51136.954 ms/op
# Warmup Iteration   5: 51472.499 ms/op
Iteration   1: 49392.124 ms/op
                 executeQuery·p0.00:   49392.124 ms/op
                 executeQuery·p0.50:   49392.124 ms/op
                 executeQuery·p0.90:   49392.124 ms/op
                 executeQuery·p0.95:   49392.124 ms/op
                 executeQuery·p0.99:   49392.124 ms/op
                 executeQuery·p0.999:  49392.124 ms/op
                 executeQuery·p0.9999: 49392.124 ms/op
                 executeQuery·p1.00:   49392.124 ms/op

Iteration   2: 51136.954 ms/op
                 executeQuery·p0.00:   51136.954 ms/op
                 executeQuery·p0.50:   51136.954 ms/op
                 executeQuery·p0.90:   51136.954 ms/op
                 executeQuery·p0.95:   51136.954 ms/op
                 executeQuery·p0.99:   51136.954 ms/op
                 executeQuery·p0.999:  51136.954 ms/op
                 executeQuery·p0.9999: 51136.954 ms/op
                 executeQuery·p1.00:   51136.954 ms/op

Iteration   3: 48989.471 ms/op
                 executeQuery·p0.00:   48989.471 ms/op
                 executeQuery·p0.50:   48989.471 ms/op
                 executeQuery·p0.90:   48989.471 ms/op
                 executeQuery·p0.95:   48989.471 ms/op
                 executeQuery·p0.99:   48989.471 ms/op
                 executeQuery·p0.999:  48989.471 ms/op
                 executeQuery·p0.9999: 48989.471 ms/op
                 executeQuery·p1.00:   48989.471 ms/op

Iteration   4: 52009.370 ms/op
                 executeQuery·p0.00:   52009.370 ms/op
                 executeQuery·p0.50:   52009.370 ms/op
                 executeQuery·p0.90:   52009.370 ms/op
                 executeQuery·p0.95:   52009.370 ms/op
                 executeQuery·p0.99:   52009.370 ms/op
                 executeQuery·p0.999:  52009.370 ms/op
                 executeQuery·p0.9999: 52009.370 ms/op
                 executeQuery·p1.00:   52009.370 ms/op

Iteration   5: 48922.362 ms/op
                 executeQuery·p0.00:   48922.362 ms/op
                 executeQuery·p0.50:   48922.362 ms/op
                 executeQuery·p0.90:   48922.362 ms/op
                 executeQuery·p0.95:   48922.362 ms/op
                 executeQuery·p0.99:   48922.362 ms/op
                 executeQuery·p0.999:  48922.362 ms/op
                 executeQuery·p0.9999: 48922.362 ms/op
                 executeQuery·p1.00:   48922.362 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =  50405.468 ±(99.9%) 1632.793 ms/op

  Histogram, ms/op:
    [48000.000, 48500.000) = 0 
    [48500.000, 49000.000) = 2 
    [49000.000, 49500.000) = 1 
    [49500.000, 50000.000) = 1 
    [50000.000, 50500.000) = 1 
    [50500.000, 51000.000) = 1 
    [51000.000, 51500.000) = 3 
    [51500.000, 52000.000) = 0 
    [52000.000, 52500.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  48922.362 ms/op
     p(50.0000) =  50532.975 ms/op
     p(90.0000) =  51948.972 ms/op
     p(95.0000) =  52009.370 ms/op
     p(99.0000) =  52009.370 ms/op
     p(99.9000) =  52009.370 ms/op
     p(99.9900) =  52009.370 ms/op
     p(99.9990) =  52009.370 ms/op
     p(99.9999) =  52009.370 ms/op
    p(100.0000) =  52009.370 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288)

# Run progress: 27.85% complete, ETA 18:34:51
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

106166.223 ms/op
# Warmup Iteration   2: 108313.706 ms/op
# Warmup Iteration   3: 100663.296 ms/op
# Warmup Iteration   4: 101602.820 ms/op
# Warmup Iteration   5: 102273.909 ms/op
Iteration   1: 102542.344 ms/op
                 executeQuery·p0.00:   102542.344 ms/op
                 executeQuery·p0.50:   102542.344 ms/op
                 executeQuery·p0.90:   102542.344 ms/op
                 executeQuery·p0.95:   102542.344 ms/op
                 executeQuery·p0.99:   102542.344 ms/op
                 executeQuery·p0.999:  102542.344 ms/op
                 executeQuery·p0.9999: 102542.344 ms/op
                 executeQuery·p1.00:   102542.344 ms/op

Iteration   2: 102542.344 ms/op
                 executeQuery·p0.00:   102542.344 ms/op
                 executeQuery·p0.50:   102542.344 ms/op
                 executeQuery·p0.90:   102542.344 ms/op
                 executeQuery·p0.95:   102542.344 ms/op
                 executeQuery·p0.99:   102542.344 ms/op
                 executeQuery·p0.999:  102542.344 ms/op
                 executeQuery·p0.9999: 102542.344 ms/op
                 executeQuery·p1.00:   102542.344 ms/op

Iteration   3: 99589.554 ms/op
                 executeQuery·p0.00:   99589.554 ms/op
                 executeQuery·p0.50:   99589.554 ms/op
                 executeQuery·p0.90:   99589.554 ms/op
                 executeQuery·p0.95:   99589.554 ms/op
                 executeQuery·p0.99:   99589.554 ms/op
                 executeQuery·p0.999:  99589.554 ms/op
                 executeQuery·p0.9999: 99589.554 ms/op
                 executeQuery·p1.00:   99589.554 ms/op

Iteration   4: 99186.901 ms/op
                 executeQuery·p0.00:   99186.901 ms/op
                 executeQuery·p0.50:   99186.901 ms/op
                 executeQuery·p0.90:   99186.901 ms/op
                 executeQuery·p0.95:   99186.901 ms/op
                 executeQuery·p0.99:   99186.901 ms/op
                 executeQuery·p0.999:  99186.901 ms/op
                 executeQuery·p0.9999: 99186.901 ms/op
                 executeQuery·p1.00:   99186.901 ms/op

Iteration   5: 99589.554 ms/op
                 executeQuery·p0.00:   99589.554 ms/op
                 executeQuery·p0.50:   99589.554 ms/op
                 executeQuery·p0.90:   99589.554 ms/op
                 executeQuery·p0.95:   99589.554 ms/op
                 executeQuery·p0.99:   99589.554 ms/op
                 executeQuery·p0.999:  99589.554 ms/op
                 executeQuery·p0.9999: 99589.554 ms/op
                 executeQuery·p1.00:   99589.554 ms/op


# Run progress: 28.16% complete, ETA 19:16:13
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_1977928389 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_1977928389() {
        this(4);
    }
    public KeyValueMap_1977928389(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_1977928389 aggregation_state_map = new KeyValueMap_1977928389();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVector(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

99321.119 ms/op
# Warmup Iteration   2: 106166.223 ms/op
# Warmup Iteration   3: 98515.812 ms/op
# Warmup Iteration   4: 100529.078 ms/op
# Warmup Iteration   5: 103079.215 ms/op
Iteration   1: 101065.949 ms/op
                 executeQuery·p0.00:   101065.949 ms/op
                 executeQuery·p0.50:   101065.949 ms/op
                 executeQuery·p0.90:   101065.949 ms/op
                 executeQuery·p0.95:   101065.949 ms/op
                 executeQuery·p0.99:   101065.949 ms/op
                 executeQuery·p0.999:  101065.949 ms/op
                 executeQuery·p0.9999: 101065.949 ms/op
                 executeQuery·p1.00:   101065.949 ms/op

Iteration   2: 101065.949 ms/op
                 executeQuery·p0.00:   101065.949 ms/op
                 executeQuery·p0.50:   101065.949 ms/op
                 executeQuery·p0.90:   101065.949 ms/op
                 executeQuery·p0.95:   101065.949 ms/op
                 executeQuery·p0.99:   101065.949 ms/op
                 executeQuery·p0.999:  101065.949 ms/op
                 executeQuery·p0.9999: 101065.949 ms/op
                 executeQuery·p1.00:   101065.949 ms/op

Iteration   3: 103079.215 ms/op
                 executeQuery·p0.00:   103079.215 ms/op
                 executeQuery·p0.50:   103079.215 ms/op
                 executeQuery·p0.90:   103079.215 ms/op
                 executeQuery·p0.95:   103079.215 ms/op
                 executeQuery·p0.99:   103079.215 ms/op
                 executeQuery·p0.999:  103079.215 ms/op
                 executeQuery·p0.9999: 103079.215 ms/op
                 executeQuery·p1.00:   103079.215 ms/op

Iteration   4: 101334.385 ms/op
                 executeQuery·p0.00:   101334.385 ms/op
                 executeQuery·p0.50:   101334.385 ms/op
                 executeQuery·p0.90:   101334.385 ms/op
                 executeQuery·p0.95:   101334.385 ms/op
                 executeQuery·p0.99:   101334.385 ms/op
                 executeQuery·p0.999:  101334.385 ms/op
                 executeQuery·p0.9999: 101334.385 ms/op
                 executeQuery·p1.00:   101334.385 ms/op

Iteration   5: 100931.731 ms/op
                 executeQuery·p0.00:   100931.731 ms/op
                 executeQuery·p0.50:   100931.731 ms/op
                 executeQuery·p0.90:   100931.731 ms/op
                 executeQuery·p0.95:   100931.731 ms/op
                 executeQuery·p0.99:   100931.731 ms/op
                 executeQuery·p0.999:  100931.731 ms/op
                 executeQuery·p0.9999: 100931.731 ms/op
                 executeQuery·p1.00:   100931.731 ms/op



Result "benchmarks.aggregation_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean = 101092.793 ±(99.9%) 2039.974 ms/op

  Histogram, ms/op:
    [ 99000.000,  99500.000) = 1 
    [ 99500.000, 100000.000) = 2 
    [100000.000, 100500.000) = 0 
    [100500.000, 101000.000) = 1 
    [101000.000, 101500.000) = 3 
    [101500.000, 102000.000) = 0 
    [102000.000, 102500.000) = 0 
    [102500.000, 103000.000) = 2 
    [103000.000, 103500.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  99186.901 ms/op
     p(50.0000) = 101065.949 ms/op
     p(90.0000) = 103025.528 ms/op
     p(95.0000) = 103079.215 ms/op
     p(99.0000) = 103079.215 ms/op
     p(99.9000) = 103079.215 ms/op
     p(99.9900) = 103079.215 ms/op
     p(99.9990) = 103079.215 ms/op
     p(99.9999) = 103079.215 ms/op
    p(100.0000) = 103079.215 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2)

# Run progress: 28.48% complete, ETA 19:56:00
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

564.600 ±(99.9%) 136.040 ms/op
# Warmup Iteration   2: 517.865 ±(99.9%) 3.052 ms/op
# Warmup Iteration   3: 520.434 ±(99.9%) 3.895 ms/op
# Warmup Iteration   4: 521.667 ±(99.9%) 12.262 ms/op
# Warmup Iteration   5: 521.273 ±(99.9%) 7.434 ms/op
Iteration   1: 518.364 ±(99.9%) 1.845 ms/op
                 executeQuery·p0.00:   513.278 ms/op
                 executeQuery·p0.50:   518.521 ms/op
                 executeQuery·p0.90:   521.142 ms/op
                 executeQuery·p0.95:   522.138 ms/op
                 executeQuery·p0.99:   522.191 ms/op
                 executeQuery·p0.999:  522.191 ms/op
                 executeQuery·p0.9999: 522.191 ms/op
                 executeQuery·p1.00:   522.191 ms/op

Iteration   2: 517.236 ±(99.9%) 2.257 ms/op
                 executeQuery·p0.00:   513.278 ms/op
                 executeQuery·p0.50:   516.948 ms/op
                 executeQuery·p0.90:   521.090 ms/op
                 executeQuery·p0.95:   522.138 ms/op
                 executeQuery·p0.99:   522.191 ms/op
                 executeQuery·p0.999:  522.191 ms/op
                 executeQuery·p0.9999: 522.191 ms/op
                 executeQuery·p1.00:   522.191 ms/op

Iteration   3: 516.529 ±(99.9%) 2.055 ms/op
                 executeQuery·p0.00:   512.754 ms/op
                 executeQuery·p0.50:   516.162 ms/op
                 executeQuery·p0.90:   520.513 ms/op
                 executeQuery·p0.95:   521.116 ms/op
                 executeQuery·p0.99:   521.142 ms/op
                 executeQuery·p0.999:  521.142 ms/op
                 executeQuery·p0.9999: 521.142 ms/op
                 executeQuery·p1.00:   521.142 ms/op

Iteration   4: 517.027 ±(99.9%) 2.147 ms/op
                 executeQuery·p0.00:   511.705 ms/op
                 executeQuery·p0.50:   516.948 ms/op
                 executeQuery·p0.90:   520.618 ms/op
                 executeQuery·p0.95:   521.116 ms/op
                 executeQuery·p0.99:   521.142 ms/op
                 executeQuery·p0.999:  521.142 ms/op
                 executeQuery·p0.9999: 521.142 ms/op
                 executeQuery·p1.00:   521.142 ms/op

Iteration   5: 519.700 ±(99.9%) 10.685 ms/op
                 executeQuery·p0.00:   513.802 ms/op
                 executeQuery·p0.50:   516.948 ms/op
                 executeQuery·p0.90:   520.094 ms/op
                 executeQuery·p0.95:   568.905 ms/op
                 executeQuery·p0.99:   571.474 ms/op
                 executeQuery·p0.999:  571.474 ms/op
                 executeQuery·p0.9999: 571.474 ms/op
                 executeQuery·p1.00:   571.474 ms/op


# Run progress: 28.80% complete, ETA 19:41:58
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

530.993 ±(99.9%) 50.043 ms/op
# Warmup Iteration   2: 527.820 ±(99.9%) 15.593 ms/op
# Warmup Iteration   3: 522.663 ±(99.9%) 3.684 ms/op
# Warmup Iteration   4: 518.966 ±(99.9%) 10.710 ms/op
# Warmup Iteration   5: 516.162 ±(99.9%) 10.330 ms/op
Iteration   1: 512.308 ±(99.9%) 7.541 ms/op
                 executeQuery·p0.00:   499.646 ms/op
                 executeQuery·p0.50:   512.754 ms/op
                 executeQuery·p0.90:   524.707 ms/op
                 executeQuery·p0.95:   534.774 ms/op
                 executeQuery·p0.99:   535.298 ms/op
                 executeQuery·p0.999:  535.298 ms/op
                 executeQuery·p0.9999: 535.298 ms/op
                 executeQuery·p1.00:   535.298 ms/op

Iteration   2: 511.836 ±(99.9%) 4.216 ms/op
                 executeQuery·p0.00:   501.219 ms/op
                 executeQuery·p0.50:   511.967 ms/op
                 executeQuery·p0.90:   518.573 ms/op
                 executeQuery·p0.95:   523.528 ms/op
                 executeQuery·p0.99:   523.764 ms/op
                 executeQuery·p0.999:  523.764 ms/op
                 executeQuery·p0.9999: 523.764 ms/op
                 executeQuery·p1.00:   523.764 ms/op

Iteration   3: 512.675 ±(99.9%) 1.537 ms/op
                 executeQuery·p0.00:   509.608 ms/op
                 executeQuery·p0.50:   512.229 ms/op
                 executeQuery·p0.90:   514.851 ms/op
                 executeQuery·p0.95:   517.839 ms/op
                 executeQuery·p0.99:   517.997 ms/op
                 executeQuery·p0.999:  517.997 ms/op
                 executeQuery·p0.9999: 517.997 ms/op
                 executeQuery·p1.00:   517.997 ms/op

Iteration   4: 512.623 ±(99.9%) 0.885 ms/op
                 executeQuery·p0.00:   511.181 ms/op
                 executeQuery·p0.50:   512.754 ms/op
                 executeQuery·p0.90:   513.802 ms/op
                 executeQuery·p0.95:   513.802 ms/op
                 executeQuery·p0.99:   513.802 ms/op
                 executeQuery·p0.999:  513.802 ms/op
                 executeQuery·p0.9999: 513.802 ms/op
                 executeQuery·p1.00:   513.802 ms/op

Iteration   5: 511.862 ±(99.9%) 2.776 ms/op
                 executeQuery·p0.00:   502.792 ms/op
                 executeQuery·p0.50:   512.754 ms/op
                 executeQuery·p0.90:   515.165 ms/op
                 executeQuery·p0.95:   515.375 ms/op
                 executeQuery·p0.99:   515.375 ms/op
                 executeQuery·p0.999:  515.375 ms/op
                 executeQuery·p0.9999: 515.375 ms/op
                 executeQuery·p1.00:   515.375 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 200
  mean =    515.016 ±(99.9%) 1.414 ms/op

  Histogram, ms/op:
    [490.000, 495.000) = 0 
    [495.000, 500.000) = 1 
    [500.000, 505.000) = 8 
    [505.000, 510.000) = 4 
    [510.000, 515.000) = 96 
    [515.000, 520.000) = 70 
    [520.000, 525.000) = 19 
    [525.000, 530.000) = 0 
    [530.000, 535.000) = 0 
    [535.000, 540.000) = 1 
    [540.000, 545.000) = 0 
    [545.000, 550.000) = 0 
    [550.000, 555.000) = 0 
    [555.000, 560.000) = 0 
    [560.000, 565.000) = 0 
    [565.000, 570.000) = 0 
    [570.000, 575.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    499.646 ms/op
     p(50.0000) =    514.589 ms/op
     p(90.0000) =    520.094 ms/op
     p(95.0000) =    521.142 ms/op
     p(99.0000) =    535.193 ms/op
     p(99.9000) =    571.474 ms/op
     p(99.9900) =    571.474 ms/op
     p(99.9990) =    571.474 ms/op
     p(99.9999) =    571.474 ms/op
    p(100.0000) =    571.474 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16)

# Run progress: 29.11% complete, ETA 19:28:10
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

733.779 ±(99.9%) 90.594 ms/op
# Warmup Iteration   2: 704.503 ±(99.9%) 9.998 ms/op
# Warmup Iteration   3: 703.175 ±(99.9%) 4.676 ms/op
# Warmup Iteration   4: 701.707 ±(99.9%) 5.782 ms/op
# Warmup Iteration   5: 710.795 ±(99.9%) 5.082 ms/op
Iteration   1: 710.935 ±(99.9%) 5.856 ms/op
                 executeQuery·p0.00:   700.449 ms/op
                 executeQuery·p0.50:   709.886 ms/op
                 executeQuery·p0.90:   722.049 ms/op
                 executeQuery·p0.95:   724.566 ms/op
                 executeQuery·p0.99:   724.566 ms/op
                 executeQuery·p0.999:  724.566 ms/op
                 executeQuery·p0.9999: 724.566 ms/op
                 executeQuery·p1.00:   724.566 ms/op

Iteration   2: 713.481 ±(99.9%) 4.969 ms/op
                 executeQuery·p0.00:   708.837 ms/op
                 executeQuery·p0.50:   711.983 ms/op
                 executeQuery·p0.90:   721.945 ms/op
                 executeQuery·p0.95:   723.517 ms/op
                 executeQuery·p0.99:   723.517 ms/op
                 executeQuery·p0.999:  723.517 ms/op
                 executeQuery·p0.9999: 723.517 ms/op
                 executeQuery·p1.00:   723.517 ms/op

Iteration   3: 710.515 ±(99.9%) 2.990 ms/op
                 executeQuery·p0.00:   707.789 ms/op
                 executeQuery·p0.50:   709.886 ms/op
                 executeQuery·p0.90:   716.597 ms/op
                 executeQuery·p0.95:   717.226 ms/op
                 executeQuery·p0.99:   717.226 ms/op
                 executeQuery·p0.999:  717.226 ms/op
                 executeQuery·p0.9999: 717.226 ms/op
                 executeQuery·p1.00:   717.226 ms/op

Iteration   4: 705.482 ±(99.9%) 5.843 ms/op
                 executeQuery·p0.00:   699.400 ms/op
                 executeQuery·p0.50:   703.594 ms/op
                 executeQuery·p0.90:   713.871 ms/op
                 executeQuery·p0.95:   715.129 ms/op
                 executeQuery·p0.99:   715.129 ms/op
                 executeQuery·p0.999:  715.129 ms/op
                 executeQuery·p0.9999: 715.129 ms/op
                 executeQuery·p1.00:   715.129 ms/op

Iteration   5: 704.993 ±(99.9%) 12.623 ms/op
                 executeQuery·p0.00:   699.400 ms/op
                 executeQuery·p0.50:   701.497 ms/op
                 executeQuery·p0.90:   723.937 ms/op
                 executeQuery·p0.95:   746.586 ms/op
                 executeQuery·p0.99:   746.586 ms/op
                 executeQuery·p0.999:  746.586 ms/op
                 executeQuery·p0.9999: 746.586 ms/op
                 executeQuery·p1.00:   746.586 ms/op


# Run progress: 29.43% complete, ETA 19:14:43
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

729.060 ±(99.9%) 57.796 ms/op
# Warmup Iteration   2: 712.358 ±(99.9%) 1.891 ms/op
# Warmup Iteration   3: 712.657 ±(99.9%) 5.916 ms/op
# Warmup Iteration   4: 713.107 ±(99.9%) 4.057 ms/op
# Warmup Iteration   5: 706.041 ±(99.9%) 6.135 ms/op
Iteration   1: 725.615 ±(99.9%) 88.858 ms/op
                 executeQuery·p0.00:   700.449 ms/op
                 executeQuery·p0.50:   701.497 ms/op
                 executeQuery·p0.90:   850.815 ms/op
                 executeQuery·p0.95:   1024.459 ms/op
                 executeQuery·p0.99:   1024.459 ms/op
                 executeQuery·p0.999:  1024.459 ms/op
                 executeQuery·p0.9999: 1024.459 ms/op
                 executeQuery·p1.00:   1024.459 ms/op

Iteration   2: 705.202 ±(99.9%) 13.702 ms/op
                 executeQuery·p0.00:   699.400 ms/op
                 executeQuery·p0.50:   701.497 ms/op
                 executeQuery·p0.90:   728.341 ms/op
                 executeQuery·p0.95:   749.732 ms/op
                 executeQuery·p0.99:   749.732 ms/op
                 executeQuery·p0.999:  749.732 ms/op
                 executeQuery·p0.9999: 749.732 ms/op
                 executeQuery·p1.00:   749.732 ms/op

Iteration   3: 703.385 ±(99.9%) 8.613 ms/op
                 executeQuery·p0.00:   699.400 ms/op
                 executeQuery·p0.50:   701.497 ms/op
                 executeQuery·p0.90:   716.177 ms/op
                 executeQuery·p0.95:   731.906 ms/op
                 executeQuery·p0.99:   731.906 ms/op
                 executeQuery·p0.999:  731.906 ms/op
                 executeQuery·p0.9999: 731.906 ms/op
                 executeQuery·p1.00:   731.906 ms/op

Iteration   4: 703.525 ±(99.9%) 7.864 ms/op
                 executeQuery·p0.00:   700.449 ms/op
                 executeQuery·p0.50:   701.497 ms/op
                 executeQuery·p0.90:   714.080 ms/op
                 executeQuery·p0.95:   729.809 ms/op
                 executeQuery·p0.99:   729.809 ms/op
                 executeQuery·p0.999:  729.809 ms/op
                 executeQuery·p0.9999: 729.809 ms/op
                 executeQuery·p1.00:   729.809 ms/op

Iteration   5: 716.028 ±(99.9%) 18.782 ms/op
                 executeQuery·p0.00:   706.740 ms/op
                 executeQuery·p0.50:   709.886 ms/op
                 executeQuery·p0.90:   753.926 ms/op
                 executeQuery·p0.95:   764.412 ms/op
                 executeQuery·p0.99:   764.412 ms/op
                 executeQuery·p0.999:  764.412 ms/op
                 executeQuery·p0.9999: 764.412 ms/op
                 executeQuery·p1.00:   764.412 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 148
  mean =    709.851 ±(99.9%) 7.690 ms/op

  Histogram, ms/op:
    [ 600.000,  650.000) = 0 
    [ 650.000,  700.000) = 9 
    [ 700.000,  750.000) = 137 
    [ 750.000,  800.000) = 1 
    [ 800.000,  850.000) = 0 
    [ 850.000,  900.000) = 0 
    [ 900.000,  950.000) = 0 
    [ 950.000, 1000.000) = 0 
    [1000.000, 1050.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    699.400 ms/op
     p(50.0000) =    704.643 ms/op
     p(90.0000) =    716.282 ms/op
     p(95.0000) =    730.962 ms/op
     p(99.0000) =    897.036 ms/op
     p(99.9000) =   1024.459 ms/op
     p(99.9900) =   1024.459 ms/op
     p(99.9990) =   1024.459 ms/op
     p(99.9999) =   1024.459 ms/op
    p(100.0000) =   1024.459 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192)

# Run progress: 29.75% complete, ETA 19:01:27
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

1019.111 ±(99.9%) 127.356 ms/op
# Warmup Iteration   2: 964.785 ±(99.9%) 10.119 ms/op
# Warmup Iteration   3: 961.735 ±(99.9%) 20.782 ms/op
# Warmup Iteration   4: 960.210 ±(99.9%) 12.013 ms/op
# Warmup Iteration   5: 953.346 ±(99.9%) 27.468 ms/op
Iteration   1: 958.875 ±(99.9%) 15.325 ms/op
                 executeQuery·p0.00:   943.718 ms/op
                 executeQuery·p0.50:   963.641 ms/op
                 executeQuery·p0.90:   973.288 ms/op
                 executeQuery·p0.95:   974.127 ms/op
                 executeQuery·p0.99:   974.127 ms/op
                 executeQuery·p0.999:  974.127 ms/op
                 executeQuery·p0.9999: 974.127 ms/op
                 executeQuery·p1.00:   974.127 ms/op

Iteration   2: 953.251 ±(99.9%) 23.388 ms/op
                 executeQuery·p0.00:   925.893 ms/op
                 executeQuery·p0.50:   950.010 ms/op
                 executeQuery·p0.90:   971.820 ms/op
                 executeQuery·p0.95:   972.030 ms/op
                 executeQuery·p0.99:   972.030 ms/op
                 executeQuery·p0.999:  972.030 ms/op
                 executeQuery·p0.9999: 972.030 ms/op
                 executeQuery·p1.00:   972.030 ms/op

Iteration   3: 957.445 ±(99.9%) 24.339 ms/op
                 executeQuery·p0.00:   929.038 ms/op
                 executeQuery·p0.50:   963.641 ms/op
                 executeQuery·p0.90:   979.160 ms/op
                 executeQuery·p0.95:   979.370 ms/op
                 executeQuery·p0.99:   979.370 ms/op
                 executeQuery·p0.999:  979.370 ms/op
                 executeQuery·p0.9999: 979.370 ms/op
                 executeQuery·p1.00:   979.370 ms/op

Iteration   4: 962.593 ±(99.9%) 10.557 ms/op
                 executeQuery·p0.00:   947.913 ms/op
                 executeQuery·p0.50:   964.690 ms/op
                 executeQuery·p0.90:   969.723 ms/op
                 executeQuery·p0.95:   969.933 ms/op
                 executeQuery·p0.99:   969.933 ms/op
                 executeQuery·p0.999:  969.933 ms/op
                 executeQuery·p0.9999: 969.933 ms/op
                 executeQuery·p1.00:   969.933 ms/op

Iteration   5: 964.309 ±(99.9%) 9.382 ms/op
                 executeQuery·p0.00:   951.058 ms/op
                 executeQuery·p0.50:   965.738 ms/op
                 executeQuery·p0.90:   972.240 ms/op
                 executeQuery·p0.95:   973.079 ms/op
                 executeQuery·p0.99:   973.079 ms/op
                 executeQuery·p0.999:  973.079 ms/op
                 executeQuery·p0.9999: 973.079 ms/op
                 executeQuery·p1.00:   973.079 ms/op


# Run progress: 30.06% complete, ETA 18:48:32
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

1076.468 ±(99.9%) 102.495 ms/op
# Warmup Iteration   2: 972.983 ±(99.9%) 8.808 ms/op
# Warmup Iteration   3: 967.836 ±(99.9%) 8.530 ms/op
# Warmup Iteration   4: 957.827 ±(99.9%) 12.413 ms/op
# Warmup Iteration   5: 966.406 ±(99.9%) 15.515 ms/op
Iteration   1: 962.021 ±(99.9%) 15.242 ms/op
                 executeQuery·p0.00:   948.961 ms/op
                 executeQuery·p0.50:   958.398 ms/op
                 executeQuery·p0.90:   974.966 ms/op
                 executeQuery·p0.95:   975.176 ms/op
                 executeQuery·p0.99:   975.176 ms/op
                 executeQuery·p0.999:  975.176 ms/op
                 executeQuery·p0.9999: 975.176 ms/op
                 executeQuery·p1.00:   975.176 ms/op

Iteration   2: 959.733 ±(99.9%) 15.620 ms/op
                 executeQuery·p0.00:   946.864 ms/op
                 executeQuery·p0.50:   962.593 ms/op
                 executeQuery·p0.90:   980.628 ms/op
                 executeQuery·p0.95:   984.613 ms/op
                 executeQuery·p0.99:   984.613 ms/op
                 executeQuery·p0.999:  984.613 ms/op
                 executeQuery·p0.9999: 984.613 ms/op
                 executeQuery·p1.00:   984.613 ms/op

Iteration   3: 957.064 ±(99.9%) 11.657 ms/op
                 executeQuery·p0.00:   943.718 ms/op
                 executeQuery·p0.50:   962.593 ms/op
                 executeQuery·p0.90:   965.529 ms/op
                 executeQuery·p0.95:   965.738 ms/op
                 executeQuery·p0.99:   965.738 ms/op
                 executeQuery·p0.999:  965.738 ms/op
                 executeQuery·p0.9999: 965.738 ms/op
                 executeQuery·p1.00:   965.738 ms/op

Iteration   4: 955.539 ±(99.9%) 16.925 ms/op
                 executeQuery·p0.00:   923.795 ms/op
                 executeQuery·p0.50:   961.544 ms/op
                 executeQuery·p0.90:   966.997 ms/op
                 executeQuery·p0.95:   967.836 ms/op
                 executeQuery·p0.99:   967.836 ms/op
                 executeQuery·p0.999:  967.836 ms/op
                 executeQuery·p0.9999: 967.836 ms/op
                 executeQuery·p1.00:   967.836 ms/op

Iteration   5: 962.593 ±(99.9%) 3.669 ms/op
                 executeQuery·p0.00:   955.253 ms/op
                 executeQuery·p0.50:   963.641 ms/op
                 executeQuery·p0.90:   965.319 ms/op
                 executeQuery·p0.95:   965.738 ms/op
                 executeQuery·p0.99:   965.738 ms/op
                 executeQuery·p0.999:  965.738 ms/op
                 executeQuery·p0.9999: 965.738 ms/op
                 executeQuery·p1.00:   965.738 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 110
  mean =    959.342 ±(99.9%) 3.687 ms/op

  Histogram, ms/op:
    [920.000, 925.000) = 1 
    [925.000, 930.000) = 2 
    [930.000, 935.000) = 2 
    [935.000, 940.000) = 1 
    [940.000, 945.000) = 5 
    [945.000, 950.000) = 15 
    [950.000, 955.000) = 10 
    [955.000, 960.000) = 5 
    [960.000, 965.000) = 35 
    [965.000, 970.000) = 20 
    [970.000, 975.000) = 10 
    [975.000, 980.000) = 3 
    [980.000, 985.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    923.795 ms/op
     p(50.0000) =    963.117 ms/op
     p(90.0000) =    970.981 ms/op
     p(95.0000) =    974.127 ms/op
     p(99.0000) =    984.036 ms/op
     p(99.9000) =    984.613 ms/op
     p(99.9900) =    984.613 ms/op
     p(99.9990) =    984.613 ms/op
     p(99.9999) =    984.613 ms/op
    p(100.0000) =    984.613 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144)

# Run progress: 30.38% complete, ETA 18:35:53
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3082.813 ms/op
# Warmup Iteration   2: 2495.611 ms/op
# Warmup Iteration   3: 2613.051 ms/op
# Warmup Iteration   4: 2734.686 ms/op
# Warmup Iteration   5: 2894.070 ms/op
Iteration   1: 2541.748 ms/op
                 executeQuery·p0.00:   2541.748 ms/op
                 executeQuery·p0.50:   2541.748 ms/op
                 executeQuery·p0.90:   2541.748 ms/op
                 executeQuery·p0.95:   2541.748 ms/op
                 executeQuery·p0.99:   2541.748 ms/op
                 executeQuery·p0.999:  2541.748 ms/op
                 executeQuery·p0.9999: 2541.748 ms/op
                 executeQuery·p1.00:   2541.748 ms/op

Iteration   2: 2839.544 ms/op
                 executeQuery·p0.00:   2839.544 ms/op
                 executeQuery·p0.50:   2839.544 ms/op
                 executeQuery·p0.90:   2839.544 ms/op
                 executeQuery·p0.95:   2839.544 ms/op
                 executeQuery·p0.99:   2839.544 ms/op
                 executeQuery·p0.999:  2839.544 ms/op
                 executeQuery·p0.9999: 2839.544 ms/op
                 executeQuery·p1.00:   2839.544 ms/op

Iteration   3: 2634.023 ms/op
                 executeQuery·p0.00:   2634.023 ms/op
                 executeQuery·p0.50:   2634.023 ms/op
                 executeQuery·p0.90:   2634.023 ms/op
                 executeQuery·p0.95:   2634.023 ms/op
                 executeQuery·p0.99:   2634.023 ms/op
                 executeQuery·p0.999:  2634.023 ms/op
                 executeQuery·p0.9999: 2634.023 ms/op
                 executeQuery·p1.00:   2634.023 ms/op

Iteration   4: 2608.857 ms/op
                 executeQuery·p0.00:   2608.857 ms/op
                 executeQuery·p0.50:   2608.857 ms/op
                 executeQuery·p0.90:   2608.857 ms/op
                 executeQuery·p0.95:   2608.857 ms/op
                 executeQuery·p0.99:   2608.857 ms/op
                 executeQuery·p0.999:  2608.857 ms/op
                 executeQuery·p0.9999: 2608.857 ms/op
                 executeQuery·p1.00:   2608.857 ms/op

Iteration   5: 2671.772 ms/op
                 executeQuery·p0.00:   2671.772 ms/op
                 executeQuery·p0.50:   2671.772 ms/op
                 executeQuery·p0.90:   2671.772 ms/op
                 executeQuery·p0.95:   2671.772 ms/op
                 executeQuery·p0.99:   2671.772 ms/op
                 executeQuery·p0.999:  2671.772 ms/op
                 executeQuery·p0.9999: 2671.772 ms/op
                 executeQuery·p1.00:   2671.772 ms/op


# Run progress: 30.70% complete, ETA 18:24:43
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_2142740815 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_2142740815() {
        this(4);
    }
    public KeyValueMap_2142740815(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_2142740815 aggregation_state_map = new KeyValueMap_2142740815();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

3038.773 ms/op
# Warmup Iteration   2: 2835.350 ms/op
# Warmup Iteration   3: 2747.269 ms/op
# Warmup Iteration   4: 2772.435 ms/op
# Warmup Iteration   5: 2684.355 ms/op
Iteration   1: 2906.653 ms/op
                 executeQuery·p0.00:   2906.653 ms/op
                 executeQuery·p0.50:   2906.653 ms/op
                 executeQuery·p0.90:   2906.653 ms/op
                 executeQuery·p0.95:   2906.653 ms/op
                 executeQuery·p0.99:   2906.653 ms/op
                 executeQuery·p0.999:  2906.653 ms/op
                 executeQuery·p0.9999: 2906.653 ms/op
                 executeQuery·p1.00:   2906.653 ms/op

Iteration   2: 2642.412 ms/op
                 executeQuery·p0.00:   2642.412 ms/op
                 executeQuery·p0.50:   2642.412 ms/op
                 executeQuery·p0.90:   2642.412 ms/op
                 executeQuery·p0.95:   2642.412 ms/op
                 executeQuery·p0.99:   2642.412 ms/op
                 executeQuery·p0.999:  2642.412 ms/op
                 executeQuery·p0.9999: 2642.412 ms/op
                 executeQuery·p1.00:   2642.412 ms/op

Iteration   3: 2642.412 ms/op
                 executeQuery·p0.00:   2642.412 ms/op
                 executeQuery·p0.50:   2642.412 ms/op
                 executeQuery·p0.90:   2642.412 ms/op
                 executeQuery·p0.95:   2642.412 ms/op
                 executeQuery·p0.99:   2642.412 ms/op
                 executeQuery·p0.999:  2642.412 ms/op
                 executeQuery·p0.9999: 2642.412 ms/op
                 executeQuery·p1.00:   2642.412 ms/op

Iteration   4: 2709.520 ms/op
                 executeQuery·p0.00:   2709.520 ms/op
                 executeQuery·p0.50:   2709.520 ms/op
                 executeQuery·p0.90:   2709.520 ms/op
                 executeQuery·p0.95:   2709.520 ms/op
                 executeQuery·p0.99:   2709.520 ms/op
                 executeQuery·p0.999:  2709.520 ms/op
                 executeQuery·p0.9999: 2709.520 ms/op
                 executeQuery·p1.00:   2709.520 ms/op

Iteration   5: 2684.355 ms/op
                 executeQuery·p0.00:   2684.355 ms/op
                 executeQuery·p0.50:   2684.355 ms/op
                 executeQuery·p0.90:   2684.355 ms/op
                 executeQuery·p0.95:   2684.355 ms/op
                 executeQuery·p0.99:   2684.355 ms/op
                 executeQuery·p0.999:  2684.355 ms/op
                 executeQuery·p0.9999: 2684.355 ms/op
                 executeQuery·p1.00:   2684.355 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =   2688.129 ±(99.9%) 164.259 ms/op

  Histogram, ms/op:
    [2500.000, 2550.000) = 1 
    [2550.000, 2600.000) = 0 
    [2600.000, 2650.000) = 4 
    [2650.000, 2700.000) = 2 
    [2700.000, 2750.000) = 1 
    [2750.000, 2800.000) = 0 
    [2800.000, 2850.000) = 1 
    [2850.000, 2900.000) = 0 
    [2900.000, 2950.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2541.748 ms/op
     p(50.0000) =   2657.092 ms/op
     p(90.0000) =   2899.942 ms/op
     p(95.0000) =   2906.653 ms/op
     p(99.0000) =   2906.653 ms/op
     p(99.9000) =   2906.653 ms/op
     p(99.9900) =   2906.653 ms/op
     p(99.9990) =   2906.653 ms/op
     p(99.9999) =   2906.653 ms/op
    p(100.0000) =   2906.653 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288)

# Run progress: 31.01% complete, ETA 18:13:17
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5637.145 ms/op
# Warmup Iteration   2: 5301.600 ms/op
# Warmup Iteration   3: 5234.491 ms/op
# Warmup Iteration   4: 5142.217 ms/op
# Warmup Iteration   5: 4991.222 ms/op
Iteration   1: 5125.439 ms/op
                 executeQuery·p0.00:   5125.439 ms/op
                 executeQuery·p0.50:   5125.439 ms/op
                 executeQuery·p0.90:   5125.439 ms/op
                 executeQuery·p0.95:   5125.439 ms/op
                 executeQuery·p0.99:   5125.439 ms/op
                 executeQuery·p0.999:  5125.439 ms/op
                 executeQuery·p0.9999: 5125.439 ms/op
                 executeQuery·p1.00:   5125.439 ms/op

Iteration   2: 5217.714 ms/op
                 executeQuery·p0.00:   5217.714 ms/op
                 executeQuery·p0.50:   5217.714 ms/op
                 executeQuery·p0.90:   5217.714 ms/op
                 executeQuery·p0.95:   5217.714 ms/op
                 executeQuery·p0.99:   5217.714 ms/op
                 executeQuery·p0.999:  5217.714 ms/op
                 executeQuery·p0.9999: 5217.714 ms/op
                 executeQuery·p1.00:   5217.714 ms/op

Iteration   3: 4982.833 ms/op
                 executeQuery·p0.00:   4982.833 ms/op
                 executeQuery·p0.50:   4982.833 ms/op
                 executeQuery·p0.90:   4982.833 ms/op
                 executeQuery·p0.95:   4982.833 ms/op
                 executeQuery·p0.99:   4982.833 ms/op
                 executeQuery·p0.999:  4982.833 ms/op
                 executeQuery·p0.9999: 4982.833 ms/op
                 executeQuery·p1.00:   4982.833 ms/op

Iteration   4: 5200.937 ms/op
                 executeQuery·p0.00:   5200.937 ms/op
                 executeQuery·p0.50:   5200.937 ms/op
                 executeQuery·p0.90:   5200.937 ms/op
                 executeQuery·p0.95:   5200.937 ms/op
                 executeQuery·p0.99:   5200.937 ms/op
                 executeQuery·p0.999:  5200.937 ms/op
                 executeQuery·p0.9999: 5200.937 ms/op
                 executeQuery·p1.00:   5200.937 ms/op

Iteration   5: 5083.496 ms/op
                 executeQuery·p0.00:   5083.496 ms/op
                 executeQuery·p0.50:   5083.496 ms/op
                 executeQuery·p0.90:   5083.496 ms/op
                 executeQuery·p0.95:   5083.496 ms/op
                 executeQuery·p0.99:   5083.496 ms/op
                 executeQuery·p0.999:  5083.496 ms/op
                 executeQuery·p0.9999: 5083.496 ms/op
                 executeQuery·p1.00:   5083.496 ms/op


# Run progress: 31.33% complete, ETA 18:12:25
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

5519.704 ms/op
# Warmup Iteration   2: 5108.662 ms/op
# Warmup Iteration   3: 5150.605 ms/op
# Warmup Iteration   4: 5091.885 ms/op
# Warmup Iteration   5: 5058.331 ms/op
Iteration   1: 5326.766 ms/op
                 executeQuery·p0.00:   5326.766 ms/op
                 executeQuery·p0.50:   5326.766 ms/op
                 executeQuery·p0.90:   5326.766 ms/op
                 executeQuery·p0.95:   5326.766 ms/op
                 executeQuery·p0.99:   5326.766 ms/op
                 executeQuery·p0.999:  5326.766 ms/op
                 executeQuery·p0.9999: 5326.766 ms/op
                 executeQuery·p1.00:   5326.766 ms/op

Iteration   2: 5100.274 ms/op
                 executeQuery·p0.00:   5100.274 ms/op
                 executeQuery·p0.50:   5100.274 ms/op
                 executeQuery·p0.90:   5100.274 ms/op
                 executeQuery·p0.95:   5100.274 ms/op
                 executeQuery·p0.99:   5100.274 ms/op
                 executeQuery·p0.999:  5100.274 ms/op
                 executeQuery·p0.9999: 5100.274 ms/op
                 executeQuery·p1.00:   5100.274 ms/op

Iteration   3: 5058.331 ms/op
                 executeQuery·p0.00:   5058.331 ms/op
                 executeQuery·p0.50:   5058.331 ms/op
                 executeQuery·p0.90:   5058.331 ms/op
                 executeQuery·p0.95:   5058.331 ms/op
                 executeQuery·p0.99:   5058.331 ms/op
                 executeQuery·p0.999:  5058.331 ms/op
                 executeQuery·p0.9999: 5058.331 ms/op
                 executeQuery·p1.00:   5058.331 ms/op

Iteration   4: 5326.766 ms/op
                 executeQuery·p0.00:   5326.766 ms/op
                 executeQuery·p0.50:   5326.766 ms/op
                 executeQuery·p0.90:   5326.766 ms/op
                 executeQuery·p0.95:   5326.766 ms/op
                 executeQuery·p0.99:   5326.766 ms/op
                 executeQuery·p0.999:  5326.766 ms/op
                 executeQuery·p0.9999: 5326.766 ms/op
                 executeQuery·p1.00:   5326.766 ms/op

Iteration   5: 5016.388 ms/op
                 executeQuery·p0.00:   5016.388 ms/op
                 executeQuery·p0.50:   5016.388 ms/op
                 executeQuery·p0.90:   5016.388 ms/op
                 executeQuery·p0.95:   5016.388 ms/op
                 executeQuery·p0.99:   5016.388 ms/op
                 executeQuery·p0.999:  5016.388 ms/op
                 executeQuery·p0.9999: 5016.388 ms/op
                 executeQuery·p1.00:   5016.388 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =   5143.894 ±(99.9%) 182.399 ms/op

  Histogram, ms/op:
    [4900.000, 4950.000) = 0 
    [4950.000, 5000.000) = 1 
    [5000.000, 5050.000) = 1 
    [5050.000, 5100.000) = 2 
    [5100.000, 5150.000) = 2 
    [5150.000, 5200.000) = 0 
    [5200.000, 5250.000) = 2 
    [5250.000, 5300.000) = 0 
    [5300.000, 5350.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =   4982.833 ms/op
     p(50.0000) =   5112.857 ms/op
     p(90.0000) =   5326.766 ms/op
     p(95.0000) =   5326.766 ms/op
     p(99.0000) =   5326.766 ms/op
     p(99.9000) =   5326.766 ms/op
     p(99.9900) =   5326.766 ms/op
     p(99.9990) =   5326.766 ms/op
     p(99.9999) =   5326.766 ms/op
    p(100.0000) =   5326.766 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2)

# Run progress: 31.65% complete, ETA 18:11:25
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

7583.302 ms/op
# Warmup Iteration   2: 5085.594 ms/op
# Warmup Iteration   3: 5305.795 ms/op
# Warmup Iteration   4: 5146.411 ms/op
# Warmup Iteration   5: 5171.577 ms/op
Iteration   1: 5188.354 ms/op
                 executeQuery·p0.00:   5184.160 ms/op
                 executeQuery·p0.50:   5188.354 ms/op
                 executeQuery·p0.90:   5192.548 ms/op
                 executeQuery·p0.95:   5192.548 ms/op
                 executeQuery·p0.99:   5192.548 ms/op
                 executeQuery·p0.999:  5192.548 ms/op
                 executeQuery·p0.9999: 5192.548 ms/op
                 executeQuery·p1.00:   5192.548 ms/op

Iteration   2: 5297.406 ms/op
                 executeQuery·p0.00:   5100.274 ms/op
                 executeQuery·p0.50:   5297.406 ms/op
                 executeQuery·p0.90:   5494.538 ms/op
                 executeQuery·p0.95:   5494.538 ms/op
                 executeQuery·p0.99:   5494.538 ms/op
                 executeQuery·p0.999:  5494.538 ms/op
                 executeQuery·p0.9999: 5494.538 ms/op
                 executeQuery·p1.00:   5494.538 ms/op

Iteration   3: 5154.800 ms/op
                 executeQuery·p0.00:   5125.439 ms/op
                 executeQuery·p0.50:   5154.800 ms/op
                 executeQuery·p0.90:   5184.160 ms/op
                 executeQuery·p0.95:   5184.160 ms/op
                 executeQuery·p0.99:   5184.160 ms/op
                 executeQuery·p0.999:  5184.160 ms/op
                 executeQuery·p0.9999: 5184.160 ms/op
                 executeQuery·p1.00:   5184.160 ms/op

Iteration   4: 5276.434 ms/op
                 executeQuery·p0.00:   5251.269 ms/op
                 executeQuery·p0.50:   5276.434 ms/op
                 executeQuery·p0.90:   5301.600 ms/op
                 executeQuery·p0.95:   5301.600 ms/op
                 executeQuery·p0.99:   5301.600 ms/op
                 executeQuery·p0.999:  5301.600 ms/op
                 executeQuery·p0.9999: 5301.600 ms/op
                 executeQuery·p1.00:   5301.600 ms/op

Iteration   5: 5091.885 ms/op
                 executeQuery·p0.00:   5083.496 ms/op
                 executeQuery·p0.50:   5091.885 ms/op
                 executeQuery·p0.90:   5100.274 ms/op
                 executeQuery·p0.95:   5100.274 ms/op
                 executeQuery·p0.99:   5100.274 ms/op
                 executeQuery·p0.999:  5100.274 ms/op
                 executeQuery·p0.9999: 5100.274 ms/op
                 executeQuery·p1.00:   5100.274 ms/op


# Run progress: 31.96% complete, ETA 17:59:31
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

4095.039 ±(99.9%) 26981.892 ms/op
# Warmup Iteration   2: 5393.875 ms/op
# Warmup Iteration   3: 5209.326 ms/op
# Warmup Iteration   4: 5104.468 ms/op
# Warmup Iteration   5: 5104.468 ms/op
Iteration   1: 5196.743 ms/op
                 executeQuery·p0.00:   5108.662 ms/op
                 executeQuery·p0.50:   5196.743 ms/op
                 executeQuery·p0.90:   5284.823 ms/op
                 executeQuery·p0.95:   5284.823 ms/op
                 executeQuery·p0.99:   5284.823 ms/op
                 executeQuery·p0.999:  5284.823 ms/op
                 executeQuery·p0.9999: 5284.823 ms/op
                 executeQuery·p1.00:   5284.823 ms/op

Iteration   2: 5104.468 ms/op
                 executeQuery·p0.00:   5100.274 ms/op
                 executeQuery·p0.50:   5104.468 ms/op
                 executeQuery·p0.90:   5108.662 ms/op
                 executeQuery·p0.95:   5108.662 ms/op
                 executeQuery·p0.99:   5108.662 ms/op
                 executeQuery·p0.999:  5108.662 ms/op
                 executeQuery·p0.9999: 5108.662 ms/op
                 executeQuery·p1.00:   5108.662 ms/op

Iteration   3: 5104.468 ms/op
                 executeQuery·p0.00:   5100.274 ms/op
                 executeQuery·p0.50:   5104.468 ms/op
                 executeQuery·p0.90:   5108.662 ms/op
                 executeQuery·p0.95:   5108.662 ms/op
                 executeQuery·p0.99:   5108.662 ms/op
                 executeQuery·p0.999:  5108.662 ms/op
                 executeQuery·p0.9999: 5108.662 ms/op
                 executeQuery·p1.00:   5108.662 ms/op

Iteration   4: 5104.468 ms/op
                 executeQuery·p0.00:   5100.274 ms/op
                 executeQuery·p0.50:   5104.468 ms/op
                 executeQuery·p0.90:   5108.662 ms/op
                 executeQuery·p0.95:   5108.662 ms/op
                 executeQuery·p0.99:   5108.662 ms/op
                 executeQuery·p0.999:  5108.662 ms/op
                 executeQuery·p0.9999: 5108.662 ms/op
                 executeQuery·p1.00:   5108.662 ms/op

Iteration   5: 5104.468 ms/op
                 executeQuery·p0.00:   5100.274 ms/op
                 executeQuery·p0.50:   5104.468 ms/op
                 executeQuery·p0.90:   5108.662 ms/op
                 executeQuery·p0.95:   5108.662 ms/op
                 executeQuery·p0.99:   5108.662 ms/op
                 executeQuery·p0.999:  5108.662 ms/op
                 executeQuery·p0.9999: 5108.662 ms/op
                 executeQuery·p1.00:   5108.662 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 20
  mean =   5162.349 ±(99.9%) 89.007 ms/op

  Histogram, ms/op:
    [5000.000, 5050.000) = 0 
    [5050.000, 5100.000) = 1 
    [5100.000, 5150.000) = 12 
    [5150.000, 5200.000) = 3 
    [5200.000, 5250.000) = 0 
    [5250.000, 5300.000) = 2 
    [5300.000, 5350.000) = 1 
    [5350.000, 5400.000) = 0 
    [5400.000, 5450.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   5083.496 ms/op
     p(50.0000) =   5108.662 ms/op
     p(90.0000) =   5299.923 ms/op
     p(95.0000) =   5484.891 ms/op
     p(99.0000) =   5494.538 ms/op
     p(99.9000) =   5494.538 ms/op
     p(99.9900) =   5494.538 ms/op
     p(99.9990) =   5494.538 ms/op
     p(99.9999) =   5494.538 ms/op
    p(100.0000) =   5494.538 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16)

# Run progress: 32.28% complete, ETA 17:47:42
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_2142740815 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_2142740815() {
        this(4);
    }
    public KeyValueMap_2142740815(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_2142740815 aggregation_state_map = new KeyValueMap_2142740815();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

8111.784 ms/op
# Warmup Iteration   2: 6685.721 ms/op
# Warmup Iteration   3: 10418.651 ms/op
# Warmup Iteration   4: 6647.972 ms/op
# Warmup Iteration   5: 6455.034 ms/op
Iteration   1: 6463.422 ms/op
                 executeQuery·p0.00:   6450.840 ms/op
                 executeQuery·p0.50:   6463.422 ms/op
                 executeQuery·p0.90:   6476.005 ms/op
                 executeQuery·p0.95:   6476.005 ms/op
                 executeQuery·p0.99:   6476.005 ms/op
                 executeQuery·p0.999:  6476.005 ms/op
                 executeQuery·p0.9999: 6476.005 ms/op
                 executeQuery·p1.00:   6476.005 ms/op

Iteration   2: 6463.422 ms/op
                 executeQuery·p0.00:   6459.228 ms/op
                 executeQuery·p0.50:   6463.422 ms/op
                 executeQuery·p0.90:   6467.617 ms/op
                 executeQuery·p0.95:   6467.617 ms/op
                 executeQuery·p0.99:   6467.617 ms/op
                 executeQuery·p0.999:  6467.617 ms/op
                 executeQuery·p0.9999: 6467.617 ms/op
                 executeQuery·p1.00:   6467.617 ms/op

Iteration   3: 6480.200 ms/op
                 executeQuery·p0.00:   6442.451 ms/op
                 executeQuery·p0.50:   6480.200 ms/op
                 executeQuery·p0.90:   6517.948 ms/op
                 executeQuery·p0.95:   6517.948 ms/op
                 executeQuery·p0.99:   6517.948 ms/op
                 executeQuery·p0.999:  6517.948 ms/op
                 executeQuery·p0.9999: 6517.948 ms/op
                 executeQuery·p1.00:   6517.948 ms/op

Iteration   4: 6463.422 ms/op
                 executeQuery·p0.00:   6459.228 ms/op
                 executeQuery·p0.50:   6463.422 ms/op
                 executeQuery·p0.90:   6467.617 ms/op
                 executeQuery·p0.95:   6467.617 ms/op
                 executeQuery·p0.99:   6467.617 ms/op
                 executeQuery·p0.999:  6467.617 ms/op
                 executeQuery·p0.9999: 6467.617 ms/op
                 executeQuery·p1.00:   6467.617 ms/op

Iteration   5: 6463.422 ms/op
                 executeQuery·p0.00:   6459.228 ms/op
                 executeQuery·p0.50:   6463.422 ms/op
                 executeQuery·p0.90:   6467.617 ms/op
                 executeQuery·p0.95:   6467.617 ms/op
                 executeQuery·p0.99:   6467.617 ms/op
                 executeQuery·p0.999:  6467.617 ms/op
                 executeQuery·p0.9999: 6467.617 ms/op
                 executeQuery·p1.00:   6467.617 ms/op


# Run progress: 32.59% complete, ETA 17:36:58
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

6777.995 ms/op
# Warmup Iteration   2: 6572.474 ms/op
# Warmup Iteration   3: 6958.350 ms/op
# Warmup Iteration   4: 6966.739 ms/op
# Warmup Iteration   5: 6928.990 ms/op
Iteration   1: 6937.379 ms/op
                 executeQuery·p0.00:   6928.990 ms/op
                 executeQuery·p0.50:   6937.379 ms/op
                 executeQuery·p0.90:   6945.767 ms/op
                 executeQuery·p0.95:   6945.767 ms/op
                 executeQuery·p0.99:   6945.767 ms/op
                 executeQuery·p0.999:  6945.767 ms/op
                 executeQuery·p0.9999: 6945.767 ms/op
                 executeQuery·p1.00:   6945.767 ms/op

Iteration   2: 6954.156 ms/op
                 executeQuery·p0.00:   6945.767 ms/op
                 executeQuery·p0.50:   6954.156 ms/op
                 executeQuery·p0.90:   6962.545 ms/op
                 executeQuery·p0.95:   6962.545 ms/op
                 executeQuery·p0.99:   6962.545 ms/op
                 executeQuery·p0.999:  6962.545 ms/op
                 executeQuery·p0.9999: 6962.545 ms/op
                 executeQuery·p1.00:   6962.545 ms/op

Iteration   3: 7067.402 ms/op
                 executeQuery·p0.00:   6962.545 ms/op
                 executeQuery·p0.50:   7067.402 ms/op
                 executeQuery·p0.90:   7172.260 ms/op
                 executeQuery·p0.95:   7172.260 ms/op
                 executeQuery·p0.99:   7172.260 ms/op
                 executeQuery·p0.999:  7172.260 ms/op
                 executeQuery·p0.9999: 7172.260 ms/op
                 executeQuery·p1.00:   7172.260 ms/op

Iteration   4: 7130.317 ms/op
                 executeQuery·p0.00:   6945.767 ms/op
                 executeQuery·p0.50:   7130.317 ms/op
                 executeQuery·p0.90:   7314.866 ms/op
                 executeQuery·p0.95:   7314.866 ms/op
                 executeQuery·p0.99:   7314.866 ms/op
                 executeQuery·p0.999:  7314.866 ms/op
                 executeQuery·p0.9999: 7314.866 ms/op
                 executeQuery·p1.00:   7314.866 ms/op

Iteration   5: 6966.739 ms/op
                 executeQuery·p0.00:   6954.156 ms/op
                 executeQuery·p0.50:   6966.739 ms/op
                 executeQuery·p0.90:   6979.322 ms/op
                 executeQuery·p0.95:   6979.322 ms/op
                 executeQuery·p0.99:   6979.322 ms/op
                 executeQuery·p0.999:  6979.322 ms/op
                 executeQuery·p0.9999: 6979.322 ms/op
                 executeQuery·p1.00:   6979.322 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 20
  mean =   6738.988 ±(99.9%) 254.531 ms/op

  Histogram, ms/op:
    [6400.000, 6500.000) = 9 
    [6500.000, 6600.000) = 1 
    [6600.000, 6700.000) = 0 
    [6700.000, 6800.000) = 0 
    [6800.000, 6900.000) = 0 
    [6900.000, 7000.000) = 8 
    [7000.000, 7100.000) = 0 
    [7100.000, 7200.000) = 1 
    [7200.000, 7300.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   6442.451 ms/op
     p(50.0000) =   6723.469 ms/op
     p(90.0000) =   7152.966 ms/op
     p(95.0000) =   7307.736 ms/op
     p(99.0000) =   7314.866 ms/op
     p(99.9000) =   7314.866 ms/op
     p(99.9900) =   7314.866 ms/op
     p(99.9990) =   7314.866 ms/op
     p(99.9999) =   7314.866 ms/op
    p(100.0000) =   7314.866 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192)

# Run progress: 32.91% complete, ETA 17:26:39
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

11291.066 ms/op
# Warmup Iteration   2: 9663.676 ms/op
# Warmup Iteration   3: 10250.879 ms/op
# Warmup Iteration   4: 9453.961 ms/op
# Warmup Iteration   5: 9219.080 ms/op
Iteration   1: 9563.013 ms/op
                 executeQuery·p0.00:   9512.681 ms/op
                 executeQuery·p0.50:   9563.013 ms/op
                 executeQuery·p0.90:   9613.345 ms/op
                 executeQuery·p0.95:   9613.345 ms/op
                 executeQuery·p0.99:   9613.345 ms/op
                 executeQuery·p0.999:  9613.345 ms/op
                 executeQuery·p0.9999: 9613.345 ms/op
                 executeQuery·p1.00:   9613.345 ms/op

Iteration   2: 9437.184 ms/op
                 executeQuery·p0.00:   9277.800 ms/op
                 executeQuery·p0.50:   9437.184 ms/op
                 executeQuery·p0.90:   9596.568 ms/op
                 executeQuery·p0.95:   9596.568 ms/op
                 executeQuery·p0.99:   9596.568 ms/op
                 executeQuery·p0.999:  9596.568 ms/op
                 executeQuery·p0.9999: 9596.568 ms/op
                 executeQuery·p1.00:   9596.568 ms/op

Iteration   3: 9395.241 ms/op
                 executeQuery·p0.00:   9177.137 ms/op
                 executeQuery·p0.50:   9395.241 ms/op
                 executeQuery·p0.90:   9613.345 ms/op
                 executeQuery·p0.95:   9613.345 ms/op
                 executeQuery·p0.99:   9613.345 ms/op
                 executeQuery·p0.999:  9613.345 ms/op
                 executeQuery·p0.9999: 9613.345 ms/op
                 executeQuery·p1.00:   9613.345 ms/op

Iteration   4: 9613.345 ms/op
                 executeQuery·p0.00:   9613.345 ms/op
                 executeQuery·p0.50:   9613.345 ms/op
                 executeQuery·p0.90:   9613.345 ms/op
                 executeQuery·p0.95:   9613.345 ms/op
                 executeQuery·p0.99:   9613.345 ms/op
                 executeQuery·p0.999:  9613.345 ms/op
                 executeQuery·p0.9999: 9613.345 ms/op
                 executeQuery·p1.00:   9613.345 ms/op

Iteration   5: 9613.345 ms/op
                 executeQuery·p0.00:   9613.345 ms/op
                 executeQuery·p0.50:   9613.345 ms/op
                 executeQuery·p0.90:   9613.345 ms/op
                 executeQuery·p0.95:   9613.345 ms/op
                 executeQuery·p0.99:   9613.345 ms/op
                 executeQuery·p0.999:  9613.345 ms/op
                 executeQuery·p0.9999: 9613.345 ms/op
                 executeQuery·p1.00:   9613.345 ms/op


# Run progress: 33.23% complete, ETA 17:17:41
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

10628.366 ms/op
# Warmup Iteration   2: 10334.765 ms/op
# Warmup Iteration   3: 10921.968 ms/op
# Warmup Iteration   4: 10435.428 ms/op
# Warmup Iteration   5: 10150.216 ms/op
Iteration   1: 10921.968 ms/op
                 executeQuery·p0.00:   10921.968 ms/op
                 executeQuery·p0.50:   10921.968 ms/op
                 executeQuery·p0.90:   10921.968 ms/op
                 executeQuery·p0.95:   10921.968 ms/op
                 executeQuery·p0.99:   10921.968 ms/op
                 executeQuery·p0.999:  10921.968 ms/op
                 executeQuery·p0.9999: 10921.968 ms/op
                 executeQuery·p1.00:   10921.968 ms/op

Iteration   2: 10921.968 ms/op
                 executeQuery·p0.00:   10921.968 ms/op
                 executeQuery·p0.50:   10921.968 ms/op
                 executeQuery·p0.90:   10921.968 ms/op
                 executeQuery·p0.95:   10921.968 ms/op
                 executeQuery·p0.99:   10921.968 ms/op
                 executeQuery·p0.999:  10921.968 ms/op
                 executeQuery·p0.9999: 10921.968 ms/op
                 executeQuery·p1.00:   10921.968 ms/op

Iteration   3: 10921.968 ms/op
                 executeQuery·p0.00:   10921.968 ms/op
                 executeQuery·p0.50:   10921.968 ms/op
                 executeQuery·p0.90:   10921.968 ms/op
                 executeQuery·p0.95:   10921.968 ms/op
                 executeQuery·p0.99:   10921.968 ms/op
                 executeQuery·p0.999:  10921.968 ms/op
                 executeQuery·p0.9999: 10921.968 ms/op
                 executeQuery·p1.00:   10921.968 ms/op

Iteration   4: 8816.427 ms/op
                 executeQuery·p0.00:   8774.484 ms/op
                 executeQuery·p0.50:   8816.427 ms/op
                 executeQuery·p0.90:   8858.370 ms/op
                 executeQuery·p0.95:   8858.370 ms/op
                 executeQuery·p0.99:   8858.370 ms/op
                 executeQuery·p0.999:  8858.370 ms/op
                 executeQuery·p0.9999: 8858.370 ms/op
                 executeQuery·p1.00:   8858.370 ms/op

Iteration   5: 8610.906 ms/op
                 executeQuery·p0.00:   8363.442 ms/op
                 executeQuery·p0.50:   8610.906 ms/op
                 executeQuery·p0.90:   8858.370 ms/op
                 executeQuery·p0.95:   8858.370 ms/op
                 executeQuery·p0.99:   8858.370 ms/op
                 executeQuery·p0.999:  8858.370 ms/op
                 executeQuery·p0.9999: 8858.370 ms/op
                 executeQuery·p1.00:   8858.370 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 17
  mean =   9580.284 ±(99.9%) 723.736 ms/op

  Histogram, ms/op:
    [ 8000.000,  8250.000) = 0 
    [ 8250.000,  8500.000) = 1 
    [ 8500.000,  8750.000) = 0 
    [ 8750.000,  9000.000) = 3 
    [ 9000.000,  9250.000) = 1 
    [ 9250.000,  9500.000) = 1 
    [ 9500.000,  9750.000) = 8 
    [ 9750.000, 10000.000) = 0 
    [10000.000, 10250.000) = 0 
    [10250.000, 10500.000) = 0 
    [10500.000, 10750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   8363.442 ms/op
     p(50.0000) =   9613.345 ms/op
     p(90.0000) =  10921.968 ms/op
     p(95.0000) =  10921.968 ms/op
     p(99.0000) =  10921.968 ms/op
     p(99.9000) =  10921.968 ms/op
     p(99.9900) =  10921.968 ms/op
     p(99.9990) =  10921.968 ms/op
     p(99.9999) =  10921.968 ms/op
    p(100.0000) =  10921.968 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144)

# Run progress: 33.54% complete, ETA 17:07:45
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_2142740815 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_2142740815() {
        this(4);
    }
    public KeyValueMap_2142740815(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_2142740815 aggregation_state_map = new KeyValueMap_2142740815();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

30433.870 ms/op
# Warmup Iteration   2: 25971.130 ms/op
# Warmup Iteration   3: 26642.219 ms/op
# Warmup Iteration   4: 26038.239 ms/op
# Warmup Iteration   5: 26004.685 ms/op
Iteration   1: 26004.685 ms/op
                 executeQuery·p0.00:   26004.685 ms/op
                 executeQuery·p0.50:   26004.685 ms/op
                 executeQuery·p0.90:   26004.685 ms/op
                 executeQuery·p0.95:   26004.685 ms/op
                 executeQuery·p0.99:   26004.685 ms/op
                 executeQuery·p0.999:  26004.685 ms/op
                 executeQuery·p0.9999: 26004.685 ms/op
                 executeQuery·p1.00:   26004.685 ms/op

Iteration   2: 25971.130 ms/op
                 executeQuery·p0.00:   25971.130 ms/op
                 executeQuery·p0.50:   25971.130 ms/op
                 executeQuery·p0.90:   25971.130 ms/op
                 executeQuery·p0.95:   25971.130 ms/op
                 executeQuery·p0.99:   25971.130 ms/op
                 executeQuery·p0.999:  25971.130 ms/op
                 executeQuery·p0.9999: 25971.130 ms/op
                 executeQuery·p1.00:   25971.130 ms/op

Iteration   3: 25534.923 ms/op
                 executeQuery·p0.00:   25534.923 ms/op
                 executeQuery·p0.50:   25534.923 ms/op
                 executeQuery·p0.90:   25534.923 ms/op
                 executeQuery·p0.95:   25534.923 ms/op
                 executeQuery·p0.99:   25534.923 ms/op
                 executeQuery·p0.999:  25534.923 ms/op
                 executeQuery·p0.9999: 25534.923 ms/op
                 executeQuery·p1.00:   25534.923 ms/op

Iteration   4: 25266.487 ms/op
                 executeQuery·p0.00:   25266.487 ms/op
                 executeQuery·p0.50:   25266.487 ms/op
                 executeQuery·p0.90:   25266.487 ms/op
                 executeQuery·p0.95:   25266.487 ms/op
                 executeQuery·p0.99:   25266.487 ms/op
                 executeQuery·p0.999:  25266.487 ms/op
                 executeQuery·p0.9999: 25266.487 ms/op
                 executeQuery·p1.00:   25266.487 ms/op

Iteration   5: 26172.457 ms/op
                 executeQuery·p0.00:   26172.457 ms/op
                 executeQuery·p0.50:   26172.457 ms/op
                 executeQuery·p0.90:   26172.457 ms/op
                 executeQuery·p0.95:   26172.457 ms/op
                 executeQuery·p0.99:   26172.457 ms/op
                 executeQuery·p0.999:  26172.457 ms/op
                 executeQuery·p0.9999: 26172.457 ms/op
                 executeQuery·p1.00:   26172.457 ms/op


# Run progress: 33.86% complete, ETA 17:04:47
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

27212.644 ms/op
# Warmup Iteration   2: 26373.784 ms/op
# Warmup Iteration   3: 25870.467 ms/op
# Warmup Iteration   4: 27145.535 ms/op
# Warmup Iteration   5: 26373.784 ms/op
Iteration   1: 22246.588 ms/op
                 executeQuery·p0.00:   22246.588 ms/op
                 executeQuery·p0.50:   22246.588 ms/op
                 executeQuery·p0.90:   22246.588 ms/op
                 executeQuery·p0.95:   22246.588 ms/op
                 executeQuery·p0.99:   22246.588 ms/op
                 executeQuery·p0.999:  22246.588 ms/op
                 executeQuery·p0.9999: 22246.588 ms/op
                 executeQuery·p1.00:   22246.588 ms/op

Iteration   2: 25803.358 ms/op
                 executeQuery·p0.00:   25803.358 ms/op
                 executeQuery·p0.50:   25803.358 ms/op
                 executeQuery·p0.90:   25803.358 ms/op
                 executeQuery·p0.95:   25803.358 ms/op
                 executeQuery·p0.99:   25803.358 ms/op
                 executeQuery·p0.999:  25803.358 ms/op
                 executeQuery·p0.9999: 25803.358 ms/op
                 executeQuery·p1.00:   25803.358 ms/op

Iteration   3: 25602.032 ms/op
                 executeQuery·p0.00:   25602.032 ms/op
                 executeQuery·p0.50:   25602.032 ms/op
                 executeQuery·p0.90:   25602.032 ms/op
                 executeQuery·p0.95:   25602.032 ms/op
                 executeQuery·p0.99:   25602.032 ms/op
                 executeQuery·p0.999:  25602.032 ms/op
                 executeQuery·p0.9999: 25602.032 ms/op
                 executeQuery·p1.00:   25602.032 ms/op

Iteration   4: 25736.249 ms/op
                 executeQuery·p0.00:   25736.249 ms/op
                 executeQuery·p0.50:   25736.249 ms/op
                 executeQuery·p0.90:   25736.249 ms/op
                 executeQuery·p0.95:   25736.249 ms/op
                 executeQuery·p0.99:   25736.249 ms/op
                 executeQuery·p0.999:  25736.249 ms/op
                 executeQuery·p0.9999: 25736.249 ms/op
                 executeQuery·p1.00:   25736.249 ms/op

Iteration   5: 25904.022 ms/op
                 executeQuery·p0.00:   25904.022 ms/op
                 executeQuery·p0.50:   25904.022 ms/op
                 executeQuery·p0.90:   25904.022 ms/op
                 executeQuery·p0.95:   25904.022 ms/op
                 executeQuery·p0.99:   25904.022 ms/op
                 executeQuery·p0.999:  25904.022 ms/op
                 executeQuery·p0.9999: 25904.022 ms/op
                 executeQuery·p1.00:   25904.022 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =  25424.193 ±(99.9%) 1733.576 ms/op

  Histogram, ms/op:
    [22000.000, 22500.000) = 1 
    [22500.000, 23000.000) = 0 
    [23000.000, 23500.000) = 0 
    [23500.000, 24000.000) = 0 
    [24000.000, 24500.000) = 0 
    [24500.000, 25000.000) = 0 
    [25000.000, 25500.000) = 1 
    [25500.000, 26000.000) = 6 
    [26000.000, 26500.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =  22246.588 ms/op
     p(50.0000) =  25769.804 ms/op
     p(90.0000) =  26155.680 ms/op
     p(95.0000) =  26172.457 ms/op
     p(99.0000) =  26172.457 ms/op
     p(99.9000) =  26172.457 ms/op
     p(99.9900) =  26172.457 ms/op
     p(99.9990) =  26172.457 ms/op
     p(99.9999) =  26172.457 ms/op
    p(100.0000) =  26172.457 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288)

# Run progress: 34.18% complete, ETA 17:01:32
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

54089.744 ms/op
# Warmup Iteration   2: 50063.213 ms/op
# Warmup Iteration   3: 51606.716 ms/op
# Warmup Iteration   4: 49996.104 ms/op
# Warmup Iteration   5: 49794.777 ms/op
Iteration   1: 49928.995 ms/op
                 executeQuery·p0.00:   49928.995 ms/op
                 executeQuery·p0.50:   49928.995 ms/op
                 executeQuery·p0.90:   49928.995 ms/op
                 executeQuery·p0.95:   49928.995 ms/op
                 executeQuery·p0.99:   49928.995 ms/op
                 executeQuery·p0.999:  49928.995 ms/op
                 executeQuery·p0.9999: 49928.995 ms/op
                 executeQuery·p1.00:   49928.995 ms/op

Iteration   2: 51338.281 ms/op
                 executeQuery·p0.00:   51338.281 ms/op
                 executeQuery·p0.50:   51338.281 ms/op
                 executeQuery·p0.90:   51338.281 ms/op
                 executeQuery·p0.95:   51338.281 ms/op
                 executeQuery·p0.99:   51338.281 ms/op
                 executeQuery·p0.999:  51338.281 ms/op
                 executeQuery·p0.9999: 51338.281 ms/op
                 executeQuery·p1.00:   51338.281 ms/op

Iteration   3: 51808.043 ms/op
                 executeQuery·p0.00:   51808.043 ms/op
                 executeQuery·p0.50:   51808.043 ms/op
                 executeQuery·p0.90:   51808.043 ms/op
                 executeQuery·p0.95:   51808.043 ms/op
                 executeQuery·p0.99:   51808.043 ms/op
                 executeQuery·p0.999:  51808.043 ms/op
                 executeQuery·p0.9999: 51808.043 ms/op
                 executeQuery·p1.00:   51808.043 ms/op

Iteration   4: 51472.499 ms/op
                 executeQuery·p0.00:   51472.499 ms/op
                 executeQuery·p0.50:   51472.499 ms/op
                 executeQuery·p0.90:   51472.499 ms/op
                 executeQuery·p0.95:   51472.499 ms/op
                 executeQuery·p0.99:   51472.499 ms/op
                 executeQuery·p0.999:  51472.499 ms/op
                 executeQuery·p0.9999: 51472.499 ms/op
                 executeQuery·p1.00:   51472.499 ms/op

Iteration   5: 50465.866 ms/op
                 executeQuery·p0.00:   50465.866 ms/op
                 executeQuery·p0.50:   50465.866 ms/op
                 executeQuery·p0.90:   50465.866 ms/op
                 executeQuery·p0.95:   50465.866 ms/op
                 executeQuery·p0.99:   50465.866 ms/op
                 executeQuery·p0.999:  50465.866 ms/op
                 executeQuery·p0.9999: 50465.866 ms/op
                 executeQuery·p1.00:   50465.866 ms/op


# Run progress: 34.49% complete, ETA 17:14:55
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_2142740815 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_2142740815() {
        this(4);
    }
    public KeyValueMap_2142740815(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_2142740815 aggregation_state_map = new KeyValueMap_2142740815();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

51338.281 ms/op
# Warmup Iteration   2: 51204.063 ms/op
# Warmup Iteration   3: 50600.083 ms/op
# Warmup Iteration   4: 50398.757 ms/op
# Warmup Iteration   5: 52479.132 ms/op
Iteration   1: 49190.797 ms/op
                 executeQuery·p0.00:   49190.797 ms/op
                 executeQuery·p0.50:   49190.797 ms/op
                 executeQuery·p0.90:   49190.797 ms/op
                 executeQuery·p0.95:   49190.797 ms/op
                 executeQuery·p0.99:   49190.797 ms/op
                 executeQuery·p0.999:  49190.797 ms/op
                 executeQuery·p0.9999: 49190.797 ms/op
                 executeQuery·p1.00:   49190.797 ms/op

Iteration   2: 51069.846 ms/op
                 executeQuery·p0.00:   51069.846 ms/op
                 executeQuery·p0.50:   51069.846 ms/op
                 executeQuery·p0.90:   51069.846 ms/op
                 executeQuery·p0.95:   51069.846 ms/op
                 executeQuery·p0.99:   51069.846 ms/op
                 executeQuery·p0.999:  51069.846 ms/op
                 executeQuery·p0.9999: 51069.846 ms/op
                 executeQuery·p1.00:   51069.846 ms/op

Iteration   3: 51875.152 ms/op
                 executeQuery·p0.00:   51875.152 ms/op
                 executeQuery·p0.50:   51875.152 ms/op
                 executeQuery·p0.90:   51875.152 ms/op
                 executeQuery·p0.95:   51875.152 ms/op
                 executeQuery·p0.99:   51875.152 ms/op
                 executeQuery·p0.999:  51875.152 ms/op
                 executeQuery·p0.9999: 51875.152 ms/op
                 executeQuery·p1.00:   51875.152 ms/op

Iteration   4: 50801.410 ms/op
                 executeQuery·p0.00:   50801.410 ms/op
                 executeQuery·p0.50:   50801.410 ms/op
                 executeQuery·p0.90:   50801.410 ms/op
                 executeQuery·p0.95:   50801.410 ms/op
                 executeQuery·p0.99:   50801.410 ms/op
                 executeQuery·p0.999:  50801.410 ms/op
                 executeQuery·p0.9999: 50801.410 ms/op
                 executeQuery·p1.00:   50801.410 ms/op

Iteration   5: 52210.696 ms/op
                 executeQuery·p0.00:   52210.696 ms/op
                 executeQuery·p0.50:   52210.696 ms/op
                 executeQuery·p0.90:   52210.696 ms/op
                 executeQuery·p0.95:   52210.696 ms/op
                 executeQuery·p0.99:   52210.696 ms/op
                 executeQuery·p0.999:  52210.696 ms/op
                 executeQuery·p0.9999: 52210.696 ms/op
                 executeQuery·p1.00:   52210.696 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =  51016.158 ±(99.9%) 1422.679 ms/op

  Histogram, ms/op:
    [49000.000, 49250.000) = 1 
    [49250.000, 49500.000) = 0 
    [49500.000, 49750.000) = 0 
    [49750.000, 50000.000) = 1 
    [50000.000, 50250.000) = 0 
    [50250.000, 50500.000) = 1 
    [50500.000, 50750.000) = 0 
    [50750.000, 51000.000) = 1 
    [51000.000, 51250.000) = 1 
    [51250.000, 51500.000) = 2 
    [51500.000, 51750.000) = 0 
    [51750.000, 52000.000) = 2 
    [52000.000, 52250.000) = 1 
    [52250.000, 52500.000) = 0 
    [52500.000, 52750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  49190.797 ms/op
     p(50.0000) =  51204.063 ms/op
     p(90.0000) =  52177.142 ms/op
     p(95.0000) =  52210.696 ms/op
     p(99.0000) =  52210.696 ms/op
     p(99.9000) =  52210.696 ms/op
     p(99.9900) =  52210.696 ms/op
     p(99.9990) =  52210.696 ms/op
     p(99.9999) =  52210.696 ms/op
    p(100.0000) =  52210.696 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2)

# Run progress: 34.81% complete, ETA 17:27:47
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

18320.720 ms/op
# Warmup Iteration   2: 11341.398 ms/op
# Warmup Iteration   3: 9403.630 ms/op
# Warmup Iteration   4: 10150.216 ms/op
# Warmup Iteration   5: 10116.661 ms/op
Iteration   1: 10150.216 ms/op
                 executeQuery·p0.00:   10150.216 ms/op
                 executeQuery·p0.50:   10150.216 ms/op
                 executeQuery·p0.90:   10150.216 ms/op
                 executeQuery·p0.95:   10150.216 ms/op
                 executeQuery·p0.99:   10150.216 ms/op
                 executeQuery·p0.999:  10150.216 ms/op
                 executeQuery·p0.9999: 10150.216 ms/op
                 executeQuery·p1.00:   10150.216 ms/op

Iteration   2: 10217.325 ms/op
                 executeQuery·p0.00:   10217.325 ms/op
                 executeQuery·p0.50:   10217.325 ms/op
                 executeQuery·p0.90:   10217.325 ms/op
                 executeQuery·p0.95:   10217.325 ms/op
                 executeQuery·p0.99:   10217.325 ms/op
                 executeQuery·p0.999:  10217.325 ms/op
                 executeQuery·p0.9999: 10217.325 ms/op
                 executeQuery·p1.00:   10217.325 ms/op

Iteration   3: 10653.532 ms/op
                 executeQuery·p0.00:   10653.532 ms/op
                 executeQuery·p0.50:   10653.532 ms/op
                 executeQuery·p0.90:   10653.532 ms/op
                 executeQuery·p0.95:   10653.532 ms/op
                 executeQuery·p0.99:   10653.532 ms/op
                 executeQuery·p0.999:  10653.532 ms/op
                 executeQuery·p0.9999: 10653.532 ms/op
                 executeQuery·p1.00:   10653.532 ms/op

Iteration   4: 10116.661 ms/op
                 executeQuery·p0.00:   10116.661 ms/op
                 executeQuery·p0.50:   10116.661 ms/op
                 executeQuery·p0.90:   10116.661 ms/op
                 executeQuery·p0.95:   10116.661 ms/op
                 executeQuery·p0.99:   10116.661 ms/op
                 executeQuery·p0.999:  10116.661 ms/op
                 executeQuery·p0.9999: 10116.661 ms/op
                 executeQuery·p1.00:   10116.661 ms/op

Iteration   5: 10250.879 ms/op
                 executeQuery·p0.00:   10250.879 ms/op
                 executeQuery·p0.50:   10250.879 ms/op
                 executeQuery·p0.90:   10250.879 ms/op
                 executeQuery·p0.95:   10250.879 ms/op
                 executeQuery·p0.99:   10250.879 ms/op
                 executeQuery·p0.999:  10250.879 ms/op
                 executeQuery·p0.9999: 10250.879 ms/op
                 executeQuery·p1.00:   10250.879 ms/op


# Run progress: 35.13% complete, ETA 17:17:03
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[8];
long[] resultSum2Array = new long[8];
long[] resultSum3Array = new long[8];
long[] resultSum4Array = new long[8];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

8132.755 ms/op
# Warmup Iteration   2: 9491.710 ms/op
# Warmup Iteration   3: 10317.988 ms/op
# Warmup Iteration   4: 10317.988 ms/op
# Warmup Iteration   5: 10317.988 ms/op
Iteration   1: 10317.988 ms/op
                 executeQuery·p0.00:   10317.988 ms/op
                 executeQuery·p0.50:   10317.988 ms/op
                 executeQuery·p0.90:   10317.988 ms/op
                 executeQuery·p0.95:   10317.988 ms/op
                 executeQuery·p0.99:   10317.988 ms/op
                 executeQuery·p0.999:  10317.988 ms/op
                 executeQuery·p0.9999: 10317.988 ms/op
                 executeQuery·p1.00:   10317.988 ms/op

Iteration   2: 10334.765 ms/op
                 executeQuery·p0.00:   10334.765 ms/op
                 executeQuery·p0.50:   10334.765 ms/op
                 executeQuery·p0.90:   10334.765 ms/op
                 executeQuery·p0.95:   10334.765 ms/op
                 executeQuery·p0.99:   10334.765 ms/op
                 executeQuery·p0.999:  10334.765 ms/op
                 executeQuery·p0.9999: 10334.765 ms/op
                 executeQuery·p1.00:   10334.765 ms/op

Iteration   3: 10317.988 ms/op
                 executeQuery·p0.00:   10317.988 ms/op
                 executeQuery·p0.50:   10317.988 ms/op
                 executeQuery·p0.90:   10317.988 ms/op
                 executeQuery·p0.95:   10317.988 ms/op
                 executeQuery·p0.99:   10317.988 ms/op
                 executeQuery·p0.999:  10317.988 ms/op
                 executeQuery·p0.9999: 10317.988 ms/op
                 executeQuery·p1.00:   10317.988 ms/op

Iteration   4: 10284.433 ms/op
                 executeQuery·p0.00:   10284.433 ms/op
                 executeQuery·p0.50:   10284.433 ms/op
                 executeQuery·p0.90:   10284.433 ms/op
                 executeQuery·p0.95:   10284.433 ms/op
                 executeQuery·p0.99:   10284.433 ms/op
                 executeQuery·p0.999:  10284.433 ms/op
                 executeQuery·p0.9999: 10284.433 ms/op
                 executeQuery·p1.00:   10284.433 ms/op

Iteration   5: 10317.988 ms/op
                 executeQuery·p0.00:   10317.988 ms/op
                 executeQuery·p0.50:   10317.988 ms/op
                 executeQuery·p0.90:   10317.988 ms/op
                 executeQuery·p0.95:   10317.988 ms/op
                 executeQuery·p0.99:   10317.988 ms/op
                 executeQuery·p0.999:  10317.988 ms/op
                 executeQuery·p0.9999: 10317.988 ms/op
                 executeQuery·p1.00:   10317.988 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =  10296.177 ±(99.9%) 221.141 ms/op

  Histogram, ms/op:
    [10100.000, 10150.000) = 1 
    [10150.000, 10200.000) = 1 
    [10200.000, 10250.000) = 1 
    [10250.000, 10300.000) = 2 
    [10300.000, 10350.000) = 4 
    [10350.000, 10400.000) = 0 
    [10400.000, 10450.000) = 0 
    [10450.000, 10500.000) = 0 
    [10500.000, 10550.000) = 0 
    [10550.000, 10600.000) = 0 
    [10600.000, 10650.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  10116.661 ms/op
     p(50.0000) =  10301.211 ms/op
     p(90.0000) =  10621.655 ms/op
     p(95.0000) =  10653.532 ms/op
     p(99.0000) =  10653.532 ms/op
     p(99.9000) =  10653.532 ms/op
     p(99.9900) =  10653.532 ms/op
     p(99.9990) =  10653.532 ms/op
     p(99.9999) =  10653.532 ms/op
    p(100.0000) =  10653.532 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16)

# Run progress: 35.44% complete, ETA 17:06:25
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

17062.429 ms/op
# Warmup Iteration   2: 16944.988 ms/op
# Warmup Iteration   3: 14579.401 ms/op
# Warmup Iteration   4: 17481.859 ms/op
# Warmup Iteration   5: 16911.434 ms/op
Iteration   1: 16894.657 ms/op
                 executeQuery·p0.00:   16894.657 ms/op
                 executeQuery·p0.50:   16894.657 ms/op
                 executeQuery·p0.90:   16894.657 ms/op
                 executeQuery·p0.95:   16894.657 ms/op
                 executeQuery·p0.99:   16894.657 ms/op
                 executeQuery·p0.999:  16894.657 ms/op
                 executeQuery·p0.9999: 16894.657 ms/op
                 executeQuery·p1.00:   16894.657 ms/op

Iteration   2: 16911.434 ms/op
                 executeQuery·p0.00:   16911.434 ms/op
                 executeQuery·p0.50:   16911.434 ms/op
                 executeQuery·p0.90:   16911.434 ms/op
                 executeQuery·p0.95:   16911.434 ms/op
                 executeQuery·p0.99:   16911.434 ms/op
                 executeQuery·p0.999:  16911.434 ms/op
                 executeQuery·p0.9999: 16911.434 ms/op
                 executeQuery·p1.00:   16911.434 ms/op

Iteration   3: 16911.434 ms/op
                 executeQuery·p0.00:   16911.434 ms/op
                 executeQuery·p0.50:   16911.434 ms/op
                 executeQuery·p0.90:   16911.434 ms/op
                 executeQuery·p0.95:   16911.434 ms/op
                 executeQuery·p0.99:   16911.434 ms/op
                 executeQuery·p0.999:  16911.434 ms/op
                 executeQuery·p0.9999: 16911.434 ms/op
                 executeQuery·p1.00:   16911.434 ms/op

Iteration   4: 16810.770 ms/op
                 executeQuery·p0.00:   16810.770 ms/op
                 executeQuery·p0.50:   16810.770 ms/op
                 executeQuery·p0.90:   16810.770 ms/op
                 executeQuery·p0.95:   16810.770 ms/op
                 executeQuery·p0.99:   16810.770 ms/op
                 executeQuery·p0.999:  16810.770 ms/op
                 executeQuery·p0.9999: 16810.770 ms/op
                 executeQuery·p1.00:   16810.770 ms/op

Iteration   5: 16911.434 ms/op
                 executeQuery·p0.00:   16911.434 ms/op
                 executeQuery·p0.50:   16911.434 ms/op
                 executeQuery·p0.90:   16911.434 ms/op
                 executeQuery·p0.95:   16911.434 ms/op
                 executeQuery·p0.99:   16911.434 ms/op
                 executeQuery·p0.999:  16911.434 ms/op
                 executeQuery·p0.9999: 16911.434 ms/op
                 executeQuery·p1.00:   16911.434 ms/op


# Run progress: 35.76% complete, ETA 16:57:24
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[64];
long[] resultSum2Array = new long[64];
long[] resultSum3Array = new long[64];
long[] resultSum4Array = new long[64];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

15049.163 ms/op
# Warmup Iteration   2: 16693.330 ms/op
# Warmup Iteration   3: 14612.955 ms/op
# Warmup Iteration   4: 17783.849 ms/op
# Warmup Iteration   5: 16458.449 ms/op
Iteration   1: 16995.320 ms/op
                 executeQuery·p0.00:   16995.320 ms/op
                 executeQuery·p0.50:   16995.320 ms/op
                 executeQuery·p0.90:   16995.320 ms/op
                 executeQuery·p0.95:   16995.320 ms/op
                 executeQuery·p0.99:   16995.320 ms/op
                 executeQuery·p0.999:  16995.320 ms/op
                 executeQuery·p0.9999: 16995.320 ms/op
                 executeQuery·p1.00:   16995.320 ms/op

Iteration   2: 16424.894 ms/op
                 executeQuery·p0.00:   16424.894 ms/op
                 executeQuery·p0.50:   16424.894 ms/op
                 executeQuery·p0.90:   16424.894 ms/op
                 executeQuery·p0.95:   16424.894 ms/op
                 executeQuery·p0.99:   16424.894 ms/op
                 executeQuery·p0.999:  16424.894 ms/op
                 executeQuery·p0.9999: 16424.894 ms/op
                 executeQuery·p1.00:   16424.894 ms/op

Iteration   3: 16492.003 ms/op
                 executeQuery·p0.00:   16492.003 ms/op
                 executeQuery·p0.50:   16492.003 ms/op
                 executeQuery·p0.90:   16492.003 ms/op
                 executeQuery·p0.95:   16492.003 ms/op
                 executeQuery·p0.99:   16492.003 ms/op
                 executeQuery·p0.999:  16492.003 ms/op
                 executeQuery·p0.9999: 16492.003 ms/op
                 executeQuery·p1.00:   16492.003 ms/op

Iteration   4: 16424.894 ms/op
                 executeQuery·p0.00:   16424.894 ms/op
                 executeQuery·p0.50:   16424.894 ms/op
                 executeQuery·p0.90:   16424.894 ms/op
                 executeQuery·p0.95:   16424.894 ms/op
                 executeQuery·p0.99:   16424.894 ms/op
                 executeQuery·p0.999:  16424.894 ms/op
                 executeQuery·p0.9999: 16424.894 ms/op
                 executeQuery·p1.00:   16424.894 ms/op

Iteration   5: 16894.657 ms/op
                 executeQuery·p0.00:   16894.657 ms/op
                 executeQuery·p0.50:   16894.657 ms/op
                 executeQuery·p0.90:   16894.657 ms/op
                 executeQuery·p0.95:   16894.657 ms/op
                 executeQuery·p0.99:   16894.657 ms/op
                 executeQuery·p0.999:  16894.657 ms/op
                 executeQuery·p0.9999: 16894.657 ms/op
                 executeQuery·p1.00:   16894.657 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =  16767.150 ±(99.9%) 341.395 ms/op

  Histogram, ms/op:
    [16400.000, 16450.000) = 2 
    [16450.000, 16500.000) = 1 
    [16500.000, 16550.000) = 0 
    [16550.000, 16600.000) = 0 
    [16600.000, 16650.000) = 0 
    [16650.000, 16700.000) = 0 
    [16700.000, 16750.000) = 0 
    [16750.000, 16800.000) = 0 
    [16800.000, 16850.000) = 1 
    [16850.000, 16900.000) = 2 
    [16900.000, 16950.000) = 3 

  Percentiles, ms/op:
      p(0.0000) =  16424.894 ms/op
     p(50.0000) =  16894.657 ms/op
     p(90.0000) =  16986.931 ms/op
     p(95.0000) =  16995.320 ms/op
     p(99.0000) =  16995.320 ms/op
     p(99.9000) =  16995.320 ms/op
     p(99.9900) =  16995.320 ms/op
     p(99.9990) =  16995.320 ms/op
     p(99.9999) =  16995.320 ms/op
    p(100.0000) =  16995.320 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192)

# Run progress: 36.08% complete, ETA 16:48:24
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

21810.381 ms/op
# Warmup Iteration   2: 20736.639 ms/op
# Warmup Iteration   3: 20266.877 ms/op
# Warmup Iteration   4: 19662.897 ms/op
# Warmup Iteration   5: 19394.462 ms/op
Iteration   1: 19394.462 ms/op
                 executeQuery·p0.00:   19394.462 ms/op
                 executeQuery·p0.50:   19394.462 ms/op
                 executeQuery·p0.90:   19394.462 ms/op
                 executeQuery·p0.95:   19394.462 ms/op
                 executeQuery·p0.99:   19394.462 ms/op
                 executeQuery·p0.999:  19394.462 ms/op
                 executeQuery·p0.9999: 19394.462 ms/op
                 executeQuery·p1.00:   19394.462 ms/op

Iteration   2: 19763.560 ms/op
                 executeQuery·p0.00:   19763.560 ms/op
                 executeQuery·p0.50:   19763.560 ms/op
                 executeQuery·p0.90:   19763.560 ms/op
                 executeQuery·p0.95:   19763.560 ms/op
                 executeQuery·p0.99:   19763.560 ms/op
                 executeQuery·p0.999:  19763.560 ms/op
                 executeQuery·p0.9999: 19763.560 ms/op
                 executeQuery·p1.00:   19763.560 ms/op

Iteration   3: 19327.353 ms/op
                 executeQuery·p0.00:   19327.353 ms/op
                 executeQuery·p0.50:   19327.353 ms/op
                 executeQuery·p0.90:   19327.353 ms/op
                 executeQuery·p0.95:   19327.353 ms/op
                 executeQuery·p0.99:   19327.353 ms/op
                 executeQuery·p0.999:  19327.353 ms/op
                 executeQuery·p0.9999: 19327.353 ms/op
                 executeQuery·p1.00:   19327.353 ms/op

Iteration   4: 19293.798 ms/op
                 executeQuery·p0.00:   19293.798 ms/op
                 executeQuery·p0.50:   19293.798 ms/op
                 executeQuery·p0.90:   19293.798 ms/op
                 executeQuery·p0.95:   19293.798 ms/op
                 executeQuery·p0.99:   19293.798 ms/op
                 executeQuery·p0.999:  19293.798 ms/op
                 executeQuery·p0.9999: 19293.798 ms/op
                 executeQuery·p1.00:   19293.798 ms/op

Iteration   5: 19092.472 ms/op
                 executeQuery·p0.00:   19092.472 ms/op
                 executeQuery·p0.50:   19092.472 ms/op
                 executeQuery·p0.90:   19092.472 ms/op
                 executeQuery·p0.95:   19092.472 ms/op
                 executeQuery·p0.99:   19092.472 ms/op
                 executeQuery·p0.999:  19092.472 ms/op
                 executeQuery·p0.9999: 19092.472 ms/op
                 executeQuery·p1.00:   19092.472 ms/op


# Run progress: 36.39% complete, ETA 16:40:32
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[32768];
long[] resultSum2Array = new long[32768];
long[] resultSum3Array = new long[32768];
long[] resultSum4Array = new long[32768];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

20736.639 ms/op
# Warmup Iteration   2: 20635.976 ms/op
# Warmup Iteration   3: 20132.659 ms/op
# Warmup Iteration   4: 19830.669 ms/op
# Warmup Iteration   5: 19629.343 ms/op
Iteration   1: 19528.679 ms/op
                 executeQuery·p0.00:   19528.679 ms/op
                 executeQuery·p0.50:   19528.679 ms/op
                 executeQuery·p0.90:   19528.679 ms/op
                 executeQuery·p0.95:   19528.679 ms/op
                 executeQuery·p0.99:   19528.679 ms/op
                 executeQuery·p0.999:  19528.679 ms/op
                 executeQuery·p0.9999: 19528.679 ms/op
                 executeQuery·p1.00:   19528.679 ms/op

Iteration   2: 21407.728 ms/op
                 executeQuery·p0.00:   21407.728 ms/op
                 executeQuery·p0.50:   21407.728 ms/op
                 executeQuery·p0.90:   21407.728 ms/op
                 executeQuery·p0.95:   21407.728 ms/op
                 executeQuery·p0.99:   21407.728 ms/op
                 executeQuery·p0.999:  21407.728 ms/op
                 executeQuery·p0.9999: 21407.728 ms/op
                 executeQuery·p1.00:   21407.728 ms/op

Iteration   3: 19193.135 ms/op
                 executeQuery·p0.00:   19193.135 ms/op
                 executeQuery·p0.50:   19193.135 ms/op
                 executeQuery·p0.90:   19193.135 ms/op
                 executeQuery·p0.95:   19193.135 ms/op
                 executeQuery·p0.99:   19193.135 ms/op
                 executeQuery·p0.999:  19193.135 ms/op
                 executeQuery·p0.9999: 19193.135 ms/op
                 executeQuery·p1.00:   19193.135 ms/op

Iteration   4: 19730.006 ms/op
                 executeQuery·p0.00:   19730.006 ms/op
                 executeQuery·p0.50:   19730.006 ms/op
                 executeQuery·p0.90:   19730.006 ms/op
                 executeQuery·p0.95:   19730.006 ms/op
                 executeQuery·p0.99:   19730.006 ms/op
                 executeQuery·p0.999:  19730.006 ms/op
                 executeQuery·p0.9999: 19730.006 ms/op
                 executeQuery·p1.00:   19730.006 ms/op

Iteration   5: 19562.234 ms/op
                 executeQuery·p0.00:   19562.234 ms/op
                 executeQuery·p0.50:   19562.234 ms/op
                 executeQuery·p0.90:   19562.234 ms/op
                 executeQuery·p0.95:   19562.234 ms/op
                 executeQuery·p0.99:   19562.234 ms/op
                 executeQuery·p0.999:  19562.234 ms/op
                 executeQuery·p0.9999: 19562.234 ms/op
                 executeQuery·p1.00:   19562.234 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =  19629.343 ±(99.9%) 1000.685 ms/op

  Histogram, ms/op:
    [19000.000, 19250.000) = 2 
    [19250.000, 19500.000) = 3 
    [19500.000, 19750.000) = 3 
    [19750.000, 20000.000) = 1 
    [20000.000, 20250.000) = 0 
    [20250.000, 20500.000) = 0 
    [20500.000, 20750.000) = 0 
    [20750.000, 21000.000) = 0 
    [21000.000, 21250.000) = 0 
    [21250.000, 21500.000) = 1 
    [21500.000, 21750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  19092.472 ms/op
     p(50.0000) =  19461.571 ms/op
     p(90.0000) =  21243.311 ms/op
     p(95.0000) =  21407.728 ms/op
     p(99.0000) =  21407.728 ms/op
     p(99.9000) =  21407.728 ms/op
     p(99.9900) =  21407.728 ms/op
     p(99.9990) =  21407.728 ms/op
     p(99.9999) =  21407.728 ms/op
    p(100.0000) =  21407.728 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144)

# Run progress: 36.71% complete, ETA 16:32:47
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

57042.534 ms/op
# Warmup Iteration   2: 53619.982 ms/op
# Warmup Iteration   3: 51136.954 ms/op
# Warmup Iteration   4: 51606.716 ms/op
# Warmup Iteration   5: 51606.716 ms/op
Iteration   1: 51338.281 ms/op
                 executeQuery·p0.00:   51338.281 ms/op
                 executeQuery·p0.50:   51338.281 ms/op
                 executeQuery·p0.90:   51338.281 ms/op
                 executeQuery·p0.95:   51338.281 ms/op
                 executeQuery·p0.99:   51338.281 ms/op
                 executeQuery·p0.999:  51338.281 ms/op
                 executeQuery·p0.9999: 51338.281 ms/op
                 executeQuery·p1.00:   51338.281 ms/op

Iteration   2: 50868.519 ms/op
                 executeQuery·p0.00:   50868.519 ms/op
                 executeQuery·p0.50:   50868.519 ms/op
                 executeQuery·p0.90:   50868.519 ms/op
                 executeQuery·p0.95:   50868.519 ms/op
                 executeQuery·p0.99:   50868.519 ms/op
                 executeQuery·p0.999:  50868.519 ms/op
                 executeQuery·p0.9999: 50868.519 ms/op
                 executeQuery·p1.00:   50868.519 ms/op

Iteration   3: 51136.954 ms/op
                 executeQuery·p0.00:   51136.954 ms/op
                 executeQuery·p0.50:   51136.954 ms/op
                 executeQuery·p0.90:   51136.954 ms/op
                 executeQuery·p0.95:   51136.954 ms/op
                 executeQuery·p0.99:   51136.954 ms/op
                 executeQuery·p0.999:  51136.954 ms/op
                 executeQuery·p0.9999: 51136.954 ms/op
                 executeQuery·p1.00:   51136.954 ms/op

Iteration   4: 56572.772 ms/op
                 executeQuery·p0.00:   56572.772 ms/op
                 executeQuery·p0.50:   56572.772 ms/op
                 executeQuery·p0.90:   56572.772 ms/op
                 executeQuery·p0.95:   56572.772 ms/op
                 executeQuery·p0.99:   56572.772 ms/op
                 executeQuery·p0.999:  56572.772 ms/op
                 executeQuery·p0.9999: 56572.772 ms/op
                 executeQuery·p1.00:   56572.772 ms/op

Iteration   5: 53552.873 ms/op
                 executeQuery·p0.00:   53552.873 ms/op
                 executeQuery·p0.50:   53552.873 ms/op
                 executeQuery·p0.90:   53552.873 ms/op
                 executeQuery·p0.95:   53552.873 ms/op
                 executeQuery·p0.99:   53552.873 ms/op
                 executeQuery·p0.999:  53552.873 ms/op
                 executeQuery·p0.9999: 53552.873 ms/op
                 executeQuery·p1.00:   53552.873 ms/op


# Run progress: 37.03% complete, ETA 16:36:57
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[1048576];
long[] resultSum2Array = new long[1048576];
long[] resultSum3Array = new long[1048576];
long[] resultSum4Array = new long[1048576];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

54962.160 ms/op
# Warmup Iteration   2: 54156.853 ms/op
# Warmup Iteration   3: 51673.825 ms/op
# Warmup Iteration   4: 53754.200 ms/op
# Warmup Iteration   5: 52881.785 ms/op
Iteration   1: 53821.309 ms/op
                 executeQuery·p0.00:   53821.309 ms/op
                 executeQuery·p0.50:   53821.309 ms/op
                 executeQuery·p0.90:   53821.309 ms/op
                 executeQuery·p0.95:   53821.309 ms/op
                 executeQuery·p0.99:   53821.309 ms/op
                 executeQuery·p0.999:  53821.309 ms/op
                 executeQuery·p0.9999: 53821.309 ms/op
                 executeQuery·p1.00:   53821.309 ms/op

Iteration   2: 45902.463 ms/op
                 executeQuery·p0.00:   45902.463 ms/op
                 executeQuery·p0.50:   45902.463 ms/op
                 executeQuery·p0.90:   45902.463 ms/op
                 executeQuery·p0.95:   45902.463 ms/op
                 executeQuery·p0.99:   45902.463 ms/op
                 executeQuery·p0.999:  45902.463 ms/op
                 executeQuery·p0.9999: 45902.463 ms/op
                 executeQuery·p1.00:   45902.463 ms/op

Iteration   3: 52009.370 ms/op
                 executeQuery·p0.00:   52009.370 ms/op
                 executeQuery·p0.50:   52009.370 ms/op
                 executeQuery·p0.90:   52009.370 ms/op
                 executeQuery·p0.95:   52009.370 ms/op
                 executeQuery·p0.99:   52009.370 ms/op
                 executeQuery·p0.999:  52009.370 ms/op
                 executeQuery·p0.9999: 52009.370 ms/op
                 executeQuery·p1.00:   52009.370 ms/op

Iteration   4: 51472.499 ms/op
                 executeQuery·p0.00:   51472.499 ms/op
                 executeQuery·p0.50:   51472.499 ms/op
                 executeQuery·p0.90:   51472.499 ms/op
                 executeQuery·p0.95:   51472.499 ms/op
                 executeQuery·p0.99:   51472.499 ms/op
                 executeQuery·p0.999:  51472.499 ms/op
                 executeQuery·p0.9999: 51472.499 ms/op
                 executeQuery·p1.00:   51472.499 ms/op

Iteration   5: 51002.737 ms/op
                 executeQuery·p0.00:   51002.737 ms/op
                 executeQuery·p0.50:   51002.737 ms/op
                 executeQuery·p0.90:   51002.737 ms/op
                 executeQuery·p0.95:   51002.737 ms/op
                 executeQuery·p0.99:   51002.737 ms/op
                 executeQuery·p0.999:  51002.737 ms/op
                 executeQuery·p0.9999: 51002.737 ms/op
                 executeQuery·p1.00:   51002.737 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean =  51767.778 ±(99.9%) 4125.501 ms/op

  Histogram, ms/op:
    [40000.000, 41250.000) = 0 
    [41250.000, 42500.000) = 0 
    [42500.000, 43750.000) = 0 
    [43750.000, 45000.000) = 0 
    [45000.000, 46250.000) = 1 
    [46250.000, 47500.000) = 0 
    [47500.000, 48750.000) = 0 
    [48750.000, 50000.000) = 0 
    [50000.000, 51250.000) = 3 
    [51250.000, 52500.000) = 3 
    [52500.000, 53750.000) = 1 
    [53750.000, 55000.000) = 1 
    [55000.000, 56250.000) = 0 
    [56250.000, 57500.000) = 1 
    [57500.000, 58750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  45902.463 ms/op
     p(50.0000) =  51405.390 ms/op
     p(90.0000) =  56297.626 ms/op
     p(95.0000) =  56572.772 ms/op
     p(99.0000) =  56572.772 ms/op
     p(99.9000) =  56572.772 ms/op
     p(99.9900) =  56572.772 ms/op
     p(99.9990) =  56572.772 ms/op
     p(99.9999) =  56572.772 ms/op
    p(100.0000) =  56572.772 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.aggregation_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288)

# Run progress: 37.34% complete, ETA 16:40:38
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

109119.013 ms/op
# Warmup Iteration   2: 102139.691 ms/op
# Warmup Iteration   3: 102944.997 ms/op
# Warmup Iteration   4: 100394.861 ms/op
# Warmup Iteration   5: 100394.861 ms/op
Iteration   1: 102810.780 ms/op
                 executeQuery·p0.00:   102810.780 ms/op
                 executeQuery·p0.50:   102810.780 ms/op
                 executeQuery·p0.90:   102810.780 ms/op
                 executeQuery·p0.95:   102810.780 ms/op
                 executeQuery·p0.99:   102810.780 ms/op
                 executeQuery·p0.999:  102810.780 ms/op
                 executeQuery·p0.9999: 102810.780 ms/op
                 executeQuery·p1.00:   102810.780 ms/op

Iteration   2: 102542.344 ms/op
                 executeQuery·p0.00:   102542.344 ms/op
                 executeQuery·p0.50:   102542.344 ms/op
                 executeQuery·p0.90:   102542.344 ms/op
                 executeQuery·p0.95:   102542.344 ms/op
                 executeQuery·p0.99:   102542.344 ms/op
                 executeQuery·p0.999:  102542.344 ms/op
                 executeQuery·p0.9999: 102542.344 ms/op
                 executeQuery·p1.00:   102542.344 ms/op

Iteration   3: 103213.433 ms/op
                 executeQuery·p0.00:   103213.433 ms/op
                 executeQuery·p0.50:   103213.433 ms/op
                 executeQuery·p0.90:   103213.433 ms/op
                 executeQuery·p0.95:   103213.433 ms/op
                 executeQuery·p0.99:   103213.433 ms/op
                 executeQuery·p0.999:  103213.433 ms/op
                 executeQuery·p0.9999: 103213.433 ms/op
                 executeQuery·p1.00:   103213.433 ms/op

Iteration   4: 101200.167 ms/op
                 executeQuery·p0.00:   101200.167 ms/op
                 executeQuery·p0.50:   101200.167 ms/op
                 executeQuery·p0.90:   101200.167 ms/op
                 executeQuery·p0.95:   101200.167 ms/op
                 executeQuery·p0.99:   101200.167 ms/op
                 executeQuery·p0.999:  101200.167 ms/op
                 executeQuery·p0.9999: 101200.167 ms/op
                 executeQuery·p1.00:   101200.167 ms/op

Iteration   5: 103347.651 ms/op
                 executeQuery·p0.00:   103347.651 ms/op
                 executeQuery·p0.50:   103347.651 ms/op
                 executeQuery·p0.90:   103347.651 ms/op
                 executeQuery·p0.95:   103347.651 ms/op
                 executeQuery·p0.99:   103347.651 ms/op
                 executeQuery·p0.999:  103347.651 ms/op
                 executeQuery·p0.9999: 103347.651 ms/op
                 executeQuery·p1.00:   103347.651 ms/op


# Run progress: 37.66% complete, ETA 17:05:40
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2, 3]
Finished query code!

[Generated query code]
int[] resultKeyArray = new int[2097152];
long[] resultSum2Array = new long[2097152];
long[] resultSum3Array = new long[2097152];
long[] resultSum4Array = new long[2097152];
int resultWritePtr = 0;
long[] groupKeyPreHashVector = cCtx.getAllocationManager().getLongVector();
private final class KeyValueMap_865415658 {
    public int numberOfRecords;
    public int[] keys_ord_0;
    public long[] values_ord_0;
    public long[] values_ord_1;
    public long[] values_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyValueMap_865415658() {
        this(4);
    }
    public KeyValueMap_865415658(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys_ord_0 = new int[capacity];
        Arrays.fill(this.keys_ord_0, -1);
        this.values_ord_0 = new long[capacity];
        this.values_ord_1 = new long[capacity];
        this.values_ord_2 = new long[capacity];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void incrementForKey(int key_ord_0, long preHash, long value_ord_0, long value_ord_1, long value_ord_2) {
        if ((key_ord_0 < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects the first key ordinal to be non-negative");
        }
        int index = this.find(key_ord_0, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys_ord_0.length == index)) {
                this.growArrays();
            }
            this.keys_ord_0[index] = key_ord_0;
        }
        this.values_ord_0[index] += value_ord_0;
        this.values_ord_1[index] += value_ord_1;
        this.values_ord_2[index] += value_ord_2;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key_ord_0, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key_ord_0, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys_ord_0[currentIndex] != key_ord_0)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys_ord_0.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] keys_ord_0_new = new int[newSize];
        System.arraycopy(this.keys_ord_0, 0, keys_ord_0_new, 0, currentSize);
        Arrays.fill(keys_ord_0_new, currentSize, newSize, -1);
        this.keys_ord_0 = keys_ord_0_new;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        long[] new_values_ord_0 = new long[newSize];
        System.arraycopy(this.values_ord_0, 0, new_values_ord_0, 0, currentSize);
        this.values_ord_0 = new_values_ord_0;
        long[] new_values_ord_1 = new long[newSize];
        System.arraycopy(this.values_ord_1, 0, new_values_ord_1, 0, currentSize);
        this.values_ord_1 = new_values_ord_1;
        long[] new_values_ord_2 = new long[newSize];
        System.arraycopy(this.values_ord_2, 0, new_values_ord_2, 0, currentSize);
        this.values_ord_2 = new_values_ord_2;
    }
    private void putHashEntry(int key_ord_0, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys_ord_0[currentIndex] != key_ord_0) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key_ord_0 = this.keys_ord_0[i];
            long preHash = Int_Hash_Function.preHash(key_ord_0);
            this.putHashEntry(key_ord_0, preHash, i, false);
        }
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys_ord_0, -1);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        Arrays.fill(this.values_ord_0, 0);
        Arrays.fill(this.values_ord_1, 0);
        Arrays.fill(this.values_ord_2, 0);
    }
}

KeyValueMap_865415658 aggregation_state_map = new KeyValueMap_865415658();
ArrowTableReader aggregation_query_table = cCtx.getArrowReader(0);
while (aggregation_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(0));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(1));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(2));
    org.apache.arrow.vector.IntVector aggregation_query_table_vc_3 = ((org.apache.arrow.vector.IntVector) aggregation_query_table.getVector(3));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(groupKeyPreHashVector, aggregation_query_table_vc_0, false);
    int recordCount = aggregation_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        aggregation_state_map.incrementForKey(aggregation_query_table_vc_0.get(aviv), groupKeyPreHashVector[aviv], aggregation_query_table_vc_1.get(aviv), aggregation_query_table_vc_2.get(aviv), aggregation_query_table_vc_3.get(aviv));
    }
}
int aggregationResultVectorLength;
int[] groupKeyVector_0 = cCtx.getAllocationManager().getIntVector();
long[] agg_G_SUM_0_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_1_vector = cCtx.getAllocationManager().getLongVector();
long[] agg_G_SUM_2_vector = cCtx.getAllocationManager().getLongVector();
int current_key_offset = 0;
int number_of_records = aggregation_state_map.numberOfRecords;
while ((current_key_offset < number_of_records)) {
    aggregationResultVectorLength = VectorisedAggregationOperators.constructVector(groupKeyVector_0, aggregation_state_map.keys_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_0_vector, aggregation_state_map.values_ord_0, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_1_vector, aggregation_state_map.values_ord_1, number_of_records, current_key_offset);
    VectorisedAggregationOperators.constructVector(agg_G_SUM_2_vector, aggregation_state_map.values_ord_2, number_of_records, current_key_offset);
    current_key_offset += aggregationResultVectorLength;
    System.arraycopy(groupKeyVector_0, 0, resultKeyArray, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_0_vector, 0, resultSum2Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_1_vector, 0, resultSum3Array, resultWritePtr, aggregationResultVectorLength);
    System.arraycopy(agg_G_SUM_2_vector, 0, resultSum4Array, resultWritePtr, aggregationResultVectorLength);
    resultWritePtr += aggregationResultVectorLength;
}
cCtx.getAllocationManager().release(groupKeyVector_0);
cCtx.getAllocationManager().release(agg_G_SUM_0_vector);
cCtx.getAllocationManager().release(agg_G_SUM_1_vector);
cCtx.getAllocationManager().release(agg_G_SUM_2_vector);
cCtx.getAllocationManager().release(groupKeyPreHashVector);
cCtx.getResultConsumptionTarget().consumeResultItem(resultKeyArray);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum2Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum3Array);
cCtx.getResultConsumptionTarget().consumeResultItem(resultSum4Array);

104018.739 ms/op
# Warmup Iteration   2: 100260.643 ms/op
# Warmup Iteration   3: 101334.385 ms/op
# Warmup Iteration   4: 99455.336 ms/op
# Warmup Iteration   5: 101468.602 ms/op
Iteration   1: 104018.739 ms/op
                 executeQuery·p0.00:   104018.739 ms/op
                 executeQuery·p0.50:   104018.739 ms/op
                 executeQuery·p0.90:   104018.739 ms/op
                 executeQuery·p0.95:   104018.739 ms/op
                 executeQuery·p0.99:   104018.739 ms/op
                 executeQuery·p0.999:  104018.739 ms/op
                 executeQuery·p0.9999: 104018.739 ms/op
                 executeQuery·p1.00:   104018.739 ms/op

Iteration   2: 101602.820 ms/op
                 executeQuery·p0.00:   101602.820 ms/op
                 executeQuery·p0.50:   101602.820 ms/op
                 executeQuery·p0.90:   101602.820 ms/op
                 executeQuery·p0.95:   101602.820 ms/op
                 executeQuery·p0.99:   101602.820 ms/op
                 executeQuery·p0.999:  101602.820 ms/op
                 executeQuery·p0.9999: 101602.820 ms/op
                 executeQuery·p1.00:   101602.820 ms/op

Iteration   3: 101468.602 ms/op
                 executeQuery·p0.00:   101468.602 ms/op
                 executeQuery·p0.50:   101468.602 ms/op
                 executeQuery·p0.90:   101468.602 ms/op
                 executeQuery·p0.95:   101468.602 ms/op
                 executeQuery·p0.99:   101468.602 ms/op
                 executeQuery·p0.999:  101468.602 ms/op
                 executeQuery·p0.9999: 101468.602 ms/op
                 executeQuery·p1.00:   101468.602 ms/op

Iteration   4: 102005.473 ms/op
                 executeQuery·p0.00:   102005.473 ms/op
                 executeQuery·p0.50:   102005.473 ms/op
                 executeQuery·p0.90:   102005.473 ms/op
                 executeQuery·p0.95:   102005.473 ms/op
                 executeQuery·p0.99:   102005.473 ms/op
                 executeQuery·p0.999:  102005.473 ms/op
                 executeQuery·p0.9999: 102005.473 ms/op
                 executeQuery·p1.00:   102005.473 ms/op

Iteration   5: 102542.344 ms/op
                 executeQuery·p0.00:   102542.344 ms/op
                 executeQuery·p0.50:   102542.344 ms/op
                 executeQuery·p0.90:   102542.344 ms/op
                 executeQuery·p0.95:   102542.344 ms/op
                 executeQuery·p0.99:   102542.344 ms/op
                 executeQuery·p0.999:  102542.344 ms/op
                 executeQuery·p0.9999: 102542.344 ms/op
                 executeQuery·p1.00:   102542.344 ms/op



Result "benchmarks.aggregation_query.VectorisedSimd.executeQuery":
  N = 10
  mean = 102475.235 ±(99.9%) 1373.762 ms/op

  Histogram, ms/op:
    [101000.000, 101250.000) = 1 
    [101250.000, 101500.000) = 1 
    [101500.000, 101750.000) = 1 
    [101750.000, 102000.000) = 0 
    [102000.000, 102250.000) = 1 
    [102250.000, 102500.000) = 0 
    [102500.000, 102750.000) = 2 
    [102750.000, 103000.000) = 1 
    [103000.000, 103250.000) = 1 
    [103250.000, 103500.000) = 1 
    [103500.000, 103750.000) = 0 
    [103750.000, 104000.000) = 0 
    [104000.000, 104250.000) = 1 
    [104250.000, 104500.000) = 0 
    [104500.000, 104750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) = 101200.167 ms/op
     p(50.0000) = 102542.344 ms/op
     p(90.0000) = 103951.630 ms/op
     p(95.0000) = 104018.739 ms/op
     p(99.0000) = 104018.739 ms/op
     p(99.9000) = 104018.739 ms/op
     p(99.9900) = 104018.739 ms/op
     p(99.9990) = 104018.739 ms/op
     p(99.9999) = 104018.739 ms/op
    p(100.0000) = 104018.739 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/)

# Run progress: 37.97% complete, ETA 17:29:36
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

84.821 ±(99.9%) 18.462 ms/op
# Warmup Iteration   2: 77.414 ±(99.9%) 0.681 ms/op
# Warmup Iteration   3: 77.339 ±(99.9%) 0.803 ms/op
# Warmup Iteration   4: 78.380 ±(99.9%) 0.632 ms/op
# Warmup Iteration   5: 78.085 ±(99.9%) 0.674 ms/op
Iteration   1: 77.746 ±(99.9%) 0.777 ms/op
                 executeFilterQuery·p0.00:   72.745 ms/op
                 executeFilterQuery·p0.50:   78.905 ms/op
                 executeFilterQuery·p0.90:   80.373 ms/op
                 executeFilterQuery·p0.95:   81.134 ms/op
                 executeFilterQuery·p0.99:   81.621 ms/op
                 executeFilterQuery·p0.999:  81.658 ms/op
                 executeFilterQuery·p0.9999: 81.658 ms/op
                 executeFilterQuery·p1.00:   81.658 ms/op

Iteration   2: 76.982 ±(99.9%) 0.847 ms/op
                 executeFilterQuery·p0.00:   69.730 ms/op
                 executeFilterQuery·p0.50:   77.332 ms/op
                 executeFilterQuery·p0.90:   79.692 ms/op
                 executeFilterQuery·p0.95:   80.740 ms/op
                 executeFilterQuery·p0.99:   87.648 ms/op
                 executeFilterQuery·p0.999:  90.046 ms/op
                 executeFilterQuery·p0.9999: 90.046 ms/op
                 executeFilterQuery·p1.00:   90.046 ms/op

Iteration   3: 75.091 ±(99.9%) 0.729 ms/op
                 executeFilterQuery·p0.00:   69.730 ms/op
                 executeFilterQuery·p0.50:   75.629 ms/op
                 executeFilterQuery·p0.90:   77.726 ms/op
                 executeFilterQuery·p0.95:   78.696 ms/op
                 executeFilterQuery·p0.99:   80.829 ms/op
                 executeFilterQuery·p0.999:  80.871 ms/op
                 executeFilterQuery·p0.9999: 80.871 ms/op
                 executeFilterQuery·p1.00:   80.871 ms/op

Iteration   4: 75.568 ±(99.9%) 0.700 ms/op
                 executeFilterQuery·p0.00:   69.861 ms/op
                 executeFilterQuery·p0.50:   76.284 ms/op
                 executeFilterQuery·p0.90:   78.106 ms/op
                 executeFilterQuery·p0.95:   78.571 ms/op
                 executeFilterQuery·p0.99:   80.144 ms/op
                 executeFilterQuery·p0.999:  80.347 ms/op
                 executeFilterQuery·p0.9999: 80.347 ms/op
                 executeFilterQuery·p1.00:   80.347 ms/op

Iteration   5: 75.464 ±(99.9%) 0.660 ms/op
                 executeFilterQuery·p0.00:   69.861 ms/op
                 executeFilterQuery·p0.50:   76.153 ms/op
                 executeFilterQuery·p0.90:   77.437 ms/op
                 executeFilterQuery·p0.95:   77.752 ms/op
                 executeFilterQuery·p0.99:   82.418 ms/op
                 executeFilterQuery·p0.999:  83.886 ms/op
                 executeFilterQuery·p0.9999: 83.886 ms/op
                 executeFilterQuery·p1.00:   83.886 ms/op


# Run progress: 38.29% complete, ETA 17:18:22
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

80.663 ±(99.9%) 2.467 ms/op
# Warmup Iteration   2: 78.751 ±(99.9%) 0.567 ms/op
# Warmup Iteration   3: 79.252 ±(99.9%) 0.760 ms/op
# Warmup Iteration   4: 80.387 ±(99.9%) 0.540 ms/op
# Warmup Iteration   5: 79.441 ±(99.9%) 0.599 ms/op
Iteration   1: 80.101 ±(99.9%) 0.614 ms/op
                 executeFilterQuery·p0.00:   73.531 ms/op
                 executeFilterQuery·p0.50:   80.478 ms/op
                 executeFilterQuery·p0.90:   81.868 ms/op
                 executeFilterQuery·p0.95:   82.392 ms/op
                 executeFilterQuery·p0.99:   83.404 ms/op
                 executeFilterQuery·p0.999:  83.624 ms/op
                 executeFilterQuery·p0.9999: 83.624 ms/op
                 executeFilterQuery·p1.00:   83.624 ms/op

Iteration   2: 77.850 ±(99.9%) 0.590 ms/op
                 executeFilterQuery·p0.00:   70.910 ms/op
                 executeFilterQuery·p0.50:   77.988 ms/op
                 executeFilterQuery·p0.90:   79.430 ms/op
                 executeFilterQuery·p0.95:   79.967 ms/op
                 executeFilterQuery·p0.99:   88.087 ms/op
                 executeFilterQuery·p0.999:  90.178 ms/op
                 executeFilterQuery·p0.9999: 90.178 ms/op
                 executeFilterQuery·p1.00:   90.178 ms/op

Iteration   3: 80.443 ±(99.9%) 0.304 ms/op
                 executeFilterQuery·p0.00:   74.842 ms/op
                 executeFilterQuery·p0.50:   80.478 ms/op
                 executeFilterQuery·p0.90:   81.527 ms/op
                 executeFilterQuery·p0.95:   81.920 ms/op
                 executeFilterQuery·p0.99:   83.296 ms/op
                 executeFilterQuery·p0.999:  83.493 ms/op
                 executeFilterQuery·p0.9999: 83.493 ms/op
                 executeFilterQuery·p1.00:   83.493 ms/op

Iteration   4: 79.897 ±(99.9%) 0.445 ms/op
                 executeFilterQuery·p0.00:   73.925 ms/op
                 executeFilterQuery·p0.50:   80.216 ms/op
                 executeFilterQuery·p0.90:   81.265 ms/op
                 executeFilterQuery·p0.95:   81.527 ms/op
                 executeFilterQuery·p0.99:   81.755 ms/op
                 executeFilterQuery·p0.999:  81.789 ms/op
                 executeFilterQuery·p0.9999: 81.789 ms/op
                 executeFilterQuery·p1.00:   81.789 ms/op

Iteration   5: 79.871 ±(99.9%) 0.499 ms/op
                 executeFilterQuery·p0.00:   73.662 ms/op
                 executeFilterQuery·p0.50:   79.954 ms/op
                 executeFilterQuery·p0.90:   81.317 ms/op
                 executeFilterQuery·p0.95:   81.881 ms/op
                 executeFilterQuery·p0.99:   86.390 ms/op
                 executeFilterQuery·p0.999:  86.901 ms/op
                 executeFilterQuery·p0.9999: 86.901 ms/op
                 executeFilterQuery·p1.00:   86.901 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 1273
  mean =     77.859 ±(99.9%) 0.270 ms/op

  Histogram, ms/op:
    [ 60.000,  62.500) = 0 
    [ 62.500,  65.000) = 0 
    [ 65.000,  67.500) = 0 
    [ 67.500,  70.000) = 15 
    [ 70.000,  72.500) = 61 
    [ 72.500,  75.000) = 141 
    [ 75.000,  77.500) = 327 
    [ 77.500,  80.000) = 379 
    [ 80.000,  82.500) = 338 
    [ 82.500,  85.000) = 9 
    [ 85.000,  87.500) = 1 
    [ 87.500,  90.000) = 0 
    [ 90.000,  92.500) = 2 
    [ 92.500,  95.000) = 0 
    [ 95.000,  97.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     69.730 ms/op
     p(50.0000) =     78.250 ms/op
     p(90.0000) =     80.871 ms/op
     p(95.0000) =     81.396 ms/op
     p(99.0000) =     82.478 ms/op
     p(99.9000) =     90.142 ms/op
     p(99.9900) =     90.178 ms/op
     p(99.9990) =     90.178 ms/op
     p(99.9999) =     90.178 ms/op
    p(100.0000) =     90.178 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/)

# Run progress: 38.61% complete, ETA 17:07:18
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

85.134 ±(99.9%) 14.455 ms/op
# Warmup Iteration   2: 79.056 ±(99.9%) 0.725 ms/op
# Warmup Iteration   3: 78.933 ±(99.9%) 0.751 ms/op
# Warmup Iteration   4: 79.696 ±(99.9%) 0.742 ms/op
# Warmup Iteration   5: 79.545 ±(99.9%) 0.724 ms/op
Iteration   1: 79.087 ±(99.9%) 0.764 ms/op
                 executeFilterQuery·p0.00:   74.187 ms/op
                 executeFilterQuery·p0.50:   80.216 ms/op
                 executeFilterQuery·p0.90:   81.527 ms/op
                 executeFilterQuery·p0.95:   81.920 ms/op
                 executeFilterQuery·p0.99:   82.541 ms/op
                 executeFilterQuery·p0.999:  82.575 ms/op
                 executeFilterQuery·p0.9999: 82.575 ms/op
                 executeFilterQuery·p1.00:   82.575 ms/op

Iteration   2: 77.645 ±(99.9%) 0.736 ms/op
                 executeFilterQuery·p0.00:   72.221 ms/op
                 executeFilterQuery·p0.50:   77.595 ms/op
                 executeFilterQuery·p0.90:   80.373 ms/op
                 executeFilterQuery·p0.95:   81.088 ms/op
                 executeFilterQuery·p0.99:   89.458 ms/op
                 executeFilterQuery·p0.999:  92.537 ms/op
                 executeFilterQuery·p0.9999: 92.537 ms/op
                 executeFilterQuery·p1.00:   92.537 ms/op

Iteration   3: 78.264 ±(99.9%) 0.794 ms/op
                 executeFilterQuery·p0.00:   71.303 ms/op
                 executeFilterQuery·p0.50:   78.578 ms/op
                 executeFilterQuery·p0.90:   81.002 ms/op
                 executeFilterQuery·p0.95:   81.396 ms/op
                 executeFilterQuery·p0.99:   84.911 ms/op
                 executeFilterQuery·p0.999:  86.114 ms/op
                 executeFilterQuery·p0.9999: 86.114 ms/op
                 executeFilterQuery·p1.00:   86.114 ms/op

Iteration   4: 78.753 ±(99.9%) 0.687 ms/op
                 executeFilterQuery·p0.00:   71.434 ms/op
                 executeFilterQuery·p0.50:   79.299 ms/op
                 executeFilterQuery·p0.90:   81.265 ms/op
                 executeFilterQuery·p0.95:   81.527 ms/op
                 executeFilterQuery·p0.99:   83.472 ms/op
                 executeFilterQuery·p0.999:  83.755 ms/op
                 executeFilterQuery·p0.9999: 83.755 ms/op
                 executeFilterQuery·p1.00:   83.755 ms/op

Iteration   5: 78.100 ±(99.9%) 0.840 ms/op
                 executeFilterQuery·p0.00:   71.434 ms/op
                 executeFilterQuery·p0.50:   78.643 ms/op
                 executeFilterQuery·p0.90:   80.898 ms/op
                 executeFilterQuery·p0.95:   81.212 ms/op
                 executeFilterQuery·p0.99:   84.243 ms/op
                 executeFilterQuery·p0.999:  85.197 ms/op
                 executeFilterQuery·p0.9999: 85.197 ms/op
                 executeFilterQuery·p1.00:   85.197 ms/op


# Run progress: 38.92% complete, ETA 16:56:22
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

81.746 ±(99.9%) 2.636 ms/op
# Warmup Iteration   2: 78.297 ±(99.9%) 0.648 ms/op
# Warmup Iteration   3: 78.689 ±(99.9%) 0.797 ms/op
# Warmup Iteration   4: 78.583 ±(99.9%) 0.885 ms/op
# Warmup Iteration   5: 79.531 ±(99.9%) 0.720 ms/op
Iteration   1: 79.635 ±(99.9%) 0.657 ms/op
                 executeFilterQuery·p0.00:   74.580 ms/op
                 executeFilterQuery·p0.50:   80.478 ms/op
                 executeFilterQuery·p0.90:   81.723 ms/op
                 executeFilterQuery·p0.95:   82.018 ms/op
                 executeFilterQuery·p0.99:   82.575 ms/op
                 executeFilterQuery·p0.999:  82.575 ms/op
                 executeFilterQuery·p0.9999: 82.575 ms/op
                 executeFilterQuery·p1.00:   82.575 ms/op

Iteration   2: 77.330 ±(99.9%) 0.667 ms/op
                 executeFilterQuery·p0.00:   72.090 ms/op
                 executeFilterQuery·p0.50:   77.726 ms/op
                 executeFilterQuery·p0.90:   79.299 ms/op
                 executeFilterQuery·p0.95:   80.413 ms/op
                 executeFilterQuery·p0.99:   86.639 ms/op
                 executeFilterQuery·p0.999:  88.605 ms/op
                 executeFilterQuery·p0.9999: 88.605 ms/op
                 executeFilterQuery·p1.00:   88.605 ms/op

Iteration   3: 79.894 ±(99.9%) 0.424 ms/op
                 executeFilterQuery·p0.00:   74.056 ms/op
                 executeFilterQuery·p0.50:   80.085 ms/op
                 executeFilterQuery·p0.90:   81.002 ms/op
                 executeFilterQuery·p0.95:   81.356 ms/op
                 executeFilterQuery·p0.99:   84.898 ms/op
                 executeFilterQuery·p0.999:  85.852 ms/op
                 executeFilterQuery·p0.9999: 85.852 ms/op
                 executeFilterQuery·p1.00:   85.852 ms/op

Iteration   4: 79.737 ±(99.9%) 0.442 ms/op
                 executeFilterQuery·p0.00:   73.794 ms/op
                 executeFilterQuery·p0.50:   80.216 ms/op
                 executeFilterQuery·p0.90:   81.134 ms/op
                 executeFilterQuery·p0.95:   81.265 ms/op
                 executeFilterQuery·p0.99:   81.886 ms/op
                 executeFilterQuery·p0.999:  81.920 ms/op
                 executeFilterQuery·p0.9999: 81.920 ms/op
                 executeFilterQuery·p1.00:   81.920 ms/op

Iteration   5: 79.681 ±(99.9%) 0.625 ms/op
                 executeFilterQuery·p0.00:   73.925 ms/op
                 executeFilterQuery·p0.50:   80.085 ms/op
                 executeFilterQuery·p0.90:   81.186 ms/op
                 executeFilterQuery·p0.95:   81.881 ms/op
                 executeFilterQuery·p0.99:   87.860 ms/op
                 executeFilterQuery·p0.999:  88.474 ms/op
                 executeFilterQuery·p0.9999: 88.474 ms/op
                 executeFilterQuery·p1.00:   88.474 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 1260
  mean =     78.803 ±(99.9%) 0.225 ms/op

  Histogram, ms/op:
    [ 70.000,  72.500) = 23 
    [ 72.500,  75.000) = 88 
    [ 75.000,  77.500) = 219 
    [ 77.500,  80.000) = 423 
    [ 80.000,  82.500) = 492 
    [ 82.500,  85.000) = 8 
    [ 85.000,  87.500) = 4 
    [ 87.500,  90.000) = 2 
    [ 90.000,  92.500) = 0 
    [ 92.500,  95.000) = 1 
    [ 95.000,  97.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     71.303 ms/op
     p(50.0000) =     79.561 ms/op
     p(90.0000) =     81.134 ms/op
     p(95.0000) =     81.527 ms/op
     p(99.0000) =     82.575 ms/op
     p(99.9000) =     91.511 ms/op
     p(99.9900) =     92.537 ms/op
     p(99.9990) =     92.537 ms/op
     p(99.9999) =     92.537 ms/op
    p(100.0000) =     92.537 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/)

# Run progress: 39.24% complete, ETA 16:45:36
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

87.609 ±(99.9%) 19.334 ms/op
# Warmup Iteration   2: 78.404 ±(99.9%) 0.590 ms/op
# Warmup Iteration   3: 79.874 ±(99.9%) 0.884 ms/op
# Warmup Iteration   4: 80.956 ±(99.9%) 0.745 ms/op
# Warmup Iteration   5: 80.408 ±(99.9%) 0.759 ms/op
Iteration   1: 80.705 ±(99.9%) 0.767 ms/op
                 executeFilterQuery·p0.00:   74.580 ms/op
                 executeFilterQuery·p0.50:   81.068 ms/op
                 executeFilterQuery·p0.90:   83.152 ms/op
                 executeFilterQuery·p0.95:   83.997 ms/op
                 executeFilterQuery·p0.99:   88.999 ms/op
                 executeFilterQuery·p0.999:  89.391 ms/op
                 executeFilterQuery·p0.9999: 89.391 ms/op
                 executeFilterQuery·p1.00:   89.391 ms/op

Iteration   2: 78.427 ±(99.9%) 0.770 ms/op
                 executeFilterQuery·p0.00:   72.876 ms/op
                 executeFilterQuery·p0.50:   78.643 ms/op
                 executeFilterQuery·p0.90:   80.478 ms/op
                 executeFilterQuery·p0.95:   81.894 ms/op
                 executeFilterQuery·p0.99:   89.412 ms/op
                 executeFilterQuery·p0.999:  90.440 ms/op
                 executeFilterQuery·p0.9999: 90.440 ms/op
                 executeFilterQuery·p1.00:   90.440 ms/op

Iteration   3: 80.504 ±(99.9%) 0.610 ms/op
                 executeFilterQuery·p0.00:   75.366 ms/op
                 executeFilterQuery·p0.50:   81.002 ms/op
                 executeFilterQuery·p0.90:   82.510 ms/op
                 executeFilterQuery·p0.95:   82.838 ms/op
                 executeFilterQuery·p0.99:   86.868 ms/op
                 executeFilterQuery·p0.999:  87.949 ms/op
                 executeFilterQuery·p0.9999: 87.949 ms/op
                 executeFilterQuery·p1.00:   87.949 ms/op

Iteration   4: 80.389 ±(99.9%) 0.694 ms/op
                 executeFilterQuery·p0.00:   74.187 ms/op
                 executeFilterQuery·p0.50:   80.871 ms/op
                 executeFilterQuery·p0.90:   82.575 ms/op
                 executeFilterQuery·p0.95:   83.067 ms/op
                 executeFilterQuery·p0.99:   88.801 ms/op
                 executeFilterQuery·p0.999:  89.260 ms/op
                 executeFilterQuery·p0.9999: 89.260 ms/op
                 executeFilterQuery·p1.00:   89.260 ms/op

Iteration   5: 80.645 ±(99.9%) 0.715 ms/op
                 executeFilterQuery·p0.00:   74.318 ms/op
                 executeFilterQuery·p0.50:   81.134 ms/op
                 executeFilterQuery·p0.90:   82.706 ms/op
                 executeFilterQuery·p0.95:   83.231 ms/op
                 executeFilterQuery·p0.99:   89.850 ms/op
                 executeFilterQuery·p0.999:  90.440 ms/op
                 executeFilterQuery·p0.9999: 90.440 ms/op
                 executeFilterQuery·p1.00:   90.440 ms/op


# Run progress: 39.56% complete, ETA 16:34:58
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

81.514 ±(99.9%) 3.102 ms/op
# Warmup Iteration   2: 79.086 ±(99.9%) 0.821 ms/op
# Warmup Iteration   3: 79.383 ±(99.9%) 0.835 ms/op
# Warmup Iteration   4: 81.210 ±(99.9%) 0.768 ms/op
# Warmup Iteration   5: 79.842 ±(99.9%) 0.890 ms/op
Iteration   1: 80.254 ±(99.9%) 0.847 ms/op
                 executeFilterQuery·p0.00:   74.580 ms/op
                 executeFilterQuery·p0.50:   81.527 ms/op
                 executeFilterQuery·p0.90:   82.654 ms/op
                 executeFilterQuery·p0.95:   82.969 ms/op
                 executeFilterQuery·p0.99:   87.378 ms/op
                 executeFilterQuery·p0.999:  88.605 ms/op
                 executeFilterQuery·p0.9999: 88.605 ms/op
                 executeFilterQuery·p1.00:   88.605 ms/op

Iteration   2: 78.904 ±(99.9%) 0.695 ms/op
                 executeFilterQuery·p0.00:   71.827 ms/op
                 executeFilterQuery·p0.50:   79.036 ms/op
                 executeFilterQuery·p0.90:   81.527 ms/op
                 executeFilterQuery·p0.95:   81.874 ms/op
                 executeFilterQuery·p0.99:   84.489 ms/op
                 executeFilterQuery·p0.999:  85.197 ms/op
                 executeFilterQuery·p0.9999: 85.197 ms/op
                 executeFilterQuery·p1.00:   85.197 ms/op

Iteration   3: 78.363 ±(99.9%) 0.691 ms/op
                 executeFilterQuery·p0.00:   71.827 ms/op
                 executeFilterQuery·p0.50:   78.840 ms/op
                 executeFilterQuery·p0.90:   79.954 ms/op
                 executeFilterQuery·p0.95:   81.258 ms/op
                 executeFilterQuery·p0.99:   86.944 ms/op
                 executeFilterQuery·p0.999:  87.687 ms/op
                 executeFilterQuery·p0.9999: 87.687 ms/op
                 executeFilterQuery·p1.00:   87.687 ms/op

Iteration   4: 77.716 ±(99.9%) 0.745 ms/op
                 executeFilterQuery·p0.00:   71.827 ms/op
                 executeFilterQuery·p0.50:   78.381 ms/op
                 executeFilterQuery·p0.90:   79.823 ms/op
                 executeFilterQuery·p0.95:   80.635 ms/op
                 executeFilterQuery·p0.99:   81.773 ms/op
                 executeFilterQuery·p0.999:  81.920 ms/op
                 executeFilterQuery·p0.9999: 81.920 ms/op
                 executeFilterQuery·p1.00:   81.920 ms/op

Iteration   5: 78.397 ±(99.9%) 0.718 ms/op
                 executeFilterQuery·p0.00:   71.959 ms/op
                 executeFilterQuery·p0.50:   78.774 ms/op
                 executeFilterQuery·p0.90:   79.941 ms/op
                 executeFilterQuery·p0.95:   80.911 ms/op
                 executeFilterQuery·p0.99:   89.091 ms/op
                 executeFilterQuery·p0.999:  90.046 ms/op
                 executeFilterQuery·p0.9999: 90.046 ms/op
                 executeFilterQuery·p1.00:   90.046 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 1249
  mean =     79.417 ±(99.9%) 0.247 ms/op

  Histogram, ms/op:
    [ 70.000,  72.500) = 32 
    [ 72.500,  75.000) = 50 
    [ 75.000,  77.500) = 125 
    [ 77.500,  80.000) = 522 
    [ 80.000,  82.500) = 432 
    [ 82.500,  85.000) = 70 
    [ 85.000,  87.500) = 8 
    [ 87.500,  90.000) = 7 
    [ 90.000,  92.500) = 3 
    [ 92.500,  95.000) = 0 
    [ 95.000,  97.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     71.827 ms/op
     p(50.0000) =     79.299 ms/op
     p(90.0000) =     82.313 ms/op
     p(95.0000) =     82.706 ms/op
     p(99.0000) =     86.770 ms/op
     p(99.9000) =     90.440 ms/op
     p(99.9900) =     90.440 ms/op
     p(99.9990) =     90.440 ms/op
     p(99.9999) =     90.440 ms/op
    p(100.0000) =     90.440 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/)

# Run progress: 39.87% complete, ETA 16:24:29
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1508.302 ±(99.9%) 4320.107 ms/op
# Warmup Iteration   2: 723.443 ±(99.9%) 11.188 ms/op
# Warmup Iteration   3: 724.266 ±(99.9%) 13.806 ms/op
# Warmup Iteration   4: 721.420 ±(99.9%) 17.987 ms/op
# Warmup Iteration   5: 740.594 ±(99.9%) 16.108 ms/op
Iteration   1: 740.744 ±(99.9%) 8.450 ms/op
                 executeFilterQuery·p0.00:   727.712 ms/op
                 executeFilterQuery·p0.50:   739.770 ms/op
                 executeFilterQuery·p0.90:   751.305 ms/op
                 executeFilterQuery·p0.95:   751.829 ms/op
                 executeFilterQuery·p0.99:   751.829 ms/op
                 executeFilterQuery·p0.999:  751.829 ms/op
                 executeFilterQuery·p0.9999: 751.829 ms/op
                 executeFilterQuery·p1.00:   751.829 ms/op

Iteration   2: 743.665 ±(99.9%) 9.141 ms/op
                 executeFilterQuery·p0.00:   728.760 ms/op
                 executeFilterQuery·p0.50:   743.440 ms/op
                 executeFilterQuery·p0.90:   755.499 ms/op
                 executeFilterQuery·p0.95:   757.072 ms/op
                 executeFilterQuery·p0.99:   757.072 ms/op
                 executeFilterQuery·p0.999:  757.072 ms/op
                 executeFilterQuery·p0.9999: 757.072 ms/op
                 executeFilterQuery·p1.00:   757.072 ms/op

Iteration   3: 744.564 ±(99.9%) 7.756 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   745.013 ms/op
                 executeFilterQuery·p0.90:   753.926 ms/op
                 executeFilterQuery·p0.95:   754.975 ms/op
                 executeFilterQuery·p0.99:   754.975 ms/op
                 executeFilterQuery·p0.999:  754.975 ms/op
                 executeFilterQuery·p0.9999: 754.975 ms/op
                 executeFilterQuery·p1.00:   754.975 ms/op

Iteration   4: 741.942 ±(99.9%) 14.388 ms/op
                 executeFilterQuery·p0.00:   731.906 ms/op
                 executeFilterQuery·p0.50:   738.722 ms/op
                 executeFilterQuery·p0.90:   765.985 ms/op
                 executeFilterQuery·p0.95:   783.286 ms/op
                 executeFilterQuery·p0.99:   783.286 ms/op
                 executeFilterQuery·p0.999:  783.286 ms/op
                 executeFilterQuery·p0.9999: 783.286 ms/op
                 executeFilterQuery·p1.00:   783.286 ms/op

Iteration   5: 747.934 ±(99.9%) 8.095 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   748.159 ms/op
                 executeFilterQuery·p0.90:   757.596 ms/op
                 executeFilterQuery·p0.95:   760.218 ms/op
                 executeFilterQuery·p0.99:   760.218 ms/op
                 executeFilterQuery·p0.999:  760.218 ms/op
                 executeFilterQuery·p0.9999: 760.218 ms/op
                 executeFilterQuery·p1.00:   760.218 ms/op


# Run progress: 40.19% complete, ETA 16:14:13
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

745.013 ±(99.9%) 46.656 ms/op
# Warmup Iteration   2: 715.503 ±(99.9%) 9.367 ms/op
# Warmup Iteration   3: 728.760 ±(99.9%) 17.185 ms/op
# Warmup Iteration   4: 716.477 ±(99.9%) 12.844 ms/op
# Warmup Iteration   5: 737.299 ±(99.9%) 6.205 ms/op
Iteration   1: 736.100 ±(99.9%) 4.401 ms/op
                 executeFilterQuery·p0.00:   730.857 ms/op
                 executeFilterQuery·p0.50:   738.198 ms/op
                 executeFilterQuery·p0.90:   740.819 ms/op
                 executeFilterQuery·p0.95:   741.343 ms/op
                 executeFilterQuery·p0.99:   741.343 ms/op
                 executeFilterQuery·p0.999:  741.343 ms/op
                 executeFilterQuery·p0.9999: 741.343 ms/op
                 executeFilterQuery·p1.00:   741.343 ms/op

Iteration   2: 743.515 ±(99.9%) 6.731 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   743.440 ms/op
                 executeFilterQuery·p0.90:   751.829 ms/op
                 executeFilterQuery·p0.95:   751.829 ms/op
                 executeFilterQuery·p0.99:   751.829 ms/op
                 executeFilterQuery·p0.999:  751.829 ms/op
                 executeFilterQuery·p0.9999: 751.829 ms/op
                 executeFilterQuery·p1.00:   751.829 ms/op

Iteration   3: 736.924 ±(99.9%) 7.469 ms/op
                 executeFilterQuery·p0.00:   724.566 ms/op
                 executeFilterQuery·p0.50:   734.527 ms/op
                 executeFilterQuery·p0.90:   747.635 ms/op
                 executeFilterQuery·p0.95:   752.878 ms/op
                 executeFilterQuery·p0.99:   752.878 ms/op
                 executeFilterQuery·p0.999:  752.878 ms/op
                 executeFilterQuery·p0.9999: 752.878 ms/op
                 executeFilterQuery·p1.00:   752.878 ms/op

Iteration   4: 744.189 ±(99.9%) 6.841 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   743.965 ms/op
                 executeFilterQuery·p0.90:   751.829 ms/op
                 executeFilterQuery·p0.95:   751.829 ms/op
                 executeFilterQuery·p0.99:   751.829 ms/op
                 executeFilterQuery·p0.999:  751.829 ms/op
                 executeFilterQuery·p0.9999: 751.829 ms/op
                 executeFilterQuery·p1.00:   751.829 ms/op

Iteration   5: 742.691 ±(99.9%) 7.852 ms/op
                 executeFilterQuery·p0.00:   730.857 ms/op
                 executeFilterQuery·p0.50:   742.916 ms/op
                 executeFilterQuery·p0.90:   753.402 ms/op
                 executeFilterQuery·p0.95:   756.023 ms/op
                 executeFilterQuery·p0.99:   756.023 ms/op
                 executeFilterQuery·p0.999:  756.023 ms/op
                 executeFilterQuery·p0.9999: 756.023 ms/op
                 executeFilterQuery·p1.00:   756.023 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 140
  mean =    742.227 ±(99.9%) 2.275 ms/op

  Histogram, ms/op:
    [720.000, 725.000) = 1 
    [725.000, 730.000) = 3 
    [730.000, 735.000) = 24 
    [735.000, 740.000) = 28 
    [740.000, 745.000) = 38 
    [745.000, 750.000) = 23 
    [750.000, 755.000) = 19 
    [755.000, 760.000) = 2 
    [760.000, 765.000) = 1 
    [765.000, 770.000) = 0 
    [770.000, 775.000) = 0 
    [775.000, 780.000) = 0 
    [780.000, 785.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    724.566 ms/op
     p(50.0000) =    741.343 ms/op
     p(90.0000) =    751.829 ms/op
     p(95.0000) =    754.922 ms/op
     p(99.0000) =    773.828 ms/op
     p(99.9000) =    783.286 ms/op
     p(99.9900) =    783.286 ms/op
     p(99.9990) =    783.286 ms/op
     p(99.9999) =    783.286 ms/op
    p(100.0000) =    783.286 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/)

# Run progress: 40.51% complete, ETA 16:04:04
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

2032.979 ±(99.9%) 10244.247 ms/op
# Warmup Iteration   2: 724.791 ±(99.9%) 17.546 ms/op
# Warmup Iteration   3: 719.024 ±(99.9%) 7.088 ms/op
# Warmup Iteration   4: 727.412 ±(99.9%) 14.682 ms/op
# Warmup Iteration   5: 734.378 ±(99.9%) 18.804 ms/op
Iteration   1: 743.440 ±(99.9%) 4.954 ms/op
                 executeFilterQuery·p0.00:   736.100 ms/op
                 executeFilterQuery·p0.50:   742.916 ms/op
                 executeFilterQuery·p0.90:   751.305 ms/op
                 executeFilterQuery·p0.95:   753.926 ms/op
                 executeFilterQuery·p0.99:   753.926 ms/op
                 executeFilterQuery·p0.999:  753.926 ms/op
                 executeFilterQuery·p0.9999: 753.926 ms/op
                 executeFilterQuery·p1.00:   753.926 ms/op

Iteration   2: 743.066 ±(99.9%) 4.879 ms/op
                 executeFilterQuery·p0.00:   736.100 ms/op
                 executeFilterQuery·p0.50:   743.440 ms/op
                 executeFilterQuery·p0.90:   749.732 ms/op
                 executeFilterQuery·p0.95:   751.829 ms/op
                 executeFilterQuery·p0.99:   751.829 ms/op
                 executeFilterQuery·p0.999:  751.829 ms/op
                 executeFilterQuery·p0.9999: 751.829 ms/op
                 executeFilterQuery·p1.00:   751.829 ms/op

Iteration   3: 742.467 ±(99.9%) 7.473 ms/op
                 executeFilterQuery·p0.00:   735.052 ms/op
                 executeFilterQuery·p0.50:   742.392 ms/op
                 executeFilterQuery·p0.90:   753.926 ms/op
                 executeFilterQuery·p0.95:   753.926 ms/op
                 executeFilterQuery·p0.99:   753.926 ms/op
                 executeFilterQuery·p0.999:  753.926 ms/op
                 executeFilterQuery·p0.9999: 753.926 ms/op
                 executeFilterQuery·p1.00:   753.926 ms/op

Iteration   4: 746.212 ±(99.9%) 7.547 ms/op
                 executeFilterQuery·p0.00:   736.100 ms/op
                 executeFilterQuery·p0.50:   747.110 ms/op
                 executeFilterQuery·p0.90:   754.975 ms/op
                 executeFilterQuery·p0.95:   754.975 ms/op
                 executeFilterQuery·p0.99:   754.975 ms/op
                 executeFilterQuery·p0.999:  754.975 ms/op
                 executeFilterQuery·p0.9999: 754.975 ms/op
                 executeFilterQuery·p1.00:   754.975 ms/op

Iteration   5: 747.485 ±(99.9%) 7.692 ms/op
                 executeFilterQuery·p0.00:   736.100 ms/op
                 executeFilterQuery·p0.50:   747.110 ms/op
                 executeFilterQuery·p0.90:   756.023 ms/op
                 executeFilterQuery·p0.95:   756.023 ms/op
                 executeFilterQuery·p0.99:   756.023 ms/op
                 executeFilterQuery·p0.999:  756.023 ms/op
                 executeFilterQuery·p0.9999: 756.023 ms/op
                 executeFilterQuery·p1.00:   756.023 ms/op


# Run progress: 40.82% complete, ETA 15:54:03
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

740.220 ±(99.9%) 49.796 ms/op
# Warmup Iteration   2: 709.816 ±(99.9%) 7.108 ms/op
# Warmup Iteration   3: 724.491 ±(99.9%) 21.339 ms/op
# Warmup Iteration   4: 723.817 ±(99.9%) 15.900 ms/op
# Warmup Iteration   5: 738.347 ±(99.9%) 9.507 ms/op
Iteration   1: 740.220 ±(99.9%) 8.760 ms/op
                 executeFilterQuery·p0.00:   729.809 ms/op
                 executeFilterQuery·p0.50:   738.198 ms/op
                 executeFilterQuery·p0.90:   754.975 ms/op
                 executeFilterQuery·p0.95:   757.072 ms/op
                 executeFilterQuery·p0.99:   757.072 ms/op
                 executeFilterQuery·p0.999:  757.072 ms/op
                 executeFilterQuery·p0.9999: 757.072 ms/op
                 executeFilterQuery·p1.00:   757.072 ms/op

Iteration   2: 741.718 ±(99.9%) 6.505 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   741.343 ms/op
                 executeFilterQuery·p0.90:   751.305 ms/op
                 executeFilterQuery·p0.95:   754.975 ms/op
                 executeFilterQuery·p0.99:   754.975 ms/op
                 executeFilterQuery·p0.999:  754.975 ms/op
                 executeFilterQuery·p0.9999: 754.975 ms/op
                 executeFilterQuery·p1.00:   754.975 ms/op

Iteration   3: 730.783 ±(99.9%) 8.357 ms/op
                 executeFilterQuery·p0.00:   724.566 ms/op
                 executeFilterQuery·p0.50:   727.712 ms/op
                 executeFilterQuery·p0.90:   745.538 ms/op
                 executeFilterQuery·p0.95:   747.635 ms/op
                 executeFilterQuery·p0.99:   747.635 ms/op
                 executeFilterQuery·p0.999:  747.635 ms/op
                 executeFilterQuery·p0.9999: 747.635 ms/op
                 executeFilterQuery·p1.00:   747.635 ms/op

Iteration   4: 738.123 ±(99.9%) 7.811 ms/op
                 executeFilterQuery·p0.00:   724.566 ms/op
                 executeFilterQuery·p0.50:   738.722 ms/op
                 executeFilterQuery·p0.90:   747.110 ms/op
                 executeFilterQuery·p0.95:   748.683 ms/op
                 executeFilterQuery·p0.99:   748.683 ms/op
                 executeFilterQuery·p0.999:  748.683 ms/op
                 executeFilterQuery·p0.9999: 748.683 ms/op
                 executeFilterQuery·p1.00:   748.683 ms/op

Iteration   5: 743.365 ±(99.9%) 5.986 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   744.489 ms/op
                 executeFilterQuery·p0.90:   751.829 ms/op
                 executeFilterQuery·p0.95:   753.926 ms/op
                 executeFilterQuery·p0.99:   753.926 ms/op
                 executeFilterQuery·p0.999:  753.926 ms/op
                 executeFilterQuery·p0.9999: 753.926 ms/op
                 executeFilterQuery·p1.00:   753.926 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 140
  mean =    741.688 ±(99.9%) 2.144 ms/op

  Histogram, ms/op:
    [720.000, 722.500) = 0 
    [722.500, 725.000) = 3 
    [725.000, 727.500) = 4 
    [727.500, 730.000) = 5 
    [730.000, 732.500) = 4 
    [732.500, 735.000) = 4 
    [735.000, 737.500) = 22 
    [737.500, 740.000) = 14 
    [740.000, 742.500) = 22 
    [742.500, 745.000) = 16 
    [745.000, 747.500) = 16 
    [747.500, 750.000) = 11 
    [750.000, 752.500) = 4 
    [752.500, 755.000) = 11 
    [755.000, 757.500) = 4 

  Percentiles, ms/op:
      p(0.0000) =    724.566 ms/op
     p(50.0000) =    742.392 ms/op
     p(90.0000) =    752.878 ms/op
     p(95.0000) =    754.922 ms/op
     p(99.0000) =    756.642 ms/op
     p(99.9000) =    757.072 ms/op
     p(99.9900) =    757.072 ms/op
     p(99.9990) =    757.072 ms/op
     p(99.9999) =    757.072 ms/op
    p(100.0000) =    757.072 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/)

# Run progress: 41.14% complete, ETA 15:44:10
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

2038.432 ±(99.9%) 10179.659 ms/op
# Warmup Iteration   2: 724.566 ±(99.9%) 11.374 ms/op
# Warmup Iteration   3: 717.001 ±(99.9%) 7.160 ms/op
# Warmup Iteration   4: 730.034 ±(99.9%) 14.158 ms/op
# Warmup Iteration   5: 732.355 ±(99.9%) 21.501 ms/op
Iteration   1: 744.040 ±(99.9%) 8.981 ms/op
                 executeFilterQuery·p0.00:   735.052 ms/op
                 executeFilterQuery·p0.50:   741.868 ms/op
                 executeFilterQuery·p0.90:   758.645 ms/op
                 executeFilterQuery·p0.95:   760.218 ms/op
                 executeFilterQuery·p0.99:   760.218 ms/op
                 executeFilterQuery·p0.999:  760.218 ms/op
                 executeFilterQuery·p0.9999: 760.218 ms/op
                 executeFilterQuery·p1.00:   760.218 ms/op

Iteration   2: 739.246 ±(99.9%) 5.720 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   737.149 ms/op
                 executeFilterQuery·p0.90:   748.159 ms/op
                 executeFilterQuery·p0.95:   748.683 ms/op
                 executeFilterQuery·p0.99:   748.683 ms/op
                 executeFilterQuery·p0.999:  748.683 ms/op
                 executeFilterQuery·p0.9999: 748.683 ms/op
                 executeFilterQuery·p1.00:   748.683 ms/op

Iteration   3: 745.463 ±(99.9%) 8.069 ms/op
                 executeFilterQuery·p0.00:   735.052 ms/op
                 executeFilterQuery·p0.50:   747.110 ms/op
                 executeFilterQuery·p0.90:   754.450 ms/op
                 executeFilterQuery·p0.95:   756.023 ms/op
                 executeFilterQuery·p0.99:   756.023 ms/op
                 executeFilterQuery·p0.999:  756.023 ms/op
                 executeFilterQuery·p0.9999: 756.023 ms/op
                 executeFilterQuery·p1.00:   756.023 ms/op

Iteration   4: 748.234 ±(99.9%) 6.220 ms/op
                 executeFilterQuery·p0.00:   739.246 ms/op
                 executeFilterQuery·p0.50:   748.683 ms/op
                 executeFilterQuery·p0.90:   757.596 ms/op
                 executeFilterQuery·p0.95:   759.169 ms/op
                 executeFilterQuery·p0.99:   759.169 ms/op
                 executeFilterQuery·p0.999:  759.169 ms/op
                 executeFilterQuery·p0.9999: 759.169 ms/op
                 executeFilterQuery·p1.00:   759.169 ms/op

Iteration   5: 743.740 ±(99.9%) 6.634 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   743.440 ms/op
                 executeFilterQuery·p0.90:   753.926 ms/op
                 executeFilterQuery·p0.95:   758.120 ms/op
                 executeFilterQuery·p0.99:   758.120 ms/op
                 executeFilterQuery·p0.999:  758.120 ms/op
                 executeFilterQuery·p0.9999: 758.120 ms/op
                 executeFilterQuery·p1.00:   758.120 ms/op


# Run progress: 41.46% complete, ETA 15:34:24
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

762.390 ±(99.9%) 79.704 ms/op
# Warmup Iteration   2: 719.548 ±(99.9%) 11.628 ms/op
# Warmup Iteration   3: 738.422 ±(99.9%) 17.416 ms/op
# Warmup Iteration   4: 716.702 ±(99.9%) 8.073 ms/op
# Warmup Iteration   5: 742.467 ±(99.9%) 15.523 ms/op
Iteration   1: 745.687 ±(99.9%) 6.785 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   746.586 ms/op
                 executeFilterQuery·p0.90:   753.926 ms/op
                 executeFilterQuery·p0.95:   754.975 ms/op
                 executeFilterQuery·p0.99:   754.975 ms/op
                 executeFilterQuery·p0.999:  754.975 ms/op
                 executeFilterQuery·p0.9999: 754.975 ms/op
                 executeFilterQuery·p1.00:   754.975 ms/op

Iteration   2: 747.185 ±(99.9%) 6.491 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   747.635 ms/op
                 executeFilterQuery·p0.90:   753.402 ms/op
                 executeFilterQuery·p0.95:   753.926 ms/op
                 executeFilterQuery·p0.99:   753.926 ms/op
                 executeFilterQuery·p0.999:  753.926 ms/op
                 executeFilterQuery·p0.9999: 753.926 ms/op
                 executeFilterQuery·p1.00:   753.926 ms/op

Iteration   3: 750.331 ±(99.9%) 6.080 ms/op
                 executeFilterQuery·p0.00:   745.538 ms/op
                 executeFilterQuery·p0.50:   748.683 ms/op
                 executeFilterQuery·p0.90:   759.693 ms/op
                 executeFilterQuery·p0.95:   766.509 ms/op
                 executeFilterQuery·p0.99:   766.509 ms/op
                 executeFilterQuery·p0.999:  766.509 ms/op
                 executeFilterQuery·p0.9999: 766.509 ms/op
                 executeFilterQuery·p1.00:   766.509 ms/op

Iteration   4: 748.533 ±(99.9%) 4.223 ms/op
                 executeFilterQuery·p0.00:   742.392 ms/op
                 executeFilterQuery·p0.50:   746.586 ms/op
                 executeFilterQuery·p0.90:   754.975 ms/op
                 executeFilterQuery·p0.95:   754.975 ms/op
                 executeFilterQuery·p0.99:   754.975 ms/op
                 executeFilterQuery·p0.999:  754.975 ms/op
                 executeFilterQuery·p0.9999: 754.975 ms/op
                 executeFilterQuery·p1.00:   754.975 ms/op

Iteration   5: 751.904 ±(99.9%) 5.007 ms/op
                 executeFilterQuery·p0.00:   746.586 ms/op
                 executeFilterQuery·p0.50:   751.305 ms/op
                 executeFilterQuery·p0.90:   759.693 ms/op
                 executeFilterQuery·p0.95:   762.315 ms/op
                 executeFilterQuery·p0.99:   762.315 ms/op
                 executeFilterQuery·p0.999:  762.315 ms/op
                 executeFilterQuery·p0.9999: 762.315 ms/op
                 executeFilterQuery·p1.00:   762.315 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 140
  mean =    746.436 ±(99.9%) 1.876 ms/op

  Histogram, ms/op:
    [730.000, 732.500) = 0 
    [732.500, 735.000) = 4 
    [735.000, 737.500) = 16 
    [737.500, 740.000) = 5 
    [740.000, 742.500) = 17 
    [742.500, 745.000) = 6 
    [745.000, 747.500) = 26 
    [747.500, 750.000) = 26 
    [750.000, 752.500) = 14 
    [752.500, 755.000) = 17 
    [755.000, 757.500) = 4 
    [757.500, 760.000) = 2 
    [760.000, 762.500) = 2 
    [762.500, 765.000) = 0 
    [765.000, 767.500) = 1 

  Percentiles, ms/op:
      p(0.0000) =    734.003 ms/op
     p(50.0000) =    746.586 ms/op
     p(90.0000) =    753.926 ms/op
     p(95.0000) =    757.019 ms/op
     p(99.0000) =    764.789 ms/op
     p(99.9000) =    766.509 ms/op
     p(99.9900) =    766.509 ms/op
     p(99.9990) =    766.509 ms/op
     p(99.9999) =    766.509 ms/op
    p(100.0000) =    766.509 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/)

# Run progress: 41.77% complete, ETA 15:24:46
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

13438.550 ms/op
# Warmup Iteration   2: 1465.010 ±(99.9%) 394.750 ms/op
# Warmup Iteration   3: 1361.052 ±(99.9%) 26.684 ms/op
# Warmup Iteration   4: 1378.353 ±(99.9%) 55.467 ms/op
# Warmup Iteration   5: 1417.675 ±(99.9%) 44.444 ms/op
Iteration   1: 1426.962 ±(99.9%) 18.264 ms/op
                 executeFilterQuery·p0.00:   1415.578 ms/op
                 executeFilterQuery·p0.50:   1430.258 ms/op
                 executeFilterQuery·p0.90:   1438.646 ms/op
                 executeFilterQuery·p0.95:   1438.646 ms/op
                 executeFilterQuery·p0.99:   1438.646 ms/op
                 executeFilterQuery·p0.999:  1438.646 ms/op
                 executeFilterQuery·p0.9999: 1438.646 ms/op
                 executeFilterQuery·p1.00:   1438.646 ms/op

Iteration   2: 1417.150 ±(99.9%) 25.786 ms/op
                 executeFilterQuery·p0.00:   1398.800 ms/op
                 executeFilterQuery·p0.50:   1419.772 ms/op
                 executeFilterQuery·p0.90:   1434.452 ms/op
                 executeFilterQuery·p0.95:   1434.452 ms/op
                 executeFilterQuery·p0.99:   1434.452 ms/op
                 executeFilterQuery·p0.999:  1434.452 ms/op
                 executeFilterQuery·p0.9999: 1434.452 ms/op
                 executeFilterQuery·p1.00:   1434.452 ms/op

Iteration   3: 1421.345 ±(99.9%) 26.576 ms/op
                 executeFilterQuery·p0.00:   1394.606 ms/op
                 executeFilterQuery·p0.50:   1423.966 ms/op
                 executeFilterQuery·p0.90:   1436.549 ms/op
                 executeFilterQuery·p0.95:   1436.549 ms/op
                 executeFilterQuery·p0.99:   1436.549 ms/op
                 executeFilterQuery·p0.999:  1436.549 ms/op
                 executeFilterQuery·p0.9999: 1436.549 ms/op
                 executeFilterQuery·p1.00:   1436.549 ms/op

Iteration   4: 1412.956 ±(99.9%) 28.494 ms/op
                 executeFilterQuery·p0.00:   1392.509 ms/op
                 executeFilterQuery·p0.50:   1412.432 ms/op
                 executeFilterQuery·p0.90:   1430.258 ms/op
                 executeFilterQuery·p0.95:   1430.258 ms/op
                 executeFilterQuery·p0.99:   1430.258 ms/op
                 executeFilterQuery·p0.999:  1430.258 ms/op
                 executeFilterQuery·p0.9999: 1430.258 ms/op
                 executeFilterQuery·p1.00:   1430.258 ms/op

Iteration   5: 1403.257 ±(99.9%) 29.732 ms/op
                 executeFilterQuery·p0.00:   1388.315 ms/op
                 executeFilterQuery·p0.50:   1397.752 ms/op
                 executeFilterQuery·p0.90:   1430.258 ms/op
                 executeFilterQuery·p0.95:   1430.258 ms/op
                 executeFilterQuery·p0.99:   1430.258 ms/op
                 executeFilterQuery·p0.999:  1430.258 ms/op
                 executeFilterQuery·p0.9999: 1430.258 ms/op
                 executeFilterQuery·p1.00:   1430.258 ms/op


# Run progress: 42.09% complete, ETA 15:15:28
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1441.343 ±(99.9%) 195.786 ms/op
# Warmup Iteration   2: 1376.518 ±(99.9%) 31.713 ms/op
# Warmup Iteration   3: 1397.228 ±(99.9%) 53.700 ms/op
# Warmup Iteration   4: 1401.422 ±(99.9%) 67.937 ms/op
# Warmup Iteration   5: 1430.857 ±(99.9%) 46.655 ms/op
Iteration   1: 1424.865 ±(99.9%) 10.859 ms/op
                 executeFilterQuery·p0.00:   1419.772 ms/op
                 executeFilterQuery·p0.50:   1423.966 ms/op
                 executeFilterQuery·p0.90:   1434.452 ms/op
                 executeFilterQuery·p0.95:   1434.452 ms/op
                 executeFilterQuery·p0.99:   1434.452 ms/op
                 executeFilterQuery·p0.999:  1434.452 ms/op
                 executeFilterQuery·p0.9999: 1434.452 ms/op
                 executeFilterQuery·p1.00:   1434.452 ms/op

Iteration   2: 1435.051 ±(99.9%) 26.258 ms/op
                 executeFilterQuery·p0.00:   1421.869 ms/op
                 executeFilterQuery·p0.50:   1438.646 ms/op
                 executeFilterQuery·p0.90:   1449.132 ms/op
                 executeFilterQuery·p0.95:   1449.132 ms/op
                 executeFilterQuery·p0.99:   1449.132 ms/op
                 executeFilterQuery·p0.999:  1449.132 ms/op
                 executeFilterQuery·p0.9999: 1449.132 ms/op
                 executeFilterQuery·p1.00:   1449.132 ms/op

Iteration   3: 1424.490 ±(99.9%) 18.406 ms/op
                 executeFilterQuery·p0.00:   1413.480 ms/op
                 executeFilterQuery·p0.50:   1423.966 ms/op
                 executeFilterQuery·p0.90:   1438.646 ms/op
                 executeFilterQuery·p0.95:   1438.646 ms/op
                 executeFilterQuery·p0.99:   1438.646 ms/op
                 executeFilterQuery·p0.999:  1438.646 ms/op
                 executeFilterQuery·p0.9999: 1438.646 ms/op
                 executeFilterQuery·p1.00:   1438.646 ms/op

Iteration   4: 1419.510 ±(99.9%) 16.799 ms/op
                 executeFilterQuery·p0.00:   1409.286 ms/op
                 executeFilterQuery·p0.50:   1417.675 ms/op
                 executeFilterQuery·p0.90:   1438.646 ms/op
                 executeFilterQuery·p0.95:   1438.646 ms/op
                 executeFilterQuery·p0.99:   1438.646 ms/op
                 executeFilterQuery·p0.999:  1438.646 ms/op
                 executeFilterQuery·p0.9999: 1438.646 ms/op
                 executeFilterQuery·p1.00:   1438.646 ms/op

Iteration   5: 1428.161 ±(99.9%) 22.815 ms/op
                 executeFilterQuery·p0.00:   1411.383 ms/op
                 executeFilterQuery·p0.50:   1430.258 ms/op
                 executeFilterQuery·p0.90:   1438.646 ms/op
                 executeFilterQuery·p0.95:   1438.646 ms/op
                 executeFilterQuery·p0.99:   1438.646 ms/op
                 executeFilterQuery·p0.999:  1438.646 ms/op
                 executeFilterQuery·p0.9999: 1438.646 ms/op
                 executeFilterQuery·p1.00:   1438.646 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 76
  mean =   1420.986 ±(99.9%) 5.443 ms/op

  Histogram, ms/op:
    [1380.000, 1385.000) = 0 
    [1385.000, 1390.000) = 1 
    [1390.000, 1395.000) = 6 
    [1395.000, 1400.000) = 1 
    [1400.000, 1405.000) = 3 
    [1405.000, 1410.000) = 3 
    [1410.000, 1415.000) = 6 
    [1415.000, 1420.000) = 11 
    [1420.000, 1425.000) = 13 
    [1425.000, 1430.000) = 8 
    [1430.000, 1435.000) = 13 
    [1435.000, 1440.000) = 8 
    [1440.000, 1445.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   1388.315 ms/op
     p(50.0000) =   1421.869 ms/op
     p(90.0000) =   1438.646 ms/op
     p(95.0000) =   1438.961 ms/op
     p(99.0000) =   1449.132 ms/op
     p(99.9000) =   1449.132 ms/op
     p(99.9900) =   1449.132 ms/op
     p(99.9990) =   1449.132 ms/op
     p(99.9999) =   1449.132 ms/op
    p(100.0000) =   1449.132 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/)

# Run progress: 42.41% complete, ETA 15:06:07
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

13388.218 ms/op
# Warmup Iteration   2: 1504.557 ±(99.9%) 376.103 ms/op
# Warmup Iteration   3: 1405.878 ±(99.9%) 27.190 ms/op
# Warmup Iteration   4: 1415.053 ±(99.9%) 56.126 ms/op
# Warmup Iteration   5: 1436.849 ±(99.9%) 86.854 ms/op
Iteration   1: 1479.391 ±(99.9%) 28.189 ms/op
                 executeFilterQuery·p0.00:   1455.423 ms/op
                 executeFilterQuery·p0.50:   1482.686 ms/op
                 executeFilterQuery·p0.90:   1491.075 ms/op
                 executeFilterQuery·p0.95:   1491.075 ms/op
                 executeFilterQuery·p0.99:   1491.075 ms/op
                 executeFilterQuery·p0.999:  1491.075 ms/op
                 executeFilterQuery·p0.9999: 1491.075 ms/op
                 executeFilterQuery·p1.00:   1491.075 ms/op

Iteration   2: 1465.010 ±(99.9%) 19.447 ms/op
                 executeFilterQuery·p0.00:   1455.423 ms/op
                 executeFilterQuery·p0.50:   1465.909 ms/op
                 executeFilterQuery·p0.90:   1480.589 ms/op
                 executeFilterQuery·p0.95:   1480.589 ms/op
                 executeFilterQuery·p0.99:   1480.589 ms/op
                 executeFilterQuery·p0.999:  1480.589 ms/op
                 executeFilterQuery·p0.9999: 1480.589 ms/op
                 executeFilterQuery·p1.00:   1480.589 ms/op

Iteration   3: 1470.104 ±(99.9%) 12.791 ms/op
                 executeFilterQuery·p0.00:   1459.618 ms/op
                 executeFilterQuery·p0.50:   1470.104 ms/op
                 executeFilterQuery·p0.90:   1478.492 ms/op
                 executeFilterQuery·p0.95:   1478.492 ms/op
                 executeFilterQuery·p0.99:   1478.492 ms/op
                 executeFilterQuery·p0.999:  1478.492 ms/op
                 executeFilterQuery·p0.9999: 1478.492 ms/op
                 executeFilterQuery·p1.00:   1478.492 ms/op

Iteration   4: 2414.721 ±(99.9%) 5599.676 ms/op
                 executeFilterQuery·p0.00:   1461.715 ms/op
                 executeFilterQuery·p0.50:   1480.589 ms/op
                 executeFilterQuery·p0.90:   8053.064 ms/op
                 executeFilterQuery·p0.95:   8053.064 ms/op
                 executeFilterQuery·p0.99:   8053.064 ms/op
                 executeFilterQuery·p0.999:  8053.064 ms/op
                 executeFilterQuery·p0.9999: 8053.064 ms/op
                 executeFilterQuery·p1.00:   8053.064 ms/op

Iteration   5: 1454.525 ±(99.9%) 38.840 ms/op
                 executeFilterQuery·p0.00:   1438.646 ms/op
                 executeFilterQuery·p0.50:   1442.841 ms/op
                 executeFilterQuery·p0.90:   1474.298 ms/op
                 executeFilterQuery·p0.95:   1474.298 ms/op
                 executeFilterQuery·p0.99:   1474.298 ms/op
                 executeFilterQuery·p0.999:  1474.298 ms/op
                 executeFilterQuery·p0.9999: 1474.298 ms/op
                 executeFilterQuery·p1.00:   1474.298 ms/op


# Run progress: 42.72% complete, ETA 14:57:05
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1470.703 ±(99.9%) 170.184 ms/op
# Warmup Iteration   2: 1403.781 ±(99.9%) 22.574 ms/op
# Warmup Iteration   3: 1428.460 ±(99.9%) 61.307 ms/op
# Warmup Iteration   4: 1412.170 ±(99.9%) 56.460 ms/op
# Warmup Iteration   5: 1455.124 ±(99.9%) 34.107 ms/op
Iteration   1: 1440.444 ±(99.9%) 21.373 ms/op
                 executeFilterQuery·p0.00:   1432.355 ms/op
                 executeFilterQuery·p0.50:   1436.549 ms/op
                 executeFilterQuery·p0.90:   1459.618 ms/op
                 executeFilterQuery·p0.95:   1459.618 ms/op
                 executeFilterQuery·p0.99:   1459.618 ms/op
                 executeFilterQuery·p0.999:  1459.618 ms/op
                 executeFilterQuery·p0.9999: 1459.618 ms/op
                 executeFilterQuery·p1.00:   1459.618 ms/op

Iteration   2: 1450.630 ±(99.9%) 45.770 ms/op
                 executeFilterQuery·p0.00:   1430.258 ms/op
                 executeFilterQuery·p0.50:   1444.938 ms/op
                 executeFilterQuery·p0.90:   1484.784 ms/op
                 executeFilterQuery·p0.95:   1484.784 ms/op
                 executeFilterQuery·p0.99:   1484.784 ms/op
                 executeFilterQuery·p0.999:  1484.784 ms/op
                 executeFilterQuery·p0.9999: 1484.784 ms/op
                 executeFilterQuery·p1.00:   1484.784 ms/op

Iteration   3: 1452.727 ±(99.9%) 32.001 ms/op
                 executeFilterQuery·p0.00:   1434.452 ms/op
                 executeFilterQuery·p0.50:   1451.229 ms/op
                 executeFilterQuery·p0.90:   1470.104 ms/op
                 executeFilterQuery·p0.95:   1470.104 ms/op
                 executeFilterQuery·p0.99:   1470.104 ms/op
                 executeFilterQuery·p0.999:  1470.104 ms/op
                 executeFilterQuery·p0.9999: 1470.104 ms/op
                 executeFilterQuery·p1.00:   1470.104 ms/op

Iteration   4: 1453.326 ±(99.9%) 23.616 ms/op
                 executeFilterQuery·p0.00:   1440.743 ms/op
                 executeFilterQuery·p0.50:   1453.326 ms/op
                 executeFilterQuery·p0.90:   1468.006 ms/op
                 executeFilterQuery·p0.95:   1468.006 ms/op
                 executeFilterQuery·p0.99:   1468.006 ms/op
                 executeFilterQuery·p0.999:  1468.006 ms/op
                 executeFilterQuery·p0.9999: 1468.006 ms/op
                 executeFilterQuery·p1.00:   1468.006 ms/op

Iteration   5: 1455.423 ±(99.9%) 24.238 ms/op
                 executeFilterQuery·p0.00:   1442.841 ms/op
                 executeFilterQuery·p0.50:   1455.423 ms/op
                 executeFilterQuery·p0.90:   1470.104 ms/op
                 executeFilterQuery·p0.95:   1470.104 ms/op
                 executeFilterQuery·p0.99:   1470.104 ms/op
                 executeFilterQuery·p0.999:  1470.104 ms/op
                 executeFilterQuery·p0.9999: 1470.104 ms/op
                 executeFilterQuery·p1.00:   1470.104 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 70
  mean =   1553.630 ±(99.9%) 323.835 ms/op

  Histogram, ms/op:
    [1000.000, 1500.000) = 69 
    [1500.000, 2000.000) = 0 
    [2000.000, 2500.000) = 0 
    [2500.000, 3000.000) = 0 
    [3000.000, 3500.000) = 0 
    [3500.000, 4000.000) = 0 
    [4000.000, 4500.000) = 0 
    [4500.000, 5000.000) = 0 
    [5000.000, 5500.000) = 0 
    [5500.000, 6000.000) = 0 
    [6000.000, 6500.000) = 0 
    [6500.000, 7000.000) = 0 
    [7000.000, 7500.000) = 0 
    [7500.000, 8000.000) = 0 
    [8000.000, 8500.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   1430.258 ms/op
     p(50.0000) =   1461.715 ms/op
     p(90.0000) =   1482.477 ms/op
     p(95.0000) =   1487.615 ms/op
     p(99.0000) =   8053.064 ms/op
     p(99.9000) =   8053.064 ms/op
     p(99.9900) =   8053.064 ms/op
     p(99.9990) =   8053.064 ms/op
     p(99.9999) =   8053.064 ms/op
    p(100.0000) =   8053.064 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/)

# Run progress: 43.04% complete, ETA 14:47:54
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

13220.446 ms/op
# Warmup Iteration   2: 1546.799 ±(99.9%) 383.164 ms/op
# Warmup Iteration   3: 1418.723 ±(99.9%) 22.984 ms/op
# Warmup Iteration   4: 1448.832 ±(99.9%) 72.325 ms/op
# Warmup Iteration   5: 1437.148 ±(99.9%) 67.501 ms/op
Iteration   1: 1493.771 ±(99.9%) 12.707 ms/op
                 executeFilterQuery·p0.00:   1488.978 ms/op
                 executeFilterQuery·p0.50:   1491.075 ms/op
                 executeFilterQuery·p0.90:   1503.658 ms/op
                 executeFilterQuery·p0.95:   1503.658 ms/op
                 executeFilterQuery·p0.99:   1503.658 ms/op
                 executeFilterQuery·p0.999:  1503.658 ms/op
                 executeFilterQuery·p0.9999: 1503.658 ms/op
                 executeFilterQuery·p1.00:   1503.658 ms/op

Iteration   2: 1500.063 ±(99.9%) 42.221 ms/op
                 executeFilterQuery·p0.00:   1480.589 ms/op
                 executeFilterQuery·p0.50:   1491.075 ms/op
                 executeFilterQuery·p0.90:   1528.824 ms/op
                 executeFilterQuery·p0.95:   1528.824 ms/op
                 executeFilterQuery·p0.99:   1528.824 ms/op
                 executeFilterQuery·p0.999:  1528.824 ms/op
                 executeFilterQuery·p0.9999: 1528.824 ms/op
                 executeFilterQuery·p1.00:   1528.824 ms/op

Iteration   3: 1489.577 ±(99.9%) 24.801 ms/op
                 executeFilterQuery·p0.00:   1478.492 ms/op
                 executeFilterQuery·p0.50:   1488.978 ms/op
                 executeFilterQuery·p0.90:   1512.047 ms/op
                 executeFilterQuery·p0.95:   1512.047 ms/op
                 executeFilterQuery·p0.99:   1512.047 ms/op
                 executeFilterQuery·p0.999:  1512.047 ms/op
                 executeFilterQuery·p0.9999: 1512.047 ms/op
                 executeFilterQuery·p1.00:   1512.047 ms/op

Iteration   4: 1482.986 ±(99.9%) 5.049 ms/op
                 executeFilterQuery·p0.00:   1478.492 ms/op
                 executeFilterQuery·p0.50:   1482.686 ms/op
                 executeFilterQuery·p0.90:   1484.784 ms/op
                 executeFilterQuery·p0.95:   1484.784 ms/op
                 executeFilterQuery·p0.99:   1484.784 ms/op
                 executeFilterQuery·p0.999:  1484.784 ms/op
                 executeFilterQuery·p0.9999: 1484.784 ms/op
                 executeFilterQuery·p1.00:   1484.784 ms/op

Iteration   5: 1484.184 ±(99.9%) 8.926 ms/op
                 executeFilterQuery·p0.00:   1478.492 ms/op
                 executeFilterQuery·p0.50:   1484.784 ms/op
                 executeFilterQuery·p0.90:   1488.978 ms/op
                 executeFilterQuery·p0.95:   1488.978 ms/op
                 executeFilterQuery·p0.99:   1488.978 ms/op
                 executeFilterQuery·p0.999:  1488.978 ms/op
                 executeFilterQuery·p0.9999: 1488.978 ms/op
                 executeFilterQuery·p1.00:   1488.978 ms/op


# Run progress: 43.35% complete, ETA 14:38:56
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int recordCount = filter_query_table_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = filter_query_table_vc_0.get(aviv);
        if (!((ordinal_value < 3000))) {
            continue;
        }
        int ordinal_value_0 = filter_query_table_vc_1.get(aviv);
        if (!((ordinal_value_0 < 3000))) {
            continue;
        }
        int ordinal_value_1 = filter_query_table_vc_2.get(aviv);
        if (!((ordinal_value_1 < 3000))) {
            continue;
        }
        count++;
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1549.196 ±(99.9%) 311.480 ms/op
# Warmup Iteration   2: 1438.946 ±(99.9%) 25.498 ms/op
# Warmup Iteration   3: 1443.140 ±(99.9%) 64.614 ms/op
# Warmup Iteration   4: 1432.954 ±(99.9%) 34.029 ms/op
# Warmup Iteration   5: 1496.468 ±(99.9%) 22.792 ms/op
Iteration   1: 1494.970 ±(99.9%) 21.198 ms/op
                 executeFilterQuery·p0.00:   1478.492 ms/op
                 executeFilterQuery·p0.50:   1499.464 ms/op
                 executeFilterQuery·p0.90:   1501.561 ms/op
                 executeFilterQuery·p0.95:   1501.561 ms/op
                 executeFilterQuery·p0.99:   1501.561 ms/op
                 executeFilterQuery·p0.999:  1501.561 ms/op
                 executeFilterQuery·p0.9999: 1501.561 ms/op
                 executeFilterQuery·p1.00:   1501.561 ms/op

Iteration   2: 1496.767 ±(99.9%) 34.678 ms/op
                 executeFilterQuery·p0.00:   1470.104 ms/op
                 executeFilterQuery·p0.50:   1499.464 ms/op
                 executeFilterQuery·p0.90:   1518.338 ms/op
                 executeFilterQuery·p0.95:   1518.338 ms/op
                 executeFilterQuery·p0.99:   1518.338 ms/op
                 executeFilterQuery·p0.999:  1518.338 ms/op
                 executeFilterQuery·p0.9999: 1518.338 ms/op
                 executeFilterQuery·p1.00:   1518.338 ms/op

Iteration   3: 1490.775 ±(99.9%) 18.780 ms/op
                 executeFilterQuery·p0.00:   1476.395 ms/op
                 executeFilterQuery·p0.50:   1493.172 ms/op
                 executeFilterQuery·p0.90:   1499.464 ms/op
                 executeFilterQuery·p0.95:   1499.464 ms/op
                 executeFilterQuery·p0.99:   1499.464 ms/op
                 executeFilterQuery·p0.999:  1499.464 ms/op
                 executeFilterQuery·p0.9999: 1499.464 ms/op
                 executeFilterQuery·p1.00:   1499.464 ms/op

Iteration   4: 1474.897 ±(99.9%) 19.227 ms/op
                 executeFilterQuery·p0.00:   1463.812 ms/op
                 executeFilterQuery·p0.50:   1472.201 ms/op
                 executeFilterQuery·p0.90:   1486.881 ms/op
                 executeFilterQuery·p0.95:   1486.881 ms/op
                 executeFilterQuery·p0.99:   1486.881 ms/op
                 executeFilterQuery·p0.999:  1486.881 ms/op
                 executeFilterQuery·p0.9999: 1486.881 ms/op
                 executeFilterQuery·p1.00:   1486.881 ms/op

Iteration   5: 1484.484 ±(99.9%) 31.143 ms/op
                 executeFilterQuery·p0.00:   1465.909 ms/op
                 executeFilterQuery·p0.50:   1484.784 ms/op
                 executeFilterQuery·p0.90:   1503.658 ms/op
                 executeFilterQuery·p0.95:   1503.658 ms/op
                 executeFilterQuery·p0.99:   1503.658 ms/op
                 executeFilterQuery·p0.999:  1503.658 ms/op
                 executeFilterQuery·p0.9999: 1503.658 ms/op
                 executeFilterQuery·p1.00:   1503.658 ms/op



Result "benchmarks.filter_query.NonVectorisedNonSimd.executeFilterQuery":
  N = 70
  mean =   1489.248 ±(99.9%) 5.132 ms/op

  Histogram, ms/op:
    [1460.000, 1465.000) = 1 
    [1465.000, 1470.000) = 2 
    [1470.000, 1475.000) = 4 
    [1475.000, 1480.000) = 6 
    [1480.000, 1485.000) = 19 
    [1485.000, 1490.000) = 8 
    [1490.000, 1495.000) = 10 
    [1495.000, 1500.000) = 8 
    [1500.000, 1505.000) = 6 
    [1505.000, 1510.000) = 1 
    [1510.000, 1515.000) = 3 
    [1515.000, 1520.000) = 1 
    [1520.000, 1525.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   1463.812 ms/op
     p(50.0000) =   1488.978 ms/op
     p(90.0000) =   1503.658 ms/op
     p(95.0000) =   1514.144 ms/op
     p(99.0000) =   1528.824 ms/op
     p(99.9000) =   1528.824 ms/op
     p(99.9900) =   1528.824 ms/op
     p(99.9990) =   1528.824 ms/op
     p(99.9999) =   1528.824 ms/op
    p(100.0000) =   1528.824 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/)

# Run progress: 43.67% complete, ETA 14:29:58
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

86.306 ±(99.9%) 17.367 ms/op
# Warmup Iteration   2: 79.921 ±(99.9%) 0.652 ms/op
# Warmup Iteration   3: 81.236 ±(99.9%) 0.695 ms/op
# Warmup Iteration   4: 80.146 ±(99.9%) 0.806 ms/op
# Warmup Iteration   5: 81.054 ±(99.9%) 0.597 ms/op
Iteration   1: 81.943 ±(99.9%) 0.486 ms/op
                 executeFilterQuery·p0.00:   76.153 ms/op
                 executeFilterQuery·p0.50:   82.182 ms/op
                 executeFilterQuery·p0.90:   83.349 ms/op
                 executeFilterQuery·p0.95:   84.011 ms/op
                 executeFilterQuery·p0.99:   87.129 ms/op
                 executeFilterQuery·p0.999:  87.294 ms/op
                 executeFilterQuery·p0.9999: 87.294 ms/op
                 executeFilterQuery·p1.00:   87.294 ms/op

Iteration   2: 78.912 ±(99.9%) 0.688 ms/op
                 executeFilterQuery·p0.00:   72.614 ms/op
                 executeFilterQuery·p0.50:   79.036 ms/op
                 executeFilterQuery·p0.90:   82.090 ms/op
                 executeFilterQuery·p0.95:   83.008 ms/op
                 executeFilterQuery·p0.99:   83.805 ms/op
                 executeFilterQuery·p0.999:  84.017 ms/op
                 executeFilterQuery·p0.9999: 84.017 ms/op
                 executeFilterQuery·p1.00:   84.017 ms/op

Iteration   3: 79.069 ±(99.9%) 0.569 ms/op
                 executeFilterQuery·p0.00:   72.614 ms/op
                 executeFilterQuery·p0.50:   78.905 ms/op
                 executeFilterQuery·p0.90:   81.697 ms/op
                 executeFilterQuery·p0.95:   82.484 ms/op
                 executeFilterQuery·p0.99:   83.996 ms/op
                 executeFilterQuery·p0.999:  84.279 ms/op
                 executeFilterQuery·p0.9999: 84.279 ms/op
                 executeFilterQuery·p1.00:   84.279 ms/op

Iteration   4: 78.765 ±(99.9%) 0.640 ms/op
                 executeFilterQuery·p0.00:   71.827 ms/op
                 executeFilterQuery·p0.50:   78.578 ms/op
                 executeFilterQuery·p0.90:   81.789 ms/op
                 executeFilterQuery·p0.95:   82.706 ms/op
                 executeFilterQuery·p0.99:   83.649 ms/op
                 executeFilterQuery·p0.999:  83.755 ms/op
                 executeFilterQuery·p0.9999: 83.755 ms/op
                 executeFilterQuery·p1.00:   83.755 ms/op

Iteration   5: 78.714 ±(99.9%) 0.948 ms/op
                 executeFilterQuery·p0.00:   73.400 ms/op
                 executeFilterQuery·p0.50:   78.447 ms/op
                 executeFilterQuery·p0.90:   81.474 ms/op
                 executeFilterQuery·p0.95:   82.261 ms/op
                 executeFilterQuery·p0.99:   99.148 ms/op
                 executeFilterQuery·p0.999:  103.678 ms/op
                 executeFilterQuery·p0.9999: 103.678 ms/op
                 executeFilterQuery·p1.00:   103.678 ms/op


# Run progress: 43.99% complete, ETA 14:21:02
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

84.734 ±(99.9%) 7.854 ms/op
# Warmup Iteration   2: 80.404 ±(99.9%) 0.656 ms/op
# Warmup Iteration   3: 81.911 ±(99.9%) 0.742 ms/op
# Warmup Iteration   4: 81.822 ±(99.9%) 0.728 ms/op
# Warmup Iteration   5: 80.466 ±(99.9%) 0.742 ms/op
Iteration   1: 81.299 ±(99.9%) 0.653 ms/op
                 executeFilterQuery·p0.00:   75.104 ms/op
                 executeFilterQuery·p0.50:   81.658 ms/op
                 executeFilterQuery·p0.90:   82.969 ms/op
                 executeFilterQuery·p0.95:   83.611 ms/op
                 executeFilterQuery·p0.99:   86.610 ms/op
                 executeFilterQuery·p0.999:  86.639 ms/op
                 executeFilterQuery·p0.9999: 86.639 ms/op
                 executeFilterQuery·p1.00:   86.639 ms/op

Iteration   2: 79.082 ±(99.9%) 0.802 ms/op
                 executeFilterQuery·p0.00:   72.090 ms/op
                 executeFilterQuery·p0.50:   79.036 ms/op
                 executeFilterQuery·p0.90:   82.313 ms/op
                 executeFilterQuery·p0.95:   82.706 ms/op
                 executeFilterQuery·p0.99:   90.651 ms/op
                 executeFilterQuery·p0.999:  92.668 ms/op
                 executeFilterQuery·p0.9999: 92.668 ms/op
                 executeFilterQuery·p1.00:   92.668 ms/op

Iteration   3: 79.006 ±(99.9%) 0.595 ms/op
                 executeFilterQuery·p0.00:   72.221 ms/op
                 executeFilterQuery·p0.50:   79.036 ms/op
                 executeFilterQuery·p0.90:   81.566 ms/op
                 executeFilterQuery·p0.95:   82.051 ms/op
                 executeFilterQuery·p0.99:   82.575 ms/op
                 executeFilterQuery·p0.999:  82.575 ms/op
                 executeFilterQuery·p0.9999: 82.575 ms/op
                 executeFilterQuery·p1.00:   82.575 ms/op

Iteration   4: 79.200 ±(99.9%) 0.624 ms/op
                 executeFilterQuery·p0.00:   72.352 ms/op
                 executeFilterQuery·p0.50:   79.102 ms/op
                 executeFilterQuery·p0.90:   81.959 ms/op
                 executeFilterQuery·p0.95:   82.529 ms/op
                 executeFilterQuery·p0.99:   85.049 ms/op
                 executeFilterQuery·p0.999:  85.721 ms/op
                 executeFilterQuery·p0.9999: 85.721 ms/op
                 executeFilterQuery·p1.00:   85.721 ms/op

Iteration   5: 79.000 ±(99.9%) 0.660 ms/op
                 executeFilterQuery·p0.00:   72.221 ms/op
                 executeFilterQuery·p0.50:   78.774 ms/op
                 executeFilterQuery·p0.90:   82.051 ms/op
                 executeFilterQuery·p0.95:   82.661 ms/op
                 executeFilterQuery·p0.99:   84.188 ms/op
                 executeFilterQuery·p0.999:  84.541 ms/op
                 executeFilterQuery·p0.9999: 84.541 ms/op
                 executeFilterQuery·p1.00:   84.541 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 1249
  mean =     79.480 ±(99.9%) 0.232 ms/op

  Histogram, ms/op:
    [ 70.000,  72.500) = 12 
    [ 72.500,  75.000) = 42 
    [ 75.000,  77.500) = 149 
    [ 77.500,  80.000) = 589 
    [ 80.000,  82.500) = 347 
    [ 82.500,  85.000) = 98 
    [ 85.000,  87.500) = 10 
    [ 87.500,  90.000) = 0 
    [ 90.000,  92.500) = 0 
    [ 92.500,  95.000) = 1 
    [ 95.000,  97.500) = 0 
    [ 97.500, 100.000) = 0 
    [100.000, 102.500) = 0 
    [102.500, 105.000) = 1 
    [105.000, 107.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     71.827 ms/op
     p(50.0000) =     79.167 ms/op
     p(90.0000) =     82.444 ms/op
     p(95.0000) =     82.969 ms/op
     p(99.0000) =     84.869 ms/op
     p(99.9000) =    100.925 ms/op
     p(99.9900) =    103.678 ms/op
     p(99.9990) =    103.678 ms/op
     p(99.9999) =    103.678 ms/op
    p(100.0000) =    103.678 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/)

# Run progress: 44.30% complete, ETA 14:12:12
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

86.939 ±(99.9%) 17.712 ms/op
# Warmup Iteration   2: 79.884 ±(99.9%) 0.782 ms/op
# Warmup Iteration   3: 80.779 ±(99.9%) 0.670 ms/op
# Warmup Iteration   4: 81.514 ±(99.9%) 0.627 ms/op
# Warmup Iteration   5: 80.273 ±(99.9%) 0.719 ms/op
Iteration   1: 81.073 ±(99.9%) 0.737 ms/op
                 executeFilterQuery·p0.00:   75.366 ms/op
                 executeFilterQuery·p0.50:   81.527 ms/op
                 executeFilterQuery·p0.90:   83.231 ms/op
                 executeFilterQuery·p0.95:   83.755 ms/op
                 executeFilterQuery·p0.99:   87.951 ms/op
                 executeFilterQuery·p0.999:  88.343 ms/op
                 executeFilterQuery·p0.9999: 88.343 ms/op
                 executeFilterQuery·p1.00:   88.343 ms/op

Iteration   2: 79.040 ±(99.9%) 0.761 ms/op
                 executeFilterQuery·p0.00:   72.352 ms/op
                 executeFilterQuery·p0.50:   78.840 ms/op
                 executeFilterQuery·p0.90:   82.353 ms/op
                 executeFilterQuery·p0.95:   83.008 ms/op
                 executeFilterQuery·p0.99:   84.889 ms/op
                 executeFilterQuery·p0.999:  85.066 ms/op
                 executeFilterQuery·p0.9999: 85.066 ms/op
                 executeFilterQuery·p1.00:   85.066 ms/op

Iteration   3: 79.316 ±(99.9%) 0.579 ms/op
                 executeFilterQuery·p0.00:   73.400 ms/op
                 executeFilterQuery·p0.50:   79.167 ms/op
                 executeFilterQuery·p0.90:   82.025 ms/op
                 executeFilterQuery·p0.95:   82.536 ms/op
                 executeFilterQuery·p0.99:   83.163 ms/op
                 executeFilterQuery·p0.999:  83.231 ms/op
                 executeFilterQuery·p0.9999: 83.231 ms/op
                 executeFilterQuery·p1.00:   83.231 ms/op

Iteration   4: 78.787 ±(99.9%) 0.657 ms/op
                 executeFilterQuery·p0.00:   72.614 ms/op
                 executeFilterQuery·p0.50:   79.036 ms/op
                 executeFilterQuery·p0.90:   81.658 ms/op
                 executeFilterQuery·p0.95:   82.005 ms/op
                 executeFilterQuery·p0.99:   83.900 ms/op
                 executeFilterQuery·p0.999:  84.148 ms/op
                 executeFilterQuery·p0.9999: 84.148 ms/op
                 executeFilterQuery·p1.00:   84.148 ms/op

Iteration   5: 78.623 ±(99.9%) 0.751 ms/op
                 executeFilterQuery·p0.00:   72.352 ms/op
                 executeFilterQuery·p0.50:   78.512 ms/op
                 executeFilterQuery·p0.90:   81.658 ms/op
                 executeFilterQuery·p0.95:   82.484 ms/op
                 executeFilterQuery·p0.99:   87.677 ms/op
                 executeFilterQuery·p0.999:  87.818 ms/op
                 executeFilterQuery·p0.9999: 87.818 ms/op
                 executeFilterQuery·p1.00:   87.818 ms/op


# Run progress: 44.62% complete, ETA 14:03:28
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

83.866 ±(99.9%) 8.142 ms/op
# Warmup Iteration   2: 79.651 ±(99.9%) 0.640 ms/op
# Warmup Iteration   3: 81.317 ±(99.9%) 0.588 ms/op
# Warmup Iteration   4: 80.868 ±(99.9%) 0.783 ms/op
# Warmup Iteration   5: 80.443 ±(99.9%) 0.745 ms/op
Iteration   1: 80.585 ±(99.9%) 0.593 ms/op
                 executeFilterQuery·p0.00:   74.711 ms/op
                 executeFilterQuery·p0.50:   80.871 ms/op
                 executeFilterQuery·p0.90:   82.444 ms/op
                 executeFilterQuery·p0.95:   82.949 ms/op
                 executeFilterQuery·p0.99:   87.055 ms/op
                 executeFilterQuery·p0.999:  88.080 ms/op
                 executeFilterQuery·p0.9999: 88.080 ms/op
                 executeFilterQuery·p1.00:   88.080 ms/op

Iteration   2: 78.688 ±(99.9%) 0.797 ms/op
                 executeFilterQuery·p0.00:   72.352 ms/op
                 executeFilterQuery·p0.50:   78.905 ms/op
                 executeFilterQuery·p0.90:   81.566 ms/op
                 executeFilterQuery·p0.95:   82.221 ms/op
                 executeFilterQuery·p0.99:   90.863 ms/op
                 executeFilterQuery·p0.999:  92.668 ms/op
                 executeFilterQuery·p0.9999: 92.668 ms/op
                 executeFilterQuery·p1.00:   92.668 ms/op

Iteration   3: 78.990 ±(99.9%) 0.601 ms/op
                 executeFilterQuery·p0.00:   72.352 ms/op
                 executeFilterQuery·p0.50:   79.036 ms/op
                 executeFilterQuery·p0.90:   81.828 ms/op
                 executeFilterQuery·p0.95:   82.182 ms/op
                 executeFilterQuery·p0.99:   84.655 ms/op
                 executeFilterQuery·p0.999:  85.328 ms/op
                 executeFilterQuery·p0.9999: 85.328 ms/op
                 executeFilterQuery·p1.00:   85.328 ms/op

Iteration   4: 79.148 ±(99.9%) 0.718 ms/op
                 executeFilterQuery·p0.00:   73.007 ms/op
                 executeFilterQuery·p0.50:   79.430 ms/op
                 executeFilterQuery·p0.90:   82.575 ms/op
                 executeFilterQuery·p0.95:   82.838 ms/op
                 executeFilterQuery·p0.99:   84.102 ms/op
                 executeFilterQuery·p0.999:  84.279 ms/op
                 executeFilterQuery·p0.9999: 84.279 ms/op
                 executeFilterQuery·p1.00:   84.279 ms/op

Iteration   5: 78.702 ±(99.9%) 0.684 ms/op
                 executeFilterQuery·p0.00:   72.221 ms/op
                 executeFilterQuery·p0.50:   78.971 ms/op
                 executeFilterQuery·p0.90:   81.789 ms/op
                 executeFilterQuery·p0.95:   82.444 ms/op
                 executeFilterQuery·p0.99:   85.109 ms/op
                 executeFilterQuery·p0.999:  85.852 ms/op
                 executeFilterQuery·p0.9999: 85.852 ms/op
                 executeFilterQuery·p1.00:   85.852 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 1251
  mean =     79.285 ±(99.9%) 0.226 ms/op

  Histogram, ms/op:
    [ 70.000,  72.500) = 8 
    [ 72.500,  75.000) = 65 
    [ 75.000,  77.500) = 168 
    [ 77.500,  80.000) = 571 
    [ 80.000,  82.500) = 353 
    [ 82.500,  85.000) = 75 
    [ 85.000,  87.500) = 7 
    [ 87.500,  90.000) = 3 
    [ 90.000,  92.500) = 0 
    [ 92.500,  95.000) = 1 
    [ 95.000,  97.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     72.221 ms/op
     p(50.0000) =     79.299 ms/op
     p(90.0000) =     82.182 ms/op
     p(95.0000) =     82.759 ms/op
     p(99.0000) =     84.410 ms/op
     p(99.9000) =     91.578 ms/op
     p(99.9900) =     92.668 ms/op
     p(99.9990) =     92.668 ms/op
     p(99.9999) =     92.668 ms/op
    p(100.0000) =     92.668 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/)

# Run progress: 44.94% complete, ETA 13:54:50
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

86.596 ±(99.9%) 18.093 ms/op
# Warmup Iteration   2: 79.570 ±(99.9%) 0.858 ms/op
# Warmup Iteration   3: 80.625 ±(99.9%) 0.738 ms/op
# Warmup Iteration   4: 80.781 ±(99.9%) 0.771 ms/op
# Warmup Iteration   5: 80.218 ±(99.9%) 0.853 ms/op
Iteration   1: 79.193 ±(99.9%) 0.853 ms/op
                 executeFilterQuery·p0.00:   74.056 ms/op
                 executeFilterQuery·p0.50:   79.167 ms/op
                 executeFilterQuery·p0.90:   82.313 ms/op
                 executeFilterQuery·p0.95:   82.706 ms/op
                 executeFilterQuery·p0.99:   89.315 ms/op
                 executeFilterQuery·p0.999:  90.440 ms/op
                 executeFilterQuery·p0.9999: 90.440 ms/op
                 executeFilterQuery·p1.00:   90.440 ms/op

Iteration   2: 79.175 ±(99.9%) 0.681 ms/op
                 executeFilterQuery·p0.00:   72.614 ms/op
                 executeFilterQuery·p0.50:   79.102 ms/op
                 executeFilterQuery·p0.90:   82.090 ms/op
                 executeFilterQuery·p0.95:   82.529 ms/op
                 executeFilterQuery·p0.99:   83.412 ms/op
                 executeFilterQuery·p0.999:  83.624 ms/op
                 executeFilterQuery·p0.9999: 83.624 ms/op
                 executeFilterQuery·p1.00:   83.624 ms/op

Iteration   3: 79.072 ±(99.9%) 0.690 ms/op
                 executeFilterQuery·p0.00:   72.614 ms/op
                 executeFilterQuery·p0.50:   78.905 ms/op
                 executeFilterQuery·p0.90:   81.999 ms/op
                 executeFilterQuery·p0.95:   82.661 ms/op
                 executeFilterQuery·p0.99:   85.492 ms/op
                 executeFilterQuery·p0.999:  86.376 ms/op
                 executeFilterQuery·p0.9999: 86.376 ms/op
                 executeFilterQuery·p1.00:   86.376 ms/op

Iteration   4: 78.757 ±(99.9%) 0.692 ms/op
                 executeFilterQuery·p0.00:   72.614 ms/op
                 executeFilterQuery·p0.50:   79.102 ms/op
                 executeFilterQuery·p0.90:   81.920 ms/op
                 executeFilterQuery·p0.95:   82.267 ms/op
                 executeFilterQuery·p0.99:   83.054 ms/op
                 executeFilterQuery·p0.999:  83.231 ms/op
                 executeFilterQuery·p0.9999: 83.231 ms/op
                 executeFilterQuery·p1.00:   83.231 ms/op

Iteration   5: 79.049 ±(99.9%) 0.728 ms/op
                 executeFilterQuery·p0.00:   72.090 ms/op
                 executeFilterQuery·p0.50:   79.167 ms/op
                 executeFilterQuery·p0.90:   81.999 ms/op
                 executeFilterQuery·p0.95:   82.706 ms/op
                 executeFilterQuery·p0.99:   86.047 ms/op
                 executeFilterQuery·p0.999:  86.508 ms/op
                 executeFilterQuery·p0.9999: 86.508 ms/op
                 executeFilterQuery·p1.00:   86.508 ms/op


# Run progress: 45.25% complete, ETA 13:46:17
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

83.256 ±(99.9%) 7.773 ms/op
# Warmup Iteration   2: 80.214 ±(99.9%) 0.672 ms/op
# Warmup Iteration   3: 81.319 ±(99.9%) 0.661 ms/op
# Warmup Iteration   4: 81.312 ±(99.9%) 0.587 ms/op
# Warmup Iteration   5: 80.444 ±(99.9%) 0.798 ms/op
Iteration   1: 80.486 ±(99.9%) 0.843 ms/op
                 executeFilterQuery·p0.00:   74.711 ms/op
                 executeFilterQuery·p0.50:   81.527 ms/op
                 executeFilterQuery·p0.90:   82.929 ms/op
                 executeFilterQuery·p0.95:   83.100 ms/op
                 executeFilterQuery·p0.99:   85.632 ms/op
                 executeFilterQuery·p0.999:  86.114 ms/op
                 executeFilterQuery·p0.9999: 86.114 ms/op
                 executeFilterQuery·p1.00:   86.114 ms/op

Iteration   2: 78.922 ±(99.9%) 0.647 ms/op
                 executeFilterQuery·p0.00:   72.090 ms/op
                 executeFilterQuery·p0.50:   78.905 ms/op
                 executeFilterQuery·p0.90:   81.645 ms/op
                 executeFilterQuery·p0.95:   82.661 ms/op
                 executeFilterQuery·p0.99:   86.023 ms/op
                 executeFilterQuery·p0.999:  86.376 ms/op
                 executeFilterQuery·p0.9999: 86.376 ms/op
                 executeFilterQuery·p1.00:   86.376 ms/op

Iteration   3: 78.706 ±(99.9%) 0.709 ms/op
                 executeFilterQuery·p0.00:   73.007 ms/op
                 executeFilterQuery·p0.50:   78.774 ms/op
                 executeFilterQuery·p0.90:   82.182 ms/op
                 executeFilterQuery·p0.95:   82.575 ms/op
                 executeFilterQuery·p0.99:   83.256 ms/op
                 executeFilterQuery·p0.999:  83.362 ms/op
                 executeFilterQuery·p0.9999: 83.362 ms/op
                 executeFilterQuery·p1.00:   83.362 ms/op

Iteration   4: 78.952 ±(99.9%) 0.616 ms/op
                 executeFilterQuery·p0.00:   73.007 ms/op
                 executeFilterQuery·p0.50:   79.102 ms/op
                 executeFilterQuery·p0.90:   81.920 ms/op
                 executeFilterQuery·p0.95:   82.182 ms/op
                 executeFilterQuery·p0.99:   82.862 ms/op
                 executeFilterQuery·p0.999:  82.969 ms/op
                 executeFilterQuery·p0.9999: 82.969 ms/op
                 executeFilterQuery·p1.00:   82.969 ms/op

Iteration   5: 79.343 ±(99.9%) 0.595 ms/op
                 executeFilterQuery·p0.00:   74.449 ms/op
                 executeFilterQuery·p0.50:   79.167 ms/op
                 executeFilterQuery·p0.90:   81.920 ms/op
                 executeFilterQuery·p0.95:   82.772 ms/op
                 executeFilterQuery·p0.99:   87.380 ms/op
                 executeFilterQuery·p0.999:  87.687 ms/op
                 executeFilterQuery·p0.9999: 87.687 ms/op
                 executeFilterQuery·p1.00:   87.687 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 1254
  mean =     79.161 ±(99.9%) 0.223 ms/op

  Histogram, ms/op:
    [ 70.000,  72.500) = 2 
    [ 72.500,  75.000) = 79 
    [ 75.000,  77.500) = 168 
    [ 77.500,  80.000) = 597 
    [ 80.000,  82.500) = 330 
    [ 82.500,  85.000) = 69 
    [ 85.000,  87.500) = 7 
    [ 87.500,  90.000) = 1 
    [ 90.000,  92.500) = 1 
    [ 92.500,  95.000) = 0 
    [ 95.000,  97.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     72.090 ms/op
     p(50.0000) =     79.167 ms/op
     p(90.0000) =     82.182 ms/op
     p(95.0000) =     82.575 ms/op
     p(99.0000) =     84.017 ms/op
     p(99.9000) =     89.738 ms/op
     p(99.9900) =     90.440 ms/op
     p(99.9990) =     90.440 ms/op
     p(99.9999) =     90.440 ms/op
    p(100.0000) =     90.440 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/)

# Run progress: 45.57% complete, ETA 13:37:51
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1163.570 ±(99.9%) 1961.990 ms/op
# Warmup Iteration   2: 742.916 ±(99.9%) 13.014 ms/op
# Warmup Iteration   3: 752.129 ±(99.9%) 22.364 ms/op
# Warmup Iteration   4: 773.446 ±(99.9%) 6.792 ms/op
# Warmup Iteration   5: 773.204 ±(99.9%) 4.905 ms/op
Iteration   1: 767.074 ±(99.9%) 6.207 ms/op
                 executeFilterQuery·p0.00:   759.169 ms/op
                 executeFilterQuery·p0.50:   766.509 ms/op
                 executeFilterQuery·p0.90:   775.737 ms/op
                 executeFilterQuery·p0.95:   776.995 ms/op
                 executeFilterQuery·p0.99:   776.995 ms/op
                 executeFilterQuery·p0.999:  776.995 ms/op
                 executeFilterQuery·p0.9999: 776.995 ms/op
                 executeFilterQuery·p1.00:   776.995 ms/op

Iteration   2: 771.187 ±(99.9%) 3.857 ms/op
                 executeFilterQuery·p0.00:   765.460 ms/op
                 executeFilterQuery·p0.50:   771.752 ms/op
                 executeFilterQuery·p0.90:   775.527 ms/op
                 executeFilterQuery·p0.95:   775.946 ms/op
                 executeFilterQuery·p0.99:   775.946 ms/op
                 executeFilterQuery·p0.999:  775.946 ms/op
                 executeFilterQuery·p0.9999: 775.946 ms/op
                 executeFilterQuery·p1.00:   775.946 ms/op

Iteration   3: 764.786 ±(99.9%) 6.095 ms/op
                 executeFilterQuery·p0.00:   757.072 ms/op
                 executeFilterQuery·p0.50:   764.412 ms/op
                 executeFilterQuery·p0.90:   774.898 ms/op
                 executeFilterQuery·p0.95:   775.946 ms/op
                 executeFilterQuery·p0.99:   775.946 ms/op
                 executeFilterQuery·p0.999:  775.946 ms/op
                 executeFilterQuery·p0.9999: 775.946 ms/op
                 executeFilterQuery·p1.00:   775.946 ms/op

Iteration   4: 768.606 ±(99.9%) 5.521 ms/op
                 executeFilterQuery·p0.00:   759.169 ms/op
                 executeFilterQuery·p0.50:   767.558 ms/op
                 executeFilterQuery·p0.90:   774.478 ms/op
                 executeFilterQuery·p0.95:   774.898 ms/op
                 executeFilterQuery·p0.99:   774.898 ms/op
                 executeFilterQuery·p0.999:  774.898 ms/op
                 executeFilterQuery·p0.9999: 774.898 ms/op
                 executeFilterQuery·p1.00:   774.898 ms/op

Iteration   5: 743.291 ±(99.9%) 21.230 ms/op
                 executeFilterQuery·p0.00:   724.566 ms/op
                 executeFilterQuery·p0.50:   736.625 ms/op
                 executeFilterQuery·p0.90:   776.471 ms/op
                 executeFilterQuery·p0.95:   776.995 ms/op
                 executeFilterQuery·p0.99:   776.995 ms/op
                 executeFilterQuery·p0.999:  776.995 ms/op
                 executeFilterQuery·p0.9999: 776.995 ms/op
                 executeFilterQuery·p1.00:   776.995 ms/op


# Run progress: 45.89% complete, ETA 13:29:33
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

791.110 ±(99.9%) 124.364 ms/op
# Warmup Iteration   2: 744.414 ±(99.9%) 12.227 ms/op
# Warmup Iteration   3: 760.218 ±(99.9%) 19.214 ms/op
# Warmup Iteration   4: 767.558 ±(99.9%) 5.822 ms/op
# Warmup Iteration   5: 770.542 ±(99.9%) 4.638 ms/op
Iteration   1: 769.090 ±(99.9%) 7.315 ms/op
                 executeFilterQuery·p0.00:   760.218 ms/op
                 executeFilterQuery·p0.50:   767.558 ms/op
                 executeFilterQuery·p0.90:   778.463 ms/op
                 executeFilterQuery·p0.95:   780.141 ms/op
                 executeFilterQuery·p0.99:   780.141 ms/op
                 executeFilterQuery·p0.999:  780.141 ms/op
                 executeFilterQuery·p0.9999: 780.141 ms/op
                 executeFilterQuery·p1.00:   780.141 ms/op

Iteration   2: 767.880 ±(99.9%) 5.987 ms/op
                 executeFilterQuery·p0.00:   759.169 ms/op
                 executeFilterQuery·p0.50:   765.460 ms/op
                 executeFilterQuery·p0.90:   776.156 ms/op
                 executeFilterQuery·p0.95:   776.995 ms/op
                 executeFilterQuery·p0.99:   776.995 ms/op
                 executeFilterQuery·p0.999:  776.995 ms/op
                 executeFilterQuery·p0.9999: 776.995 ms/op
                 executeFilterQuery·p1.00:   776.995 ms/op

Iteration   3: 762.989 ±(99.9%) 2.729 ms/op
                 executeFilterQuery·p0.00:   758.120 ms/op
                 executeFilterQuery·p0.50:   763.363 ms/op
                 executeFilterQuery·p0.90:   765.460 ms/op
                 executeFilterQuery·p0.95:   765.460 ms/op
                 executeFilterQuery·p0.99:   765.460 ms/op
                 executeFilterQuery·p0.999:  765.460 ms/op
                 executeFilterQuery·p0.9999: 765.460 ms/op
                 executeFilterQuery·p1.00:   765.460 ms/op

Iteration   4: 769.574 ±(99.9%) 7.782 ms/op
                 executeFilterQuery·p0.00:   757.072 ms/op
                 executeFilterQuery·p0.50:   771.752 ms/op
                 executeFilterQuery·p0.90:   777.624 ms/op
                 executeFilterQuery·p0.95:   778.043 ms/op
                 executeFilterQuery·p0.99:   778.043 ms/op
                 executeFilterQuery·p0.999:  778.043 ms/op
                 executeFilterQuery·p0.9999: 778.043 ms/op
                 executeFilterQuery·p1.00:   778.043 ms/op

Iteration   5: 759.394 ±(99.9%) 17.447 ms/op
                 executeFilterQuery·p0.00:   738.198 ms/op
                 executeFilterQuery·p0.50:   767.558 ms/op
                 executeFilterQuery·p0.90:   775.946 ms/op
                 executeFilterQuery·p0.95:   776.995 ms/op
                 executeFilterQuery·p0.99:   776.995 ms/op
                 executeFilterQuery·p0.999:  776.995 ms/op
                 executeFilterQuery·p0.9999: 776.995 ms/op
                 executeFilterQuery·p1.00:   776.995 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 134
  mean =    764.185 ±(99.9%) 3.424 ms/op

  Histogram, ms/op:
    [720.000, 725.000) = 1 
    [725.000, 730.000) = 4 
    [730.000, 735.000) = 2 
    [735.000, 740.000) = 3 
    [740.000, 745.000) = 5 
    [745.000, 750.000) = 2 
    [750.000, 755.000) = 0 
    [755.000, 760.000) = 11 
    [760.000, 765.000) = 23 
    [765.000, 770.000) = 36 
    [770.000, 775.000) = 36 
    [775.000, 780.000) = 10 
    [780.000, 785.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    724.566 ms/op
     p(50.0000) =    765.460 ms/op
     p(90.0000) =    774.898 ms/op
     p(95.0000) =    776.995 ms/op
     p(99.0000) =    779.407 ms/op
     p(99.9000) =    780.141 ms/op
     p(99.9900) =    780.141 ms/op
     p(99.9990) =    780.141 ms/op
     p(99.9999) =    780.141 ms/op
    p(100.0000) =    780.141 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/)

# Run progress: 46.20% complete, ETA 13:21:21
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1248.330 ±(99.9%) 2493.665 ms/op
# Warmup Iteration   2: 733.479 ±(99.9%) 10.454 ms/op
# Warmup Iteration   3: 742.766 ±(99.9%) 17.846 ms/op
# Warmup Iteration   4: 763.139 ±(99.9%) 6.646 ms/op
# Warmup Iteration   5: 761.266 ±(99.9%) 5.411 ms/op
Iteration   1: 760.967 ±(99.9%) 6.997 ms/op
                 executeFilterQuery·p0.00:   749.732 ms/op
                 executeFilterQuery·p0.50:   760.218 ms/op
                 executeFilterQuery·p0.90:   767.558 ms/op
                 executeFilterQuery·p0.95:   767.558 ms/op
                 executeFilterQuery·p0.99:   767.558 ms/op
                 executeFilterQuery·p0.999:  767.558 ms/op
                 executeFilterQuery·p0.9999: 767.558 ms/op
                 executeFilterQuery·p1.00:   767.558 ms/op

Iteration   2: 761.416 ±(99.9%) 5.037 ms/op
                 executeFilterQuery·p0.00:   753.926 ms/op
                 executeFilterQuery·p0.50:   761.790 ms/op
                 executeFilterQuery·p0.90:   769.130 ms/op
                 executeFilterQuery·p0.95:   770.703 ms/op
                 executeFilterQuery·p0.99:   770.703 ms/op
                 executeFilterQuery·p0.999:  770.703 ms/op
                 executeFilterQuery·p0.9999: 770.703 ms/op
                 executeFilterQuery·p1.00:   770.703 ms/op

Iteration   3: 761.341 ±(99.9%) 7.473 ms/op
                 executeFilterQuery·p0.00:   752.878 ms/op
                 executeFilterQuery·p0.50:   761.790 ms/op
                 executeFilterQuery·p0.90:   771.752 ms/op
                 executeFilterQuery·p0.95:   773.849 ms/op
                 executeFilterQuery·p0.99:   773.849 ms/op
                 executeFilterQuery·p0.999:  773.849 ms/op
                 executeFilterQuery·p0.9999: 773.849 ms/op
                 executeFilterQuery·p1.00:   773.849 ms/op

Iteration   4: 762.015 ±(99.9%) 9.955 ms/op
                 executeFilterQuery·p0.00:   752.878 ms/op
                 executeFilterQuery·p0.50:   760.218 ms/op
                 executeFilterQuery·p0.90:   776.471 ms/op
                 executeFilterQuery·p0.95:   784.335 ms/op
                 executeFilterQuery·p0.99:   784.335 ms/op
                 executeFilterQuery·p0.999:  784.335 ms/op
                 executeFilterQuery·p0.9999: 784.335 ms/op
                 executeFilterQuery·p1.00:   784.335 ms/op

Iteration   5: 740.444 ±(99.9%) 19.502 ms/op
                 executeFilterQuery·p0.00:   722.469 ms/op
                 executeFilterQuery·p0.50:   732.955 ms/op
                 executeFilterQuery·p0.90:   770.179 ms/op
                 executeFilterQuery·p0.95:   770.703 ms/op
                 executeFilterQuery·p0.99:   770.703 ms/op
                 executeFilterQuery·p0.999:  770.703 ms/op
                 executeFilterQuery·p0.9999: 770.703 ms/op
                 executeFilterQuery·p1.00:   770.703 ms/op


# Run progress: 46.52% complete, ETA 13:13:16
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

773.607 ±(99.9%) 124.758 ms/op
# Warmup Iteration   2: 735.801 ±(99.9%) 17.504 ms/op
# Warmup Iteration   3: 743.365 ±(99.9%) 18.322 ms/op
# Warmup Iteration   4: 722.918 ±(99.9%) 4.991 ms/op
# Warmup Iteration   5: 737.449 ±(99.9%) 17.050 ms/op
Iteration   1: 733.779 ±(99.9%) 19.130 ms/op
                 executeFilterQuery·p0.00:   714.080 ms/op
                 executeFilterQuery·p0.50:   725.615 ms/op
                 executeFilterQuery·p0.90:   757.072 ms/op
                 executeFilterQuery·p0.95:   758.120 ms/op
                 executeFilterQuery·p0.99:   758.120 ms/op
                 executeFilterQuery·p0.999:  758.120 ms/op
                 executeFilterQuery·p0.9999: 758.120 ms/op
                 executeFilterQuery·p1.00:   758.120 ms/op

Iteration   2: 718.125 ±(99.9%) 5.163 ms/op
                 executeFilterQuery·p0.00:   708.837 ms/op
                 executeFilterQuery·p0.50:   718.275 ms/op
                 executeFilterQuery·p0.90:   724.042 ms/op
                 executeFilterQuery·p0.95:   724.566 ms/op
                 executeFilterQuery·p0.99:   724.566 ms/op
                 executeFilterQuery·p0.999:  724.566 ms/op
                 executeFilterQuery·p0.9999: 724.566 ms/op
                 executeFilterQuery·p1.00:   724.566 ms/op

Iteration   3: 719.922 ±(99.9%) 6.719 ms/op
                 executeFilterQuery·p0.00:   710.935 ms/op
                 executeFilterQuery·p0.50:   720.372 ms/op
                 executeFilterQuery·p0.90:   728.760 ms/op
                 executeFilterQuery·p0.95:   730.857 ms/op
                 executeFilterQuery·p0.99:   730.857 ms/op
                 executeFilterQuery·p0.999:  730.857 ms/op
                 executeFilterQuery·p0.9999: 730.857 ms/op
                 executeFilterQuery·p1.00:   730.857 ms/op

Iteration   4: 744.863 ±(99.9%) 11.861 ms/op
                 executeFilterQuery·p0.00:   720.372 ms/op
                 executeFilterQuery·p0.50:   749.208 ms/op
                 executeFilterQuery·p0.90:   753.402 ms/op
                 executeFilterQuery·p0.95:   753.926 ms/op
                 executeFilterQuery·p0.99:   753.926 ms/op
                 executeFilterQuery·p0.999:  753.926 ms/op
                 executeFilterQuery·p0.9999: 753.926 ms/op
                 executeFilterQuery·p1.00:   753.926 ms/op

Iteration   5: 750.256 ±(99.9%) 3.272 ms/op
                 executeFilterQuery·p0.00:   744.489 ms/op
                 executeFilterQuery·p0.50:   751.829 ms/op
                 executeFilterQuery·p0.90:   752.878 ms/op
                 executeFilterQuery·p0.95:   753.926 ms/op
                 executeFilterQuery·p0.99:   753.926 ms/op
                 executeFilterQuery·p0.999:  753.926 ms/op
                 executeFilterQuery·p0.9999: 753.926 ms/op
                 executeFilterQuery·p1.00:   753.926 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 140
  mean =    745.313 ±(99.9%) 5.320 ms/op

  Histogram, ms/op:
    [700.000, 705.000) = 0 
    [705.000, 710.000) = 1 
    [710.000, 715.000) = 5 
    [715.000, 720.000) = 11 
    [720.000, 725.000) = 19 
    [725.000, 730.000) = 6 
    [730.000, 735.000) = 4 
    [735.000, 740.000) = 3 
    [740.000, 745.000) = 3 
    [745.000, 750.000) = 10 
    [750.000, 755.000) = 30 
    [755.000, 760.000) = 14 
    [760.000, 765.000) = 12 
    [765.000, 770.000) = 18 
    [770.000, 775.000) = 3 
    [775.000, 780.000) = 0 
    [780.000, 785.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    708.837 ms/op
     p(50.0000) =    751.829 ms/op
     p(90.0000) =    767.558 ms/op
     p(95.0000) =    768.554 ms/op
     p(99.0000) =    780.036 ms/op
     p(99.9000) =    784.335 ms/op
     p(99.9900) =    784.335 ms/op
     p(99.9990) =    784.335 ms/op
     p(99.9999) =    784.335 ms/op
    p(100.0000) =    784.335 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/)

# Run progress: 46.84% complete, ETA 13:05:14
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1171.725 ±(99.9%) 2082.279 ms/op
# Warmup Iteration   2: 727.787 ±(99.9%) 14.944 ms/op
# Warmup Iteration   3: 754.525 ±(99.9%) 17.793 ms/op
# Warmup Iteration   4: 760.742 ±(99.9%) 9.494 ms/op
# Warmup Iteration   5: 767.880 ±(99.9%) 6.731 ms/op
Iteration   1: 763.888 ±(99.9%) 3.526 ms/op
                 executeFilterQuery·p0.00:   757.072 ms/op
                 executeFilterQuery·p0.50:   764.936 ms/op
                 executeFilterQuery·p0.90:   767.558 ms/op
                 executeFilterQuery·p0.95:   767.558 ms/op
                 executeFilterQuery·p0.99:   767.558 ms/op
                 executeFilterQuery·p0.999:  767.558 ms/op
                 executeFilterQuery·p0.9999: 767.558 ms/op
                 executeFilterQuery·p1.00:   767.558 ms/op

Iteration   2: 759.918 ±(99.9%) 3.423 ms/op
                 executeFilterQuery·p0.00:   754.975 ms/op
                 executeFilterQuery·p0.50:   759.693 ms/op
                 executeFilterQuery·p0.90:   763.888 ms/op
                 executeFilterQuery·p0.95:   764.412 ms/op
                 executeFilterQuery·p0.99:   764.412 ms/op
                 executeFilterQuery·p0.999:  764.412 ms/op
                 executeFilterQuery·p0.9999: 764.412 ms/op
                 executeFilterQuery·p1.00:   764.412 ms/op

Iteration   3: 764.412 ±(99.9%) 4.888 ms/op
                 executeFilterQuery·p0.00:   757.072 ms/op
                 executeFilterQuery·p0.50:   764.412 ms/op
                 executeFilterQuery·p0.90:   772.276 ms/op
                 executeFilterQuery·p0.95:   774.898 ms/op
                 executeFilterQuery·p0.99:   774.898 ms/op
                 executeFilterQuery·p0.999:  774.898 ms/op
                 executeFilterQuery·p0.9999: 774.898 ms/op
                 executeFilterQuery·p1.00:   774.898 ms/op

Iteration   4: 757.746 ±(99.9%) 12.489 ms/op
                 executeFilterQuery·p0.00:   734.003 ms/op
                 executeFilterQuery·p0.50:   761.266 ms/op
                 executeFilterQuery·p0.90:   768.082 ms/op
                 executeFilterQuery·p0.95:   768.606 ms/op
                 executeFilterQuery·p0.99:   768.606 ms/op
                 executeFilterQuery·p0.999:  768.606 ms/op
                 executeFilterQuery·p0.9999: 768.606 ms/op
                 executeFilterQuery·p1.00:   768.606 ms/op

Iteration   5: 734.378 ±(99.9%) 11.054 ms/op
                 executeFilterQuery·p0.00:   719.323 ms/op
                 executeFilterQuery·p0.50:   734.527 ms/op
                 executeFilterQuery·p0.90:   750.256 ms/op
                 executeFilterQuery·p0.95:   758.120 ms/op
                 executeFilterQuery·p0.99:   758.120 ms/op
                 executeFilterQuery·p0.999:  758.120 ms/op
                 executeFilterQuery·p0.9999: 758.120 ms/op
                 executeFilterQuery·p1.00:   758.120 ms/op


# Run progress: 47.15% complete, ETA 12:57:19
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

784.980 ±(99.9%) 139.645 ms/op
# Warmup Iteration   2: 727.412 ±(99.9%) 14.572 ms/op
# Warmup Iteration   3: 747.185 ±(99.9%) 16.036 ms/op
# Warmup Iteration   4: 740.070 ±(99.9%) 19.404 ms/op
# Warmup Iteration   5: 729.135 ±(99.9%) 8.124 ms/op
Iteration   1: 751.155 ±(99.9%) 12.059 ms/op
                 executeFilterQuery·p0.00:   721.420 ms/op
                 executeFilterQuery·p0.50:   753.402 ms/op
                 executeFilterQuery·p0.90:   761.266 ms/op
                 executeFilterQuery·p0.95:   762.315 ms/op
                 executeFilterQuery·p0.99:   762.315 ms/op
                 executeFilterQuery·p0.999:  762.315 ms/op
                 executeFilterQuery·p0.9999: 762.315 ms/op
                 executeFilterQuery·p1.00:   762.315 ms/op

Iteration   2: 753.252 ±(99.9%) 7.122 ms/op
                 executeFilterQuery·p0.00:   744.489 ms/op
                 executeFilterQuery·p0.50:   753.926 ms/op
                 executeFilterQuery·p0.90:   761.790 ms/op
                 executeFilterQuery·p0.95:   763.363 ms/op
                 executeFilterQuery·p0.99:   763.363 ms/op
                 executeFilterQuery·p0.999:  763.363 ms/op
                 executeFilterQuery·p0.9999: 763.363 ms/op
                 executeFilterQuery·p1.00:   763.363 ms/op

Iteration   3: 755.274 ±(99.9%) 5.154 ms/op
                 executeFilterQuery·p0.00:   749.732 ms/op
                 executeFilterQuery·p0.50:   753.926 ms/op
                 executeFilterQuery·p0.90:   761.266 ms/op
                 executeFilterQuery·p0.95:   761.266 ms/op
                 executeFilterQuery·p0.99:   761.266 ms/op
                 executeFilterQuery·p0.999:  761.266 ms/op
                 executeFilterQuery·p0.9999: 761.266 ms/op
                 executeFilterQuery·p1.00:   761.266 ms/op

Iteration   4: 754.750 ±(99.9%) 6.035 ms/op
                 executeFilterQuery·p0.00:   745.538 ms/op
                 executeFilterQuery·p0.50:   754.450 ms/op
                 executeFilterQuery·p0.90:   761.790 ms/op
                 executeFilterQuery·p0.95:   762.315 ms/op
                 executeFilterQuery·p0.99:   762.315 ms/op
                 executeFilterQuery·p0.999:  762.315 ms/op
                 executeFilterQuery·p0.9999: 762.315 ms/op
                 executeFilterQuery·p1.00:   762.315 ms/op

Iteration   5: 754.675 ±(99.9%) 4.764 ms/op
                 executeFilterQuery·p0.00:   748.683 ms/op
                 executeFilterQuery·p0.50:   754.450 ms/op
                 executeFilterQuery·p0.90:   759.169 ms/op
                 executeFilterQuery·p0.95:   759.169 ms/op
                 executeFilterQuery·p0.99:   759.169 ms/op
                 executeFilterQuery·p0.999:  759.169 ms/op
                 executeFilterQuery·p0.9999: 759.169 ms/op
                 executeFilterQuery·p1.00:   759.169 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 140
  mean =    754.945 ±(99.9%) 2.972 ms/op

  Histogram, ms/op:
    [710.000, 715.000) = 0 
    [715.000, 720.000) = 1 
    [720.000, 725.000) = 2 
    [725.000, 730.000) = 4 
    [730.000, 735.000) = 3 
    [735.000, 740.000) = 5 
    [740.000, 745.000) = 5 
    [745.000, 750.000) = 14 
    [750.000, 755.000) = 24 
    [755.000, 760.000) = 25 
    [760.000, 765.000) = 44 
    [765.000, 770.000) = 12 
    [770.000, 775.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    719.323 ms/op
     p(50.0000) =    758.120 ms/op
     p(90.0000) =    764.412 ms/op
     p(95.0000) =    767.505 ms/op
     p(99.0000) =    772.748 ms/op
     p(99.9000) =    774.898 ms/op
     p(99.9900) =    774.898 ms/op
     p(99.9990) =    774.898 ms/op
     p(99.9999) =    774.898 ms/op
    p(100.0000) =    774.898 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/)

# Run progress: 47.47% complete, ETA 12:49:29
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5261.754 ms/op
# Warmup Iteration   2: 1438.946 ±(99.9%) 39.369 ms/op
# Warmup Iteration   3: 1452.727 ±(99.9%) 71.979 ms/op
# Warmup Iteration   4: 1491.075 ±(99.9%) 26.858 ms/op
# Warmup Iteration   5: 1487.780 ±(99.9%) 12.454 ms/op
Iteration   1: 1487.180 ±(99.9%) 19.933 ms/op
                 executeFilterQuery·p0.00:   1476.395 ms/op
                 executeFilterQuery·p0.50:   1484.784 ms/op
                 executeFilterQuery·p0.90:   1503.658 ms/op
                 executeFilterQuery·p0.95:   1503.658 ms/op
                 executeFilterQuery·p0.99:   1503.658 ms/op
                 executeFilterQuery·p0.999:  1503.658 ms/op
                 executeFilterQuery·p0.9999: 1503.658 ms/op
                 executeFilterQuery·p1.00:   1503.658 ms/op

Iteration   2: 1494.071 ±(99.9%) 29.730 ms/op
                 executeFilterQuery·p0.00:   1480.589 ms/op
                 executeFilterQuery·p0.50:   1491.075 ms/op
                 executeFilterQuery·p0.90:   1518.338 ms/op
                 executeFilterQuery·p0.95:   1518.338 ms/op
                 executeFilterQuery·p0.99:   1518.338 ms/op
                 executeFilterQuery·p0.999:  1518.338 ms/op
                 executeFilterQuery·p0.9999: 1518.338 ms/op
                 executeFilterQuery·p1.00:   1518.338 ms/op

Iteration   3: 1487.480 ±(99.9%) 28.038 ms/op
                 executeFilterQuery·p0.00:   1472.201 ms/op
                 executeFilterQuery·p0.50:   1484.784 ms/op
                 executeFilterQuery·p0.90:   1512.047 ms/op
                 executeFilterQuery·p0.95:   1512.047 ms/op
                 executeFilterQuery·p0.99:   1512.047 ms/op
                 executeFilterQuery·p0.999:  1512.047 ms/op
                 executeFilterQuery·p0.9999: 1512.047 ms/op
                 executeFilterQuery·p1.00:   1512.047 ms/op

Iteration   4: 1486.881 ±(99.9%) 23.616 ms/op
                 executeFilterQuery·p0.00:   1474.298 ms/op
                 executeFilterQuery·p0.50:   1482.686 ms/op
                 executeFilterQuery·p0.90:   1499.464 ms/op
                 executeFilterQuery·p0.95:   1499.464 ms/op
                 executeFilterQuery·p0.99:   1499.464 ms/op
                 executeFilterQuery·p0.999:  1499.464 ms/op
                 executeFilterQuery·p0.9999: 1499.464 ms/op
                 executeFilterQuery·p1.00:   1499.464 ms/op

Iteration   5: 1476.095 ±(99.9%) 84.511 ms/op
                 executeFilterQuery·p0.00:   1421.869 ms/op
                 executeFilterQuery·p0.50:   1495.269 ms/op
                 executeFilterQuery·p0.90:   1507.852 ms/op
                 executeFilterQuery·p0.95:   1507.852 ms/op
                 executeFilterQuery·p0.99:   1507.852 ms/op
                 executeFilterQuery·p0.999:  1507.852 ms/op
                 executeFilterQuery·p0.9999: 1507.852 ms/op
                 executeFilterQuery·p1.00:   1507.852 ms/op


# Run progress: 47.78% complete, ETA 12:41:43
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1520.435 ±(99.9%) 338.210 ms/op
# Warmup Iteration   2: 1437.747 ±(99.9%) 30.955 ms/op
# Warmup Iteration   3: 1481.488 ±(99.9%) 65.154 ms/op
# Warmup Iteration   4: 1493.771 ±(99.9%) 29.712 ms/op
# Warmup Iteration   5: 1481.488 ±(99.9%) 16.100 ms/op
Iteration   1: 1485.383 ±(99.9%) 12.997 ms/op
                 executeFilterQuery·p0.00:   1476.395 ms/op
                 executeFilterQuery·p0.50:   1488.978 ms/op
                 executeFilterQuery·p0.90:   1491.075 ms/op
                 executeFilterQuery·p0.95:   1491.075 ms/op
                 executeFilterQuery·p0.99:   1491.075 ms/op
                 executeFilterQuery·p0.999:  1491.075 ms/op
                 executeFilterQuery·p0.9999: 1491.075 ms/op
                 executeFilterQuery·p1.00:   1491.075 ms/op

Iteration   2: 1483.885 ±(99.9%) 20.921 ms/op
                 executeFilterQuery·p0.00:   1470.104 ms/op
                 executeFilterQuery·p0.50:   1484.784 ms/op
                 executeFilterQuery·p0.90:   1493.172 ms/op
                 executeFilterQuery·p0.95:   1493.172 ms/op
                 executeFilterQuery·p0.99:   1493.172 ms/op
                 executeFilterQuery·p0.999:  1493.172 ms/op
                 executeFilterQuery·p0.9999: 1493.172 ms/op
                 executeFilterQuery·p1.00:   1493.172 ms/op

Iteration   3: 1488.379 ±(99.9%) 16.967 ms/op
                 executeFilterQuery·p0.00:   1478.492 ms/op
                 executeFilterQuery·p0.50:   1488.978 ms/op
                 executeFilterQuery·p0.90:   1501.561 ms/op
                 executeFilterQuery·p0.95:   1501.561 ms/op
                 executeFilterQuery·p0.99:   1501.561 ms/op
                 executeFilterQuery·p0.999:  1501.561 ms/op
                 executeFilterQuery·p0.9999: 1501.561 ms/op
                 executeFilterQuery·p1.00:   1501.561 ms/op

Iteration   4: 1485.682 ±(99.9%) 15.867 ms/op
                 executeFilterQuery·p0.00:   1476.395 ms/op
                 executeFilterQuery·p0.50:   1488.978 ms/op
                 executeFilterQuery·p0.90:   1493.172 ms/op
                 executeFilterQuery·p0.95:   1493.172 ms/op
                 executeFilterQuery·p0.99:   1493.172 ms/op
                 executeFilterQuery·p0.999:  1493.172 ms/op
                 executeFilterQuery·p0.9999: 1493.172 ms/op
                 executeFilterQuery·p1.00:   1493.172 ms/op

Iteration   5: 1450.930 ±(99.9%) 60.697 ms/op
                 executeFilterQuery·p0.00:   1426.063 ms/op
                 executeFilterQuery·p0.50:   1434.452 ms/op
                 executeFilterQuery·p0.90:   1491.075 ms/op
                 executeFilterQuery·p0.95:   1491.075 ms/op
                 executeFilterQuery·p0.99:   1491.075 ms/op
                 executeFilterQuery·p0.999:  1491.075 ms/op
                 executeFilterQuery·p0.9999: 1491.075 ms/op
                 executeFilterQuery·p1.00:   1491.075 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 70
  mean =   1482.597 ±(99.9%) 8.023 ms/op

  Histogram, ms/op:
    [1420.000, 1430.000) = 3 
    [1430.000, 1440.000) = 3 
    [1440.000, 1450.000) = 0 
    [1450.000, 1460.000) = 1 
    [1460.000, 1470.000) = 1 
    [1470.000, 1480.000) = 11 
    [1480.000, 1490.000) = 27 
    [1490.000, 1500.000) = 16 
    [1500.000, 1510.000) = 6 

  Percentiles, ms/op:
      p(0.0000) =   1421.869 ms/op
     p(50.0000) =   1484.784 ms/op
     p(90.0000) =   1503.448 ms/op
     p(95.0000) =   1507.852 ms/op
     p(99.0000) =   1518.338 ms/op
     p(99.9000) =   1518.338 ms/op
     p(99.9900) =   1518.338 ms/op
     p(99.9990) =   1518.338 ms/op
     p(99.9999) =   1518.338 ms/op
    p(100.0000) =   1518.338 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/)

# Run progress: 48.10% complete, ETA 12:34:01
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1523.731 ±(99.9%) 398.332 ms/op
# Warmup Iteration   2: 1433.553 ±(99.9%) 46.905 ms/op
# Warmup Iteration   3: 1479.990 ±(99.9%) 51.792 ms/op
# Warmup Iteration   4: 1482.986 ±(99.9%) 31.968 ms/op
# Warmup Iteration   5: 1471.002 ±(99.9%) 12.749 ms/op
Iteration   1: 1472.500 ±(99.9%) 29.043 ms/op
                 executeFilterQuery·p0.00:   1461.715 ms/op
                 executeFilterQuery·p0.50:   1470.104 ms/op
                 executeFilterQuery·p0.90:   1497.367 ms/op
                 executeFilterQuery·p0.95:   1497.367 ms/op
                 executeFilterQuery·p0.99:   1497.367 ms/op
                 executeFilterQuery·p0.999:  1497.367 ms/op
                 executeFilterQuery·p0.9999: 1497.367 ms/op
                 executeFilterQuery·p1.00:   1497.367 ms/op

Iteration   2: 1480.290 ±(99.9%) 33.335 ms/op
                 executeFilterQuery·p0.00:   1463.812 ms/op
                 executeFilterQuery·p0.50:   1476.395 ms/op
                 executeFilterQuery·p0.90:   1501.561 ms/op
                 executeFilterQuery·p0.95:   1501.561 ms/op
                 executeFilterQuery·p0.99:   1501.561 ms/op
                 executeFilterQuery·p0.999:  1501.561 ms/op
                 executeFilterQuery·p0.9999: 1501.561 ms/op
                 executeFilterQuery·p1.00:   1501.561 ms/op

Iteration   3: 1463.812 ±(99.9%) 13.905 ms/op
                 executeFilterQuery·p0.00:   1457.521 ms/op
                 executeFilterQuery·p0.50:   1461.715 ms/op
                 executeFilterQuery·p0.90:   1476.395 ms/op
                 executeFilterQuery·p0.95:   1476.395 ms/op
                 executeFilterQuery·p0.99:   1476.395 ms/op
                 executeFilterQuery·p0.999:  1476.395 ms/op
                 executeFilterQuery·p0.9999: 1476.395 ms/op
                 executeFilterQuery·p1.00:   1476.395 ms/op

Iteration   4: 1471.002 ±(99.9%) 21.447 ms/op
                 executeFilterQuery·p0.00:   1457.521 ms/op
                 executeFilterQuery·p0.50:   1468.006 ms/op
                 executeFilterQuery·p0.90:   1480.589 ms/op
                 executeFilterQuery·p0.95:   1480.589 ms/op
                 executeFilterQuery·p0.99:   1480.589 ms/op
                 executeFilterQuery·p0.999:  1480.589 ms/op
                 executeFilterQuery·p0.9999: 1480.589 ms/op
                 executeFilterQuery·p1.00:   1480.589 ms/op

Iteration   5: 1430.557 ±(99.9%) 72.428 ms/op
                 executeFilterQuery·p0.00:   1398.800 ms/op
                 executeFilterQuery·p0.50:   1417.675 ms/op
                 executeFilterQuery·p0.90:   1476.395 ms/op
                 executeFilterQuery·p0.95:   1476.395 ms/op
                 executeFilterQuery·p0.99:   1476.395 ms/op
                 executeFilterQuery·p0.999:  1476.395 ms/op
                 executeFilterQuery·p0.9999: 1476.395 ms/op
                 executeFilterQuery·p1.00:   1476.395 ms/op


# Run progress: 48.42% complete, ETA 12:26:24
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1521.933 ±(99.9%) 405.601 ms/op
# Warmup Iteration   2: 1403.781 ±(99.9%) 25.263 ms/op
# Warmup Iteration   3: 1468.306 ±(99.9%) 67.264 ms/op
# Warmup Iteration   4: 1467.108 ±(99.9%) 38.261 ms/op
# Warmup Iteration   5: 1471.002 ±(99.9%) 28.057 ms/op
Iteration   1: 1480.589 ±(99.9%) 15.183 ms/op
                 executeFilterQuery·p0.00:   1472.201 ms/op
                 executeFilterQuery·p0.50:   1480.589 ms/op
                 executeFilterQuery·p0.90:   1488.978 ms/op
                 executeFilterQuery·p0.95:   1488.978 ms/op
                 executeFilterQuery·p0.99:   1488.978 ms/op
                 executeFilterQuery·p0.999:  1488.978 ms/op
                 executeFilterQuery·p0.9999: 1488.978 ms/op
                 executeFilterQuery·p1.00:   1488.978 ms/op

Iteration   2: 1479.391 ±(99.9%) 16.100 ms/op
                 executeFilterQuery·p0.00:   1470.104 ms/op
                 executeFilterQuery·p0.50:   1478.492 ms/op
                 executeFilterQuery·p0.90:   1488.978 ms/op
                 executeFilterQuery·p0.95:   1488.978 ms/op
                 executeFilterQuery·p0.99:   1488.978 ms/op
                 executeFilterQuery·p0.999:  1488.978 ms/op
                 executeFilterQuery·p0.9999: 1488.978 ms/op
                 executeFilterQuery·p1.00:   1488.978 ms/op

Iteration   3: 1471.302 ±(99.9%) 13.037 ms/op
                 executeFilterQuery·p0.00:   1463.812 ms/op
                 executeFilterQuery·p0.50:   1472.201 ms/op
                 executeFilterQuery·p0.90:   1478.492 ms/op
                 executeFilterQuery·p0.95:   1478.492 ms/op
                 executeFilterQuery·p0.99:   1478.492 ms/op
                 executeFilterQuery·p0.999:  1478.492 ms/op
                 executeFilterQuery·p0.9999: 1478.492 ms/op
                 executeFilterQuery·p1.00:   1478.492 ms/op

Iteration   4: 1474.897 ±(99.9%) 20.717 ms/op
                 executeFilterQuery·p0.00:   1461.715 ms/op
                 executeFilterQuery·p0.50:   1476.395 ms/op
                 executeFilterQuery·p0.90:   1484.784 ms/op
                 executeFilterQuery·p0.95:   1484.784 ms/op
                 executeFilterQuery·p0.99:   1484.784 ms/op
                 executeFilterQuery·p0.999:  1484.784 ms/op
                 executeFilterQuery·p0.9999: 1484.784 ms/op
                 executeFilterQuery·p1.00:   1484.784 ms/op

Iteration   5: 1433.254 ±(99.9%) 44.380 ms/op
                 executeFilterQuery·p0.00:   1417.675 ms/op
                 executeFilterQuery·p0.50:   1428.161 ms/op
                 executeFilterQuery·p0.90:   1474.298 ms/op
                 executeFilterQuery·p0.95:   1474.298 ms/op
                 executeFilterQuery·p0.99:   1474.298 ms/op
                 executeFilterQuery·p0.999:  1474.298 ms/op
                 executeFilterQuery·p0.9999: 1474.298 ms/op
                 executeFilterQuery·p1.00:   1474.298 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 70
  mean =   1465.759 ±(99.9%) 9.204 ms/op

  Histogram, ms/op:
    [1300.000, 1325.000) = 0 
    [1325.000, 1350.000) = 0 
    [1350.000, 1375.000) = 0 
    [1375.000, 1400.000) = 2 
    [1400.000, 1425.000) = 4 
    [1425.000, 1450.000) = 5 
    [1450.000, 1475.000) = 32 
    [1475.000, 1500.000) = 26 
    [1500.000, 1525.000) = 1 
    [1525.000, 1550.000) = 0 
    [1550.000, 1575.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   1398.800 ms/op
     p(50.0000) =   1472.201 ms/op
     p(90.0000) =   1486.881 ms/op
     p(95.0000) =   1491.809 ms/op
     p(99.0000) =   1501.561 ms/op
     p(99.9000) =   1501.561 ms/op
     p(99.9900) =   1501.561 ms/op
     p(99.9990) =   1501.561 ms/op
     p(99.9999) =   1501.561 ms/op
    p(100.0000) =   1501.561 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/)

# Run progress: 48.73% complete, ETA 12:18:52
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5036.311 ms/op
# Warmup Iteration   2: 1460.517 ±(99.9%) 65.040 ms/op
# Warmup Iteration   3: 1450.031 ±(99.9%) 38.455 ms/op
# Warmup Iteration   4: 1509.650 ±(99.9%) 25.643 ms/op
# Warmup Iteration   5: 1509.949 ±(99.9%) 13.359 ms/op
Iteration   1: 1501.561 ±(99.9%) 22.154 ms/op
                 executeFilterQuery·p0.00:   1488.978 ms/op
                 executeFilterQuery·p0.50:   1503.658 ms/op
                 executeFilterQuery·p0.90:   1514.144 ms/op
                 executeFilterQuery·p0.95:   1514.144 ms/op
                 executeFilterQuery·p0.99:   1514.144 ms/op
                 executeFilterQuery·p0.999:  1514.144 ms/op
                 executeFilterQuery·p0.9999: 1514.144 ms/op
                 executeFilterQuery·p1.00:   1514.144 ms/op

Iteration   2: 1491.974 ±(99.9%) 12.454 ms/op
                 executeFilterQuery·p0.00:   1486.881 ms/op
                 executeFilterQuery·p0.50:   1488.978 ms/op
                 executeFilterQuery·p0.90:   1501.561 ms/op
                 executeFilterQuery·p0.95:   1501.561 ms/op
                 executeFilterQuery·p0.99:   1501.561 ms/op
                 executeFilterQuery·p0.999:  1501.561 ms/op
                 executeFilterQuery·p0.9999: 1501.561 ms/op
                 executeFilterQuery·p1.00:   1501.561 ms/op

Iteration   3: 1491.375 ±(99.9%) 19.933 ms/op
                 executeFilterQuery·p0.00:   1474.298 ms/op
                 executeFilterQuery·p0.50:   1493.172 ms/op
                 executeFilterQuery·p0.90:   1501.561 ms/op
                 executeFilterQuery·p0.95:   1501.561 ms/op
                 executeFilterQuery·p0.99:   1501.561 ms/op
                 executeFilterQuery·p0.999:  1501.561 ms/op
                 executeFilterQuery·p0.9999: 1501.561 ms/op
                 executeFilterQuery·p1.00:   1501.561 ms/op

Iteration   4: 1495.269 ±(99.9%) 23.299 ms/op
                 executeFilterQuery·p0.00:   1482.686 ms/op
                 executeFilterQuery·p0.50:   1495.269 ms/op
                 executeFilterQuery·p0.90:   1514.144 ms/op
                 executeFilterQuery·p0.95:   1514.144 ms/op
                 executeFilterQuery·p0.99:   1514.144 ms/op
                 executeFilterQuery·p0.999:  1514.144 ms/op
                 executeFilterQuery·p0.9999: 1514.144 ms/op
                 executeFilterQuery·p1.00:   1514.144 ms/op

Iteration   5: 1503.358 ±(99.9%) 26.075 ms/op
                 executeFilterQuery·p0.00:   1491.075 ms/op
                 executeFilterQuery·p0.50:   1497.367 ms/op
                 executeFilterQuery·p0.90:   1516.241 ms/op
                 executeFilterQuery·p0.95:   1516.241 ms/op
                 executeFilterQuery·p0.99:   1516.241 ms/op
                 executeFilterQuery·p0.999:  1516.241 ms/op
                 executeFilterQuery·p0.9999: 1516.241 ms/op
                 executeFilterQuery·p1.00:   1516.241 ms/op


# Run progress: 49.05% complete, ETA 12:11:25
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int arrowVectorLength = filter_query_table_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_0.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_1.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(filter_query_table_vc_2.getDataBufferAddress(), (arrowVectorLength * filter_query_table_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMDVector = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * filter_query_table_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_sel_mask = SIMDVector.compare(jdk.incubator.vector.VectorOperators.LT, 3000, inRangeSIMDMask);
        jdk.incubator.vector.IntVector SIMDVector_0 = oCtx.createIntVector(IntVectorSpecies, col_1_ms, (currentVectorOffset * filter_query_table_vc_1.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_0_sel_mask = SIMDVector_0.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_sel_mask);
        jdk.incubator.vector.IntVector SIMDVector_1 = oCtx.createIntVector(IntVectorSpecies, col_2_ms, (currentVectorOffset * filter_query_table_vc_2.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, SIMDVector_0_sel_mask);
        jdk.incubator.vector.VectorMask<Integer> SIMDVector_1_sel_mask = SIMDVector_1.compare(jdk.incubator.vector.VectorOperators.LT, 3000, SIMDVector_0_sel_mask);
        count += SIMDVector_1_sel_mask.trueCount();
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

1545.301 ±(99.9%) 454.656 ms/op
# Warmup Iteration   2: 1440.743 ±(99.9%) 35.135 ms/op
# Warmup Iteration   3: 1477.893 ±(99.9%) 71.148 ms/op
# Warmup Iteration   4: 1493.172 ±(99.9%) 12.497 ms/op
# Warmup Iteration   5: 1494.371 ±(99.9%) 13.596 ms/op
Iteration   1: 1491.674 ±(99.9%) 16.297 ms/op
                 executeFilterQuery·p0.00:   1480.589 ms/op
                 executeFilterQuery·p0.50:   1491.075 ms/op
                 executeFilterQuery·p0.90:   1503.658 ms/op
                 executeFilterQuery·p0.95:   1503.658 ms/op
                 executeFilterQuery·p0.99:   1503.658 ms/op
                 executeFilterQuery·p0.999:  1503.658 ms/op
                 executeFilterQuery·p0.9999: 1503.658 ms/op
                 executeFilterQuery·p1.00:   1503.658 ms/op

Iteration   2: 1488.379 ±(99.9%) 17.613 ms/op
                 executeFilterQuery·p0.00:   1480.589 ms/op
                 executeFilterQuery·p0.50:   1484.784 ms/op
                 executeFilterQuery·p0.90:   1499.464 ms/op
                 executeFilterQuery·p0.95:   1499.464 ms/op
                 executeFilterQuery·p0.99:   1499.464 ms/op
                 executeFilterQuery·p0.999:  1499.464 ms/op
                 executeFilterQuery·p0.9999: 1499.464 ms/op
                 executeFilterQuery·p1.00:   1499.464 ms/op

Iteration   3: 1492.573 ±(99.9%) 11.797 ms/op
                 executeFilterQuery·p0.00:   1484.784 ms/op
                 executeFilterQuery·p0.50:   1493.172 ms/op
                 executeFilterQuery·p0.90:   1499.464 ms/op
                 executeFilterQuery·p0.95:   1499.464 ms/op
                 executeFilterQuery·p0.99:   1499.464 ms/op
                 executeFilterQuery·p0.999:  1499.464 ms/op
                 executeFilterQuery·p0.9999: 1499.464 ms/op
                 executeFilterQuery·p1.00:   1499.464 ms/op

Iteration   4: 1497.966 ±(99.9%) 19.610 ms/op
                 executeFilterQuery·p0.00:   1484.784 ms/op
                 executeFilterQuery·p0.50:   1499.464 ms/op
                 executeFilterQuery·p0.90:   1507.852 ms/op
                 executeFilterQuery·p0.95:   1507.852 ms/op
                 executeFilterQuery·p0.99:   1507.852 ms/op
                 executeFilterQuery·p0.999:  1507.852 ms/op
                 executeFilterQuery·p0.9999: 1507.852 ms/op
                 executeFilterQuery·p1.00:   1507.852 ms/op

Iteration   5: 1461.116 ±(99.9%) 79.678 ms/op
                 executeFilterQuery·p0.00:   1415.578 ms/op
                 executeFilterQuery·p0.50:   1472.201 ms/op
                 executeFilterQuery·p0.90:   1499.464 ms/op
                 executeFilterQuery·p0.95:   1499.464 ms/op
                 executeFilterQuery·p0.99:   1499.464 ms/op
                 executeFilterQuery·p0.999:  1499.464 ms/op
                 executeFilterQuery·p0.9999: 1499.464 ms/op
                 executeFilterQuery·p1.00:   1499.464 ms/op



Result "benchmarks.filter_query.NonVectorisedSimd.executeFilterQuery":
  N = 70
  mean =   1491.524 ±(99.9%) 7.015 ms/op

  Histogram, ms/op:
    [1400.000, 1412.500) = 0 
    [1412.500, 1425.000) = 1 
    [1425.000, 1437.500) = 2 
    [1437.500, 1450.000) = 0 
    [1450.000, 1462.500) = 0 
    [1462.500, 1475.000) = 2 
    [1475.000, 1487.500) = 13 
    [1487.500, 1500.000) = 37 
    [1500.000, 1512.500) = 10 
    [1512.500, 1525.000) = 5 
    [1525.000, 1537.500) = 0 
    [1537.500, 1550.000) = 0 
    [1550.000, 1562.500) = 0 
    [1562.500, 1575.000) = 0 
    [1575.000, 1587.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   1415.578 ms/op
     p(50.0000) =   1493.172 ms/op
     p(90.0000) =   1507.852 ms/op
     p(95.0000) =   1514.144 ms/op
     p(99.0000) =   1516.241 ms/op
     p(99.9000) =   1516.241 ms/op
     p(99.9900) =   1516.241 ms/op
     p(99.9990) =   1516.241 ms/op
     p(99.9999) =   1516.241 ms/op
    p(100.0000) =   1516.241 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/)

# Run progress: 49.37% complete, ETA 12:04:02
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

79.366 ±(99.9%) 3.095 ms/op
# Warmup Iteration   2: 77.264 ±(99.9%) 0.697 ms/op
# Warmup Iteration   3: 78.060 ±(99.9%) 0.648 ms/op
# Warmup Iteration   4: 78.309 ±(99.9%) 0.597 ms/op
# Warmup Iteration   5: 78.001 ±(99.9%) 0.711 ms/op
Iteration   1: 75.643 ±(99.9%) 0.803 ms/op
                 executeFilterQuery·p0.00:   69.337 ms/op
                 executeFilterQuery·p0.50:   75.760 ms/op
                 executeFilterQuery·p0.90:   79.063 ms/op
                 executeFilterQuery·p0.95:   79.823 ms/op
                 executeFilterQuery·p0.99:   87.682 ms/op
                 executeFilterQuery·p0.999:  90.702 ms/op
                 executeFilterQuery·p0.9999: 90.702 ms/op
                 executeFilterQuery·p1.00:   90.702 ms/op

Iteration   2: 78.078 ±(99.9%) 0.554 ms/op
                 executeFilterQuery·p0.00:   71.827 ms/op
                 executeFilterQuery·p0.50:   78.512 ms/op
                 executeFilterQuery·p0.90:   79.823 ms/op
                 executeFilterQuery·p0.95:   80.157 ms/op
                 executeFilterQuery·p0.99:   81.523 ms/op
                 executeFilterQuery·p0.999:  81.789 ms/op
                 executeFilterQuery·p0.9999: 81.789 ms/op
                 executeFilterQuery·p1.00:   81.789 ms/op

Iteration   3: 78.290 ±(99.9%) 0.629 ms/op
                 executeFilterQuery·p0.00:   71.696 ms/op
                 executeFilterQuery·p0.50:   78.774 ms/op
                 executeFilterQuery·p0.90:   80.347 ms/op
                 executeFilterQuery·p0.95:   80.740 ms/op
                 executeFilterQuery·p0.99:   81.474 ms/op
                 executeFilterQuery·p0.999:  81.658 ms/op
                 executeFilterQuery·p0.9999: 81.658 ms/op
                 executeFilterQuery·p1.00:   81.658 ms/op

Iteration   4: 77.935 ±(99.9%) 0.604 ms/op
                 executeFilterQuery·p0.00:   71.959 ms/op
                 executeFilterQuery·p0.50:   78.381 ms/op
                 executeFilterQuery·p0.90:   79.823 ms/op
                 executeFilterQuery·p0.95:   79.954 ms/op
                 executeFilterQuery·p0.99:   85.076 ms/op
                 executeFilterQuery·p0.999:  86.901 ms/op
                 executeFilterQuery·p0.9999: 86.901 ms/op
                 executeFilterQuery·p1.00:   86.901 ms/op

Iteration   5: 75.642 ±(99.9%) 0.690 ms/op
                 executeFilterQuery·p0.00:   69.075 ms/op
                 executeFilterQuery·p0.50:   75.694 ms/op
                 executeFilterQuery·p0.90:   78.866 ms/op
                 executeFilterQuery·p0.95:   79.692 ms/op
                 executeFilterQuery·p0.99:   80.304 ms/op
                 executeFilterQuery·p0.999:  80.347 ms/op
                 executeFilterQuery·p0.9999: 80.347 ms/op
                 executeFilterQuery·p1.00:   80.347 ms/op


# Run progress: 49.68% complete, ETA 11:56:39
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

79.399 ±(99.9%) 2.920 ms/op
# Warmup Iteration   2: 77.802 ±(99.9%) 0.766 ms/op
# Warmup Iteration   3: 78.097 ±(99.9%) 0.809 ms/op
# Warmup Iteration   4: 78.548 ±(99.9%) 0.618 ms/op
# Warmup Iteration   5: 78.310 ±(99.9%) 0.736 ms/op
Iteration   1: 77.188 ±(99.9%) 0.718 ms/op
                 executeFilterQuery·p0.00:   70.517 ms/op
                 executeFilterQuery·p0.50:   76.939 ms/op
                 executeFilterQuery·p0.90:   80.085 ms/op
                 executeFilterQuery·p0.95:   80.740 ms/op
                 executeFilterQuery·p0.99:   84.869 ms/op
                 executeFilterQuery·p0.999:  86.245 ms/op
                 executeFilterQuery·p0.9999: 86.245 ms/op
                 executeFilterQuery·p1.00:   86.245 ms/op

Iteration   2: 75.666 ±(99.9%) 0.666 ms/op
                 executeFilterQuery·p0.00:   69.599 ms/op
                 executeFilterQuery·p0.50:   76.284 ms/op
                 executeFilterQuery·p0.90:   77.962 ms/op
                 executeFilterQuery·p0.95:   78.512 ms/op
                 executeFilterQuery·p0.99:   80.274 ms/op
                 executeFilterQuery·p0.999:  80.609 ms/op
                 executeFilterQuery·p0.9999: 80.609 ms/op
                 executeFilterQuery·p1.00:   80.609 ms/op

Iteration   3: 75.314 ±(99.9%) 0.688 ms/op
                 executeFilterQuery·p0.00:   69.468 ms/op
                 executeFilterQuery·p0.50:   76.284 ms/op
                 executeFilterQuery·p0.90:   77.437 ms/op
                 executeFilterQuery·p0.95:   77.516 ms/op
                 executeFilterQuery·p0.99:   77.904 ms/op
                 executeFilterQuery·p0.999:  77.988 ms/op
                 executeFilterQuery·p0.9999: 77.988 ms/op
                 executeFilterQuery·p1.00:   77.988 ms/op

Iteration   4: 75.234 ±(99.9%) 0.758 ms/op
                 executeFilterQuery·p0.00:   69.468 ms/op
                 executeFilterQuery·p0.50:   76.153 ms/op
                 executeFilterQuery·p0.90:   77.464 ms/op
                 executeFilterQuery·p0.95:   77.909 ms/op
                 executeFilterQuery·p0.99:   78.690 ms/op
                 executeFilterQuery·p0.999:  78.774 ms/op
                 executeFilterQuery·p0.9999: 78.774 ms/op
                 executeFilterQuery·p1.00:   78.774 ms/op

Iteration   5: 75.863 ±(99.9%) 0.640 ms/op
                 executeFilterQuery·p0.00:   69.861 ms/op
                 executeFilterQuery·p0.50:   76.284 ms/op
                 executeFilterQuery·p0.90:   77.988 ms/op
                 executeFilterQuery·p0.95:   78.512 ms/op
                 executeFilterQuery·p0.99:   80.856 ms/op
                 executeFilterQuery·p0.999:  81.527 ms/op
                 executeFilterQuery·p0.9999: 81.527 ms/op
                 executeFilterQuery·p1.00:   81.527 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 1299
  mean =     76.471 ±(99.9%) 0.236 ms/op

  Histogram, ms/op:
    [ 60.000,  62.500) = 0 
    [ 62.500,  65.000) = 0 
    [ 65.000,  67.500) = 0 
    [ 67.500,  70.000) = 38 
    [ 70.000,  72.500) = 85 
    [ 72.500,  75.000) = 155 
    [ 75.000,  77.500) = 582 
    [ 77.500,  80.000) = 385 
    [ 80.000,  82.500) = 51 
    [ 82.500,  85.000) = 0 
    [ 85.000,  87.500) = 2 
    [ 87.500,  90.000) = 0 
    [ 90.000,  92.500) = 1 
    [ 92.500,  95.000) = 0 
    [ 95.000,  97.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     69.075 ms/op
     p(50.0000) =     76.677 ms/op
     p(90.0000) =     79.430 ms/op
     p(95.0000) =     79.954 ms/op
     p(99.0000) =     80.871 ms/op
     p(99.9000) =     89.561 ms/op
     p(99.9900) =     90.702 ms/op
     p(99.9990) =     90.702 ms/op
     p(99.9999) =     90.702 ms/op
    p(100.0000) =     90.702 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/)

# Run progress: 50.00% complete, ETA 11:49:21
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

81.334 ±(99.9%) 3.522 ms/op
# Warmup Iteration   2: 78.177 ±(99.9%) 0.968 ms/op
# Warmup Iteration   3: 78.704 ±(99.9%) 0.858 ms/op
# Warmup Iteration   4: 79.851 ±(99.9%) 1.058 ms/op
# Warmup Iteration   5: 79.583 ±(99.9%) 0.740 ms/op
Iteration   1: 77.979 ±(99.9%) 0.772 ms/op
                 executeFilterQuery·p0.00:   71.565 ms/op
                 executeFilterQuery·p0.50:   77.857 ms/op
                 executeFilterQuery·p0.90:   80.871 ms/op
                 executeFilterQuery·p0.95:   81.527 ms/op
                 executeFilterQuery·p0.99:   88.783 ms/op
                 executeFilterQuery·p0.999:  91.095 ms/op
                 executeFilterQuery·p0.9999: 91.095 ms/op
                 executeFilterQuery·p1.00:   91.095 ms/op

Iteration   2: 77.960 ±(99.9%) 0.635 ms/op
                 executeFilterQuery·p0.00:   71.565 ms/op
                 executeFilterQuery·p0.50:   78.119 ms/op
                 executeFilterQuery·p0.90:   79.587 ms/op
                 executeFilterQuery·p0.95:   80.944 ms/op
                 executeFilterQuery·p0.99:   86.661 ms/op
                 executeFilterQuery·p0.999:  87.687 ms/op
                 executeFilterQuery·p0.9999: 87.687 ms/op
                 executeFilterQuery·p1.00:   87.687 ms/op

Iteration   3: 78.916 ±(99.9%) 0.678 ms/op
                 executeFilterQuery·p0.00:   73.400 ms/op
                 executeFilterQuery·p0.50:   78.119 ms/op
                 executeFilterQuery·p0.90:   81.658 ms/op
                 executeFilterQuery·p0.95:   82.051 ms/op
                 executeFilterQuery·p0.99:   88.569 ms/op
                 executeFilterQuery·p0.999:  88.605 ms/op
                 executeFilterQuery·p0.9999: 88.605 ms/op
                 executeFilterQuery·p1.00:   88.605 ms/op

Iteration   4: 78.226 ±(99.9%) 0.684 ms/op
                 executeFilterQuery·p0.00:   71.172 ms/op
                 executeFilterQuery·p0.50:   77.988 ms/op
                 executeFilterQuery·p0.90:   81.422 ms/op
                 executeFilterQuery·p0.95:   81.789 ms/op
                 executeFilterQuery·p0.99:   83.257 ms/op
                 executeFilterQuery·p0.999:  83.624 ms/op
                 executeFilterQuery·p0.9999: 83.624 ms/op
                 executeFilterQuery·p1.00:   83.624 ms/op

Iteration   5: 77.276 ±(99.9%) 0.668 ms/op
                 executeFilterQuery·p0.00:   71.172 ms/op
                 executeFilterQuery·p0.50:   77.464 ms/op
                 executeFilterQuery·p0.90:   79.299 ms/op
                 executeFilterQuery·p0.95:   81.265 ms/op
                 executeFilterQuery·p0.99:   85.223 ms/op
                 executeFilterQuery·p0.999:  86.639 ms/op
                 executeFilterQuery·p0.9999: 86.639 ms/op
                 executeFilterQuery·p1.00:   86.639 ms/op


# Run progress: 50.32% complete, ETA 11:42:06
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

80.751 ±(99.9%) 3.201 ms/op
# Warmup Iteration   2: 78.025 ±(99.9%) 0.787 ms/op
# Warmup Iteration   3: 78.723 ±(99.9%) 0.862 ms/op
# Warmup Iteration   4: 79.548 ±(99.9%) 0.728 ms/op
# Warmup Iteration   5: 79.726 ±(99.9%) 0.629 ms/op
Iteration   1: 76.827 ±(99.9%) 0.761 ms/op
                 executeFilterQuery·p0.00:   70.648 ms/op
                 executeFilterQuery·p0.50:   77.332 ms/op
                 executeFilterQuery·p0.90:   79.167 ms/op
                 executeFilterQuery·p0.95:   79.692 ms/op
                 executeFilterQuery·p0.99:   84.332 ms/op
                 executeFilterQuery·p0.999:  85.983 ms/op
                 executeFilterQuery·p0.9999: 85.983 ms/op
                 executeFilterQuery·p1.00:   85.983 ms/op

Iteration   2: 76.044 ±(99.9%) 0.904 ms/op
                 executeFilterQuery·p0.00:   70.648 ms/op
                 executeFilterQuery·p0.50:   77.070 ms/op
                 executeFilterQuery·p0.90:   78.905 ms/op
                 executeFilterQuery·p0.95:   80.871 ms/op
                 executeFilterQuery·p0.99:   83.688 ms/op
                 executeFilterQuery·p0.999:  84.541 ms/op
                 executeFilterQuery·p0.9999: 84.541 ms/op
                 executeFilterQuery·p1.00:   84.541 ms/op

Iteration   3: 75.611 ±(99.9%) 0.986 ms/op
                 executeFilterQuery·p0.00:   70.517 ms/op
                 executeFilterQuery·p0.50:   77.201 ms/op
                 executeFilterQuery·p0.90:   78.381 ms/op
                 executeFilterQuery·p0.95:   78.565 ms/op
                 executeFilterQuery·p0.99:   86.329 ms/op
                 executeFilterQuery·p0.999:  87.294 ms/op
                 executeFilterQuery·p0.9999: 87.294 ms/op
                 executeFilterQuery·p1.00:   87.294 ms/op

Iteration   4: 76.536 ±(99.9%) 0.697 ms/op
                 executeFilterQuery·p0.00:   71.172 ms/op
                 executeFilterQuery·p0.50:   77.070 ms/op
                 executeFilterQuery·p0.90:   78.774 ms/op
                 executeFilterQuery·p0.95:   80.282 ms/op
                 executeFilterQuery·p0.99:   81.619 ms/op
                 executeFilterQuery·p0.999:  81.658 ms/op
                 executeFilterQuery·p0.9999: 81.658 ms/op
                 executeFilterQuery·p1.00:   81.658 ms/op

Iteration   5: 78.315 ±(99.9%) 0.809 ms/op
                 executeFilterQuery·p0.00:   71.434 ms/op
                 executeFilterQuery·p0.50:   77.988 ms/op
                 executeFilterQuery·p0.90:   81.160 ms/op
                 executeFilterQuery·p0.95:   81.605 ms/op
                 executeFilterQuery·p0.99:   88.647 ms/op
                 executeFilterQuery·p0.999:  89.784 ms/op
                 executeFilterQuery·p0.9999: 89.784 ms/op
                 executeFilterQuery·p1.00:   89.784 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 1283
  mean =     77.357 ±(99.9%) 0.255 ms/op

  Histogram, ms/op:
    [ 70.000,  72.500) = 111 
    [ 72.500,  75.000) = 101 
    [ 75.000,  77.500) = 376 
    [ 77.500,  80.000) = 522 
    [ 80.000,  82.500) = 157 
    [ 82.500,  85.000) = 7 
    [ 85.000,  87.500) = 4 
    [ 87.500,  90.000) = 4 
    [ 90.000,  92.500) = 1 
    [ 92.500,  95.000) = 0 
    [ 95.000,  97.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =     70.517 ms/op
     p(50.0000) =     77.726 ms/op
     p(90.0000) =     80.740 ms/op
     p(95.0000) =     81.396 ms/op
     p(99.0000) =     83.708 ms/op
     p(99.9000) =     90.723 ms/op
     p(99.9900) =     91.095 ms/op
     p(99.9990) =     91.095 ms/op
     p(99.9999) =     91.095 ms/op
    p(100.0000) =     91.095 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/)

# Run progress: 50.63% complete, ETA 11:34:56
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

100.036 ±(99.9%) 4.389 ms/op
# Warmup Iteration   2: 105.814 ±(99.9%) 0.694 ms/op
# Warmup Iteration   3: 105.869 ±(99.9%) 0.681 ms/op
# Warmup Iteration   4: 105.329 ±(99.9%) 0.450 ms/op
# Warmup Iteration   5: 105.371 ±(99.9%) 0.396 ms/op
Iteration   1: 105.406 ±(99.9%) 0.474 ms/op
                 executeFilterQuery·p0.00:   103.416 ms/op
                 executeFilterQuery·p0.50:   105.120 ms/op
                 executeFilterQuery·p0.90:   106.955 ms/op
                 executeFilterQuery·p0.95:   107.381 ms/op
                 executeFilterQuery·p0.99:   110.100 ms/op
                 executeFilterQuery·p0.999:  110.100 ms/op
                 executeFilterQuery·p0.9999: 110.100 ms/op
                 executeFilterQuery·p1.00:   110.100 ms/op

Iteration   2: 105.650 ±(99.9%) 0.486 ms/op
                 executeFilterQuery·p0.00:   103.416 ms/op
                 executeFilterQuery·p0.50:   106.037 ms/op
                 executeFilterQuery·p0.90:   107.217 ms/op
                 executeFilterQuery·p0.95:   107.512 ms/op
                 executeFilterQuery·p0.99:   108.921 ms/op
                 executeFilterQuery·p0.999:  108.921 ms/op
                 executeFilterQuery·p0.9999: 108.921 ms/op
                 executeFilterQuery·p1.00:   108.921 ms/op

Iteration   3: 105.514 ±(99.9%) 0.503 ms/op
                 executeFilterQuery·p0.00:   103.285 ms/op
                 executeFilterQuery·p0.50:   105.710 ms/op
                 executeFilterQuery·p0.90:   107.217 ms/op
                 executeFilterQuery·p0.95:   107.479 ms/op
                 executeFilterQuery·p0.99:   109.707 ms/op
                 executeFilterQuery·p0.999:  109.707 ms/op
                 executeFilterQuery·p0.9999: 109.707 ms/op
                 executeFilterQuery·p1.00:   109.707 ms/op

Iteration   4: 105.611 ±(99.9%) 0.711 ms/op
                 executeFilterQuery·p0.00:   103.285 ms/op
                 executeFilterQuery·p0.50:   105.775 ms/op
                 executeFilterQuery·p0.90:   106.955 ms/op
                 executeFilterQuery·p0.95:   108.134 ms/op
                 executeFilterQuery·p0.99:   119.800 ms/op
                 executeFilterQuery·p0.999:  119.800 ms/op
                 executeFilterQuery·p0.9999: 119.800 ms/op
                 executeFilterQuery·p1.00:   119.800 ms/op

Iteration   5: 105.238 ±(99.9%) 0.375 ms/op
                 executeFilterQuery·p0.00:   103.416 ms/op
                 executeFilterQuery·p0.50:   105.382 ms/op
                 executeFilterQuery·p0.90:   106.614 ms/op
                 executeFilterQuery·p0.95:   106.824 ms/op
                 executeFilterQuery·p0.99:   107.217 ms/op
                 executeFilterQuery·p0.999:  107.217 ms/op
                 executeFilterQuery·p0.9999: 107.217 ms/op
                 executeFilterQuery·p1.00:   107.217 ms/op


# Run progress: 50.95% complete, ETA 11:27:51
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

101.503 ±(99.9%) 4.457 ms/op
# Warmup Iteration   2: 110.571 ±(99.9%) 0.873 ms/op
# Warmup Iteration   3: 110.424 ±(99.9%) 0.383 ms/op
# Warmup Iteration   4: 110.182 ±(99.9%) 0.425 ms/op
# Warmup Iteration   5: 110.320 ±(99.9%) 0.545 ms/op
Iteration   1: 109.895 ±(99.9%) 0.398 ms/op
                 executeFilterQuery·p0.00:   108.528 ms/op
                 executeFilterQuery·p0.50:   109.445 ms/op
                 executeFilterQuery·p0.90:   111.542 ms/op
                 executeFilterQuery·p0.95:   111.850 ms/op
                 executeFilterQuery·p0.99:   113.115 ms/op
                 executeFilterQuery·p0.999:  113.115 ms/op
                 executeFilterQuery·p0.9999: 113.115 ms/op
                 executeFilterQuery·p1.00:   113.115 ms/op

Iteration   2: 110.082 ±(99.9%) 0.486 ms/op
                 executeFilterQuery·p0.00:   108.659 ms/op
                 executeFilterQuery·p0.50:   109.576 ms/op
                 executeFilterQuery·p0.90:   111.542 ms/op
                 executeFilterQuery·p0.95:   112.525 ms/op
                 executeFilterQuery·p0.99:   116.130 ms/op
                 executeFilterQuery·p0.999:  116.130 ms/op
                 executeFilterQuery·p0.9999: 116.130 ms/op
                 executeFilterQuery·p1.00:   116.130 ms/op

Iteration   3: 110.138 ±(99.9%) 0.537 ms/op
                 executeFilterQuery·p0.00:   108.528 ms/op
                 executeFilterQuery·p0.50:   109.576 ms/op
                 executeFilterQuery·p0.90:   111.516 ms/op
                 executeFilterQuery·p0.95:   111.909 ms/op
                 executeFilterQuery·p0.99:   121.373 ms/op
                 executeFilterQuery·p0.999:  121.373 ms/op
                 executeFilterQuery·p0.9999: 121.373 ms/op
                 executeFilterQuery·p1.00:   121.373 ms/op

Iteration   4: 109.766 ±(99.9%) 0.260 ms/op
                 executeFilterQuery·p0.00:   108.659 ms/op
                 executeFilterQuery·p0.50:   109.576 ms/op
                 executeFilterQuery·p0.90:   110.756 ms/op
                 executeFilterQuery·p0.95:   111.411 ms/op
                 executeFilterQuery·p0.99:   112.984 ms/op
                 executeFilterQuery·p0.999:  112.984 ms/op
                 executeFilterQuery·p0.9999: 112.984 ms/op
                 executeFilterQuery·p1.00:   112.984 ms/op

Iteration   5: 109.959 ±(99.9%) 0.443 ms/op
                 executeFilterQuery·p0.00:   108.528 ms/op
                 executeFilterQuery·p0.50:   109.707 ms/op
                 executeFilterQuery·p0.90:   110.887 ms/op
                 executeFilterQuery·p0.95:   111.647 ms/op
                 executeFilterQuery·p0.99:   118.620 ms/op
                 executeFilterQuery·p0.999:  118.620 ms/op
                 executeFilterQuery·p0.9999: 118.620 ms/op
                 executeFilterQuery·p1.00:   118.620 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 925
  mean =    107.680 ±(99.9%) 0.285 ms/op

  Histogram, ms/op:
    [100.000, 102.500) = 0 
    [102.500, 105.000) = 196 
    [105.000, 107.500) = 261 
    [107.500, 110.000) = 314 
    [110.000, 112.500) = 142 
    [112.500, 115.000) = 8 
    [115.000, 117.500) = 1 
    [117.500, 120.000) = 2 
    [120.000, 122.500) = 1 
    [122.500, 125.000) = 0 
    [125.000, 127.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =    103.285 ms/op
     p(50.0000) =    107.872 ms/op
     p(90.0000) =    110.808 ms/op
     p(95.0000) =    111.411 ms/op
     p(99.0000) =    112.950 ms/op
     p(99.9000) =    121.373 ms/op
     p(99.9900) =    121.373 ms/op
     p(99.9990) =    121.373 ms/op
     p(99.9999) =    121.373 ms/op
    p(100.0000) =    121.373 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/)

# Run progress: 51.27% complete, ETA 11:20:49
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

744.938 ±(99.9%) 49.008 ms/op
# Warmup Iteration   2: 713.781 ±(99.9%) 14.994 ms/op
# Warmup Iteration   3: 736.325 ±(99.9%) 11.939 ms/op
# Warmup Iteration   4: 743.515 ±(99.9%) 5.007 ms/op
# Warmup Iteration   5: 737.449 ±(99.9%) 19.990 ms/op
Iteration   1: 719.847 ±(99.9%) 15.210 ms/op
                 executeFilterQuery·p0.00:   699.400 ms/op
                 executeFilterQuery·p0.50:   717.226 ms/op
                 executeFilterQuery·p0.90:   742.916 ms/op
                 executeFilterQuery·p0.95:   744.489 ms/op
                 executeFilterQuery·p0.99:   744.489 ms/op
                 executeFilterQuery·p0.999:  744.489 ms/op
                 executeFilterQuery·p0.9999: 744.489 ms/op
                 executeFilterQuery·p1.00:   744.489 ms/op

Iteration   2: 707.649 ±(99.9%) 6.035 ms/op
                 executeFilterQuery·p0.00:   699.400 ms/op
                 executeFilterQuery·p0.50:   707.789 ms/op
                 executeFilterQuery·p0.90:   716.387 ms/op
                 executeFilterQuery·p0.95:   718.275 ms/op
                 executeFilterQuery·p0.99:   718.275 ms/op
                 executeFilterQuery·p0.999:  718.275 ms/op
                 executeFilterQuery·p0.9999: 718.275 ms/op
                 executeFilterQuery·p1.00:   718.275 ms/op

Iteration   3: 702.476 ±(99.9%) 11.844 ms/op
                 executeFilterQuery·p0.00:   671.089 ms/op
                 executeFilterQuery·p0.50:   701.497 ms/op
                 executeFilterQuery·p0.90:   716.177 ms/op
                 executeFilterQuery·p0.95:   719.323 ms/op
                 executeFilterQuery·p0.99:   719.323 ms/op
                 executeFilterQuery·p0.999:  719.323 ms/op
                 executeFilterQuery·p0.9999: 719.323 ms/op
                 executeFilterQuery·p1.00:   719.323 ms/op

Iteration   4: 708.488 ±(99.9%) 4.787 ms/op
                 executeFilterQuery·p0.00:   700.449 ms/op
                 executeFilterQuery·p0.50:   708.837 ms/op
                 executeFilterQuery·p0.90:   715.548 ms/op
                 executeFilterQuery·p0.95:   716.177 ms/op
                 executeFilterQuery·p0.99:   716.177 ms/op
                 executeFilterQuery·p0.999:  716.177 ms/op
                 executeFilterQuery·p0.9999: 716.177 ms/op
                 executeFilterQuery·p1.00:   716.177 ms/op

Iteration   5: 721.046 ±(99.9%) 14.580 ms/op
                 executeFilterQuery·p0.00:   704.643 ms/op
                 executeFilterQuery·p0.50:   725.615 ms/op
                 executeFilterQuery·p0.90:   736.100 ms/op
                 executeFilterQuery·p0.95:   736.100 ms/op
                 executeFilterQuery·p0.99:   736.100 ms/op
                 executeFilterQuery·p0.999:  736.100 ms/op
                 executeFilterQuery·p0.9999: 736.100 ms/op
                 executeFilterQuery·p1.00:   736.100 ms/op


# Run progress: 51.58% complete, ETA 11:13:54
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

743.665 ±(99.9%) 57.024 ms/op
# Warmup Iteration   2: 718.724 ±(99.9%) 15.146 ms/op
# Warmup Iteration   3: 733.404 ±(99.9%) 8.059 ms/op
# Warmup Iteration   4: 729.809 ±(99.9%) 7.232 ms/op
# Warmup Iteration   5: 731.157 ±(99.9%) 11.207 ms/op
Iteration   1: 730.333 ±(99.9%) 6.508 ms/op
                 executeFilterQuery·p0.00:   723.517 ms/op
                 executeFilterQuery·p0.50:   729.285 ms/op
                 executeFilterQuery·p0.90:   740.295 ms/op
                 executeFilterQuery·p0.95:   740.295 ms/op
                 executeFilterQuery·p0.99:   740.295 ms/op
                 executeFilterQuery·p0.999:  740.295 ms/op
                 executeFilterQuery·p0.9999: 740.295 ms/op
                 executeFilterQuery·p1.00:   740.295 ms/op

Iteration   2: 715.878 ±(99.9%) 16.208 ms/op
                 executeFilterQuery·p0.00:   699.400 ms/op
                 executeFilterQuery·p0.50:   709.886 ms/op
                 executeFilterQuery·p0.90:   736.100 ms/op
                 executeFilterQuery·p0.95:   739.246 ms/op
                 executeFilterQuery·p0.99:   739.246 ms/op
                 executeFilterQuery·p0.999:  739.246 ms/op
                 executeFilterQuery·p0.9999: 739.246 ms/op
                 executeFilterQuery·p1.00:   739.246 ms/op

Iteration   3: 705.412 ±(99.9%) 5.350 ms/op
                 executeFilterQuery·p0.00:   698.352 ms/op
                 executeFilterQuery·p0.50:   704.643 ms/op
                 executeFilterQuery·p0.90:   715.968 ms/op
                 executeFilterQuery·p0.95:   717.226 ms/op
                 executeFilterQuery·p0.99:   717.226 ms/op
                 executeFilterQuery·p0.999:  717.226 ms/op
                 executeFilterQuery·p0.9999: 717.226 ms/op
                 executeFilterQuery·p1.00:   717.226 ms/op

Iteration   4: 706.531 ±(99.9%) 6.688 ms/op
                 executeFilterQuery·p0.00:   694.157 ms/op
                 executeFilterQuery·p0.50:   705.692 ms/op
                 executeFilterQuery·p0.90:   714.919 ms/op
                 executeFilterQuery·p0.95:   719.323 ms/op
                 executeFilterQuery·p0.99:   719.323 ms/op
                 executeFilterQuery·p0.999:  719.323 ms/op
                 executeFilterQuery·p0.9999: 719.323 ms/op
                 executeFilterQuery·p1.00:   719.323 ms/op

Iteration   5: 703.804 ±(99.9%) 5.379 ms/op
                 executeFilterQuery·p0.00:   695.206 ms/op
                 executeFilterQuery·p0.50:   703.594 ms/op
                 executeFilterQuery·p0.90:   710.305 ms/op
                 executeFilterQuery·p0.95:   710.935 ms/op
                 executeFilterQuery·p0.99:   710.935 ms/op
                 executeFilterQuery·p0.999:  710.935 ms/op
                 executeFilterQuery·p0.9999: 710.935 ms/op
                 executeFilterQuery·p1.00:   710.935 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 146
  mean =    711.883 ±(99.9%) 3.440 ms/op

  Histogram, ms/op:
    [670.000, 675.000) = 1 
    [675.000, 680.000) = 0 
    [680.000, 685.000) = 0 
    [685.000, 690.000) = 0 
    [690.000, 695.000) = 1 
    [695.000, 700.000) = 14 
    [700.000, 705.000) = 38 
    [705.000, 710.000) = 31 
    [710.000, 715.000) = 15 
    [715.000, 720.000) = 12 
    [720.000, 725.000) = 3 
    [725.000, 730.000) = 14 
    [730.000, 735.000) = 9 
    [735.000, 740.000) = 4 
    [740.000, 745.000) = 4 

  Percentiles, ms/op:
      p(0.0000) =    671.089 ms/op
     p(50.0000) =    708.313 ms/op
     p(90.0000) =    731.172 ms/op
     p(95.0000) =    736.100 ms/op
     p(99.0000) =    743.010 ms/op
     p(99.9000) =    744.489 ms/op
     p(99.9900) =    744.489 ms/op
     p(99.9990) =    744.489 ms/op
     p(99.9999) =    744.489 ms/op
    p(100.0000) =    744.489 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/)

# Run progress: 51.90% complete, ETA 11:07:02
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

744.114 ±(99.9%) 62.487 ms/op
# Warmup Iteration   2: 722.169 ±(99.9%) 14.944 ms/op
# Warmup Iteration   3: 748.908 ±(99.9%) 19.930 ms/op
# Warmup Iteration   4: 739.920 ±(99.9%) 9.914 ms/op
# Warmup Iteration   5: 736.999 ±(99.9%) 6.785 ms/op
Iteration   1: 739.246 ±(99.9%) 9.520 ms/op
                 executeFilterQuery·p0.00:   728.760 ms/op
                 executeFilterQuery·p0.50:   740.295 ms/op
                 executeFilterQuery·p0.90:   752.878 ms/op
                 executeFilterQuery·p0.95:   762.315 ms/op
                 executeFilterQuery·p0.99:   762.315 ms/op
                 executeFilterQuery·p0.999:  762.315 ms/op
                 executeFilterQuery·p0.9999: 762.315 ms/op
                 executeFilterQuery·p1.00:   762.315 ms/op

Iteration   2: 742.317 ±(99.9%) 6.233 ms/op
                 executeFilterQuery·p0.00:   735.052 ms/op
                 executeFilterQuery·p0.50:   741.868 ms/op
                 executeFilterQuery·p0.90:   751.829 ms/op
                 executeFilterQuery·p0.95:   752.878 ms/op
                 executeFilterQuery·p0.99:   752.878 ms/op
                 executeFilterQuery·p0.999:  752.878 ms/op
                 executeFilterQuery·p0.9999: 752.878 ms/op
                 executeFilterQuery·p1.00:   752.878 ms/op

Iteration   3: 739.845 ±(99.9%) 11.780 ms/op
                 executeFilterQuery·p0.00:   713.032 ms/op
                 executeFilterQuery·p0.50:   741.868 ms/op
                 executeFilterQuery·p0.90:   752.878 ms/op
                 executeFilterQuery·p0.95:   752.878 ms/op
                 executeFilterQuery·p0.99:   752.878 ms/op
                 executeFilterQuery·p0.999:  752.878 ms/op
                 executeFilterQuery·p0.9999: 752.878 ms/op
                 executeFilterQuery·p1.00:   752.878 ms/op

Iteration   4: 716.327 ±(99.9%) 6.359 ms/op
                 executeFilterQuery·p0.00:   703.594 ms/op
                 executeFilterQuery·p0.50:   714.605 ms/op
                 executeFilterQuery·p0.90:   722.469 ms/op
                 executeFilterQuery·p0.95:   722.469 ms/op
                 executeFilterQuery·p0.99:   722.469 ms/op
                 executeFilterQuery·p0.999:  722.469 ms/op
                 executeFilterQuery·p0.9999: 722.469 ms/op
                 executeFilterQuery·p1.00:   722.469 ms/op

Iteration   5: 717.301 ±(99.9%) 7.209 ms/op
                 executeFilterQuery·p0.00:   705.692 ms/op
                 executeFilterQuery·p0.50:   716.177 ms/op
                 executeFilterQuery·p0.90:   727.187 ms/op
                 executeFilterQuery·p0.95:   727.712 ms/op
                 executeFilterQuery·p0.99:   727.712 ms/op
                 executeFilterQuery·p0.999:  727.712 ms/op
                 executeFilterQuery·p0.9999: 727.712 ms/op
                 executeFilterQuery·p1.00:   727.712 ms/op


# Run progress: 52.22% complete, ETA 11:00:14
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

738.422 ±(99.9%) 53.202 ms/op
# Warmup Iteration   2: 709.187 ±(99.9%) 15.571 ms/op
# Warmup Iteration   3: 748.908 ±(99.9%) 6.806 ms/op
# Warmup Iteration   4: 734.078 ±(99.9%) 10.954 ms/op
# Warmup Iteration   5: 745.987 ±(99.9%) 9.651 ms/op
Iteration   1: 744.114 ±(99.9%) 9.750 ms/op
                 executeFilterQuery·p0.00:   722.469 ms/op
                 executeFilterQuery·p0.50:   745.013 ms/op
                 executeFilterQuery·p0.90:   751.829 ms/op
                 executeFilterQuery·p0.95:   751.829 ms/op
                 executeFilterQuery·p0.99:   751.829 ms/op
                 executeFilterQuery·p0.999:  751.829 ms/op
                 executeFilterQuery·p0.9999: 751.829 ms/op
                 executeFilterQuery·p1.00:   751.829 ms/op

Iteration   2: 731.756 ±(99.9%) 8.578 ms/op
                 executeFilterQuery·p0.00:   723.517 ms/op
                 executeFilterQuery·p0.50:   730.857 ms/op
                 executeFilterQuery·p0.90:   747.110 ms/op
                 executeFilterQuery·p0.95:   752.878 ms/op
                 executeFilterQuery·p0.99:   752.878 ms/op
                 executeFilterQuery·p0.999:  752.878 ms/op
                 executeFilterQuery·p0.9999: 752.878 ms/op
                 executeFilterQuery·p1.00:   752.878 ms/op

Iteration   3: 746.287 ±(99.9%) 5.913 ms/op
                 executeFilterQuery·p0.00:   736.100 ms/op
                 executeFilterQuery·p0.50:   744.489 ms/op
                 executeFilterQuery·p0.90:   753.926 ms/op
                 executeFilterQuery·p0.95:   754.975 ms/op
                 executeFilterQuery·p0.99:   754.975 ms/op
                 executeFilterQuery·p0.999:  754.975 ms/op
                 executeFilterQuery·p0.9999: 754.975 ms/op
                 executeFilterQuery·p1.00:   754.975 ms/op

Iteration   4: 737.299 ±(99.9%) 18.171 ms/op
                 executeFilterQuery·p0.00:   709.886 ms/op
                 executeFilterQuery·p0.50:   742.392 ms/op
                 executeFilterQuery·p0.90:   753.402 ms/op
                 executeFilterQuery·p0.95:   753.926 ms/op
                 executeFilterQuery·p0.99:   753.926 ms/op
                 executeFilterQuery·p0.999:  753.926 ms/op
                 executeFilterQuery·p0.9999: 753.926 ms/op
                 executeFilterQuery·p1.00:   753.926 ms/op

Iteration   5: 709.606 ±(99.9%) 12.378 ms/op
                 executeFilterQuery·p0.00:   698.352 ms/op
                 executeFilterQuery·p0.50:   703.594 ms/op
                 executeFilterQuery·p0.90:   728.131 ms/op
                 executeFilterQuery·p0.95:   735.052 ms/op
                 executeFilterQuery·p0.99:   735.052 ms/op
                 executeFilterQuery·p0.999:  735.052 ms/op
                 executeFilterQuery·p0.9999: 735.052 ms/op
                 executeFilterQuery·p1.00:   735.052 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 141
  mean =    732.248 ±(99.9%) 4.371 ms/op

  Histogram, ms/op:
    [690.000, 695.000) = 0 
    [695.000, 700.000) = 3 
    [700.000, 705.000) = 6 
    [705.000, 710.000) = 2 
    [710.000, 715.000) = 16 
    [715.000, 720.000) = 4 
    [720.000, 725.000) = 17 
    [725.000, 730.000) = 11 
    [730.000, 735.000) = 9 
    [735.000, 740.000) = 11 
    [740.000, 745.000) = 34 
    [745.000, 750.000) = 9 
    [750.000, 755.000) = 18 
    [755.000, 760.000) = 0 
    [760.000, 765.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    698.352 ms/op
     p(50.0000) =    735.052 ms/op
     p(90.0000) =    751.619 ms/op
     p(95.0000) =    752.878 ms/op
     p(99.0000) =    759.232 ms/op
     p(99.9000) =    762.315 ms/op
     p(99.9900) =    762.315 ms/op
     p(99.9990) =    762.315 ms/op
     p(99.9999) =    762.315 ms/op
    p(100.0000) =    762.315 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/)

# Run progress: 52.53% complete, ETA 10:53:31
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

979.656 ±(99.9%) 103.196 ms/op
# Warmup Iteration   2: 1034.525 ±(99.9%) 6.979 ms/op
# Warmup Iteration   3: 1036.517 ±(99.9%) 5.555 ms/op
# Warmup Iteration   4: 1034.420 ±(99.9%) 2.147 ms/op
# Warmup Iteration   5: 1033.581 ±(99.9%) 3.887 ms/op
Iteration   1: 1034.840 ±(99.9%) 2.741 ms/op
                 executeFilterQuery·p0.00:   1031.799 ms/op
                 executeFilterQuery·p0.50:   1034.945 ms/op
                 executeFilterQuery·p0.90:   1037.042 ms/op
                 executeFilterQuery·p0.95:   1037.042 ms/op
                 executeFilterQuery·p0.99:   1037.042 ms/op
                 executeFilterQuery·p0.999:  1037.042 ms/op
                 executeFilterQuery·p0.9999: 1037.042 ms/op
                 executeFilterQuery·p1.00:   1037.042 ms/op

Iteration   2: 1033.477 ±(99.9%) 5.750 ms/op
                 executeFilterQuery·p0.00:   1029.702 ms/op
                 executeFilterQuery·p0.50:   1032.847 ms/op
                 executeFilterQuery·p0.90:   1042.494 ms/op
                 executeFilterQuery·p0.95:   1043.333 ms/op
                 executeFilterQuery·p0.99:   1043.333 ms/op
                 executeFilterQuery·p0.999:  1043.333 ms/op
                 executeFilterQuery·p0.9999: 1043.333 ms/op
                 executeFilterQuery·p1.00:   1043.333 ms/op

Iteration   3: 1036.098 ±(99.9%) 2.529 ms/op
                 executeFilterQuery·p0.00:   1033.896 ms/op
                 executeFilterQuery·p0.50:   1035.993 ms/op
                 executeFilterQuery·p0.90:   1038.090 ms/op
                 executeFilterQuery·p0.95:   1038.090 ms/op
                 executeFilterQuery·p0.99:   1038.090 ms/op
                 executeFilterQuery·p0.999:  1038.090 ms/op
                 executeFilterQuery·p0.9999: 1038.090 ms/op
                 executeFilterQuery·p1.00:   1038.090 ms/op

Iteration   4: 1036.413 ±(99.9%) 5.552 ms/op
                 executeFilterQuery·p0.00:   1031.799 ms/op
                 executeFilterQuery·p0.50:   1035.993 ms/op
                 executeFilterQuery·p0.90:   1043.962 ms/op
                 executeFilterQuery·p0.95:   1044.382 ms/op
                 executeFilterQuery·p0.99:   1044.382 ms/op
                 executeFilterQuery·p0.999:  1044.382 ms/op
                 executeFilterQuery·p0.9999: 1044.382 ms/op
                 executeFilterQuery·p1.00:   1044.382 ms/op

Iteration   5: 1035.679 ±(99.9%) 5.287 ms/op
                 executeFilterQuery·p0.00:   1031.799 ms/op
                 executeFilterQuery·p0.50:   1035.469 ms/op
                 executeFilterQuery·p0.90:   1042.809 ms/op
                 executeFilterQuery·p0.95:   1043.333 ms/op
                 executeFilterQuery·p0.99:   1043.333 ms/op
                 executeFilterQuery·p0.999:  1043.333 ms/op
                 executeFilterQuery·p0.9999: 1043.333 ms/op
                 executeFilterQuery·p1.00:   1043.333 ms/op


# Run progress: 52.85% complete, ETA 10:46:51
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

976.129 ±(99.9%) 102.716 ms/op
# Warmup Iteration   2: 1033.372 ±(99.9%) 9.751 ms/op
# Warmup Iteration   3: 1029.597 ±(99.9%) 4.512 ms/op
# Warmup Iteration   4: 1030.226 ±(99.9%) 9.636 ms/op
# Warmup Iteration   5: 1029.492 ±(99.9%) 3.646 ms/op
Iteration   1: 1028.234 ±(99.9%) 10.679 ms/op
                 executeFilterQuery·p0.00:   1010.827 ms/op
                 executeFilterQuery·p0.50:   1029.177 ms/op
                 executeFilterQuery·p0.90:   1034.840 ms/op
                 executeFilterQuery·p0.95:   1034.945 ms/op
                 executeFilterQuery·p0.99:   1034.945 ms/op
                 executeFilterQuery·p0.999:  1034.945 ms/op
                 executeFilterQuery·p0.9999: 1034.945 ms/op
                 executeFilterQuery·p1.00:   1034.945 ms/op

Iteration   2: 1030.960 ±(99.9%) 6.016 ms/op
                 executeFilterQuery·p0.00:   1020.264 ms/op
                 executeFilterQuery·p0.50:   1031.799 ms/op
                 executeFilterQuery·p0.90:   1033.896 ms/op
                 executeFilterQuery·p0.95:   1033.896 ms/op
                 executeFilterQuery·p0.99:   1033.896 ms/op
                 executeFilterQuery·p0.999:  1033.896 ms/op
                 executeFilterQuery·p0.9999: 1033.896 ms/op
                 executeFilterQuery·p1.00:   1033.896 ms/op

Iteration   3: 1033.267 ±(99.9%) 9.518 ms/op
                 executeFilterQuery·p0.00:   1028.653 ms/op
                 executeFilterQuery·p0.50:   1030.750 ms/op
                 executeFilterQuery·p0.90:   1047.423 ms/op
                 executeFilterQuery·p0.95:   1048.576 ms/op
                 executeFilterQuery·p0.99:   1048.576 ms/op
                 executeFilterQuery·p0.999:  1048.576 ms/op
                 executeFilterQuery·p0.9999: 1048.576 ms/op
                 executeFilterQuery·p1.00:   1048.576 ms/op

Iteration   4: 1031.799 ±(99.9%) 4.957 ms/op
                 executeFilterQuery·p0.00:   1028.653 ms/op
                 executeFilterQuery·p0.50:   1031.799 ms/op
                 executeFilterQuery·p0.90:   1037.776 ms/op
                 executeFilterQuery·p0.95:   1038.090 ms/op
                 executeFilterQuery·p0.99:   1038.090 ms/op
                 executeFilterQuery·p0.999:  1038.090 ms/op
                 executeFilterQuery·p0.9999: 1038.090 ms/op
                 executeFilterQuery·p1.00:   1038.090 ms/op

Iteration   5: 1031.694 ±(99.9%) 5.093 ms/op
                 executeFilterQuery·p0.00:   1024.459 ms/op
                 executeFilterQuery·p0.50:   1032.323 ms/op
                 executeFilterQuery·p0.90:   1034.945 ms/op
                 executeFilterQuery·p0.95:   1034.945 ms/op
                 executeFilterQuery·p0.99:   1034.945 ms/op
                 executeFilterQuery·p0.999:  1034.945 ms/op
                 executeFilterQuery·p0.9999: 1034.945 ms/op
                 executeFilterQuery·p1.00:   1034.945 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 100
  mean =   1033.246 ±(99.9%) 1.591 ms/op

  Histogram, ms/op:
    [1010.000, 1012.500) = 1 
    [1012.500, 1015.000) = 0 
    [1015.000, 1017.500) = 0 
    [1017.500, 1020.000) = 0 
    [1020.000, 1022.500) = 1 
    [1022.500, 1025.000) = 2 
    [1025.000, 1027.500) = 0 
    [1027.500, 1030.000) = 15 
    [1030.000, 1032.500) = 16 
    [1032.500, 1035.000) = 39 
    [1035.000, 1037.500) = 15 
    [1037.500, 1040.000) = 6 
    [1040.000, 1042.500) = 1 
    [1042.500, 1045.000) = 3 
    [1045.000, 1047.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   1010.827 ms/op
     p(50.0000) =   1033.896 ms/op
     p(90.0000) =   1038.090 ms/op
     p(95.0000) =   1040.083 ms/op
     p(99.0000) =   1048.534 ms/op
     p(99.9000) =   1048.576 ms/op
     p(99.9900) =   1048.576 ms/op
     p(99.9990) =   1048.576 ms/op
     p(99.9999) =   1048.576 ms/op
    p(100.0000) =   1048.576 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/)

# Run progress: 53.16% complete, ETA 10:40:15
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

1414.267 ±(99.9%) 157.424 ms/op
# Warmup Iteration   2: 1392.771 ±(99.9%) 55.908 ms/op
# Warmup Iteration   3: 1422.393 ±(99.9%) 26.748 ms/op
# Warmup Iteration   4: 1427.561 ±(99.9%) 17.822 ms/op
# Warmup Iteration   5: 1432.954 ±(99.9%) 16.967 ms/op
Iteration   1: 1370.227 ±(99.9%) 35.083 ms/op
                 executeFilterQuery·p0.00:   1346.372 ms/op
                 executeFilterQuery·p0.50:   1368.392 ms/op
                 executeFilterQuery·p0.90:   1409.286 ms/op
                 executeFilterQuery·p0.95:   1409.286 ms/op
                 executeFilterQuery·p0.99:   1409.286 ms/op
                 executeFilterQuery·p0.999:  1409.286 ms/op
                 executeFilterQuery·p0.9999: 1409.286 ms/op
                 executeFilterQuery·p1.00:   1409.286 ms/op

Iteration   2: 1351.877 ±(99.9%) 19.401 ms/op
                 executeFilterQuery·p0.00:   1342.177 ms/op
                 executeFilterQuery·p0.50:   1349.517 ms/op
                 executeFilterQuery·p0.90:   1369.440 ms/op
                 executeFilterQuery·p0.95:   1369.440 ms/op
                 executeFilterQuery·p0.99:   1369.440 ms/op
                 executeFilterQuery·p0.999:  1369.440 ms/op
                 executeFilterQuery·p0.9999: 1369.440 ms/op
                 executeFilterQuery·p1.00:   1369.440 ms/op

Iteration   3: 1352.139 ±(99.9%) 19.140 ms/op
                 executeFilterQuery·p0.00:   1337.983 ms/op
                 executeFilterQuery·p0.50:   1355.809 ms/op
                 executeFilterQuery·p0.90:   1363.149 ms/op
                 executeFilterQuery·p0.95:   1363.149 ms/op
                 executeFilterQuery·p0.99:   1363.149 ms/op
                 executeFilterQuery·p0.999:  1363.149 ms/op
                 executeFilterQuery·p0.9999: 1363.149 ms/op
                 executeFilterQuery·p1.00:   1363.149 ms/op

Iteration   4: 1367.343 ±(99.9%) 32.786 ms/op
                 executeFilterQuery·p0.00:   1344.274 ms/op
                 executeFilterQuery·p0.50:   1364.197 ms/op
                 executeFilterQuery·p0.90:   1392.509 ms/op
                 executeFilterQuery·p0.95:   1392.509 ms/op
                 executeFilterQuery·p0.99:   1392.509 ms/op
                 executeFilterQuery·p0.999:  1392.509 ms/op
                 executeFilterQuery·p0.9999: 1392.509 ms/op
                 executeFilterQuery·p1.00:   1392.509 ms/op

Iteration   5: 1410.073 ±(99.9%) 19.869 ms/op
                 executeFilterQuery·p0.00:   1398.800 ms/op
                 executeFilterQuery·p0.50:   1409.286 ms/op
                 executeFilterQuery·p0.90:   1423.966 ms/op
                 executeFilterQuery·p0.95:   1423.966 ms/op
                 executeFilterQuery·p0.99:   1423.966 ms/op
                 executeFilterQuery·p0.999:  1423.966 ms/op
                 executeFilterQuery·p0.9999: 1423.966 ms/op
                 executeFilterQuery·p1.00:   1423.966 ms/op


# Run progress: 53.48% complete, ETA 10:33:46
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

1432.055 ±(99.9%) 175.534 ms/op
# Warmup Iteration   2: 1367.343 ±(99.9%) 49.342 ms/op
# Warmup Iteration   3: 1418.723 ±(99.9%) 10.929 ms/op
# Warmup Iteration   4: 1373.372 ±(99.9%) 51.770 ms/op
# Warmup Iteration   5: 1359.741 ±(99.9%) 17.666 ms/op
Iteration   1: 1407.713 ±(99.9%) 50.753 ms/op
                 executeFilterQuery·p0.00:   1363.149 ms/op
                 executeFilterQuery·p0.50:   1416.626 ms/op
                 executeFilterQuery·p0.90:   1438.646 ms/op
                 executeFilterQuery·p0.95:   1438.646 ms/op
                 executeFilterQuery·p0.99:   1438.646 ms/op
                 executeFilterQuery·p0.999:  1438.646 ms/op
                 executeFilterQuery·p0.9999: 1438.646 ms/op
                 executeFilterQuery·p1.00:   1438.646 ms/op

Iteration   2: 1427.861 ±(99.9%) 28.000 ms/op
                 executeFilterQuery·p0.00:   1407.189 ms/op
                 executeFilterQuery·p0.50:   1434.452 ms/op
                 executeFilterQuery·p0.90:   1440.743 ms/op
                 executeFilterQuery·p0.95:   1440.743 ms/op
                 executeFilterQuery·p0.99:   1440.743 ms/op
                 executeFilterQuery·p0.999:  1440.743 ms/op
                 executeFilterQuery·p0.9999: 1440.743 ms/op
                 executeFilterQuery·p1.00:   1440.743 ms/op

Iteration   3: 1428.760 ±(99.9%) 21.937 ms/op
                 executeFilterQuery·p0.00:   1413.480 ms/op
                 executeFilterQuery·p0.50:   1428.161 ms/op
                 executeFilterQuery·p0.90:   1440.743 ms/op
                 executeFilterQuery·p0.95:   1440.743 ms/op
                 executeFilterQuery·p0.99:   1440.743 ms/op
                 executeFilterQuery·p0.999:  1440.743 ms/op
                 executeFilterQuery·p0.9999: 1440.743 ms/op
                 executeFilterQuery·p1.00:   1440.743 ms/op

Iteration   4: 1426.363 ±(99.9%) 26.358 ms/op
                 executeFilterQuery·p0.00:   1407.189 ms/op
                 executeFilterQuery·p0.50:   1430.258 ms/op
                 executeFilterQuery·p0.90:   1438.646 ms/op
                 executeFilterQuery·p0.95:   1438.646 ms/op
                 executeFilterQuery·p0.99:   1438.646 ms/op
                 executeFilterQuery·p0.999:  1438.646 ms/op
                 executeFilterQuery·p0.9999: 1438.646 ms/op
                 executeFilterQuery·p1.00:   1438.646 ms/op

Iteration   5: 1411.121 ±(99.9%) 15.221 ms/op
                 executeFilterQuery·p0.00:   1398.800 ms/op
                 executeFilterQuery·p0.50:   1409.286 ms/op
                 executeFilterQuery·p0.90:   1421.869 ms/op
                 executeFilterQuery·p0.95:   1421.869 ms/op
                 executeFilterQuery·p0.99:   1421.869 ms/op
                 executeFilterQuery·p0.999:  1421.869 ms/op
                 executeFilterQuery·p0.9999: 1421.869 ms/op
                 executeFilterQuery·p1.00:   1421.869 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 77
  mean =   1394.089 ±(99.9%) 12.848 ms/op

  Histogram, ms/op:
    [1300.000, 1312.500) = 0 
    [1312.500, 1325.000) = 0 
    [1325.000, 1337.500) = 0 
    [1337.500, 1350.000) = 9 
    [1350.000, 1362.500) = 8 
    [1362.500, 1375.000) = 12 
    [1375.000, 1387.500) = 2 
    [1387.500, 1400.000) = 6 
    [1400.000, 1412.500) = 9 
    [1412.500, 1425.000) = 17 
    [1425.000, 1437.500) = 10 
    [1437.500, 1450.000) = 4 
    [1450.000, 1462.500) = 0 
    [1462.500, 1475.000) = 0 
    [1475.000, 1487.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   1337.983 ms/op
     p(50.0000) =   1405.092 ms/op
     p(90.0000) =   1436.549 ms/op
     p(95.0000) =   1438.646 ms/op
     p(99.0000) =   1440.743 ms/op
     p(99.9000) =   1440.743 ms/op
     p(99.9900) =   1440.743 ms/op
     p(99.9990) =   1440.743 ms/op
     p(99.9999) =   1440.743 ms/op
    p(100.0000) =   1440.743 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/)

# Run progress: 53.80% complete, ETA 10:27:18
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

1487.780 ±(99.9%) 324.737 ms/op
# Warmup Iteration   2: 1428.161 ±(99.9%) 63.544 ms/op
# Warmup Iteration   3: 1477.593 ±(99.9%) 25.993 ms/op
# Warmup Iteration   4: 1454.225 ±(99.9%) 21.273 ms/op
# Warmup Iteration   5: 1469.504 ±(99.9%) 17.400 ms/op
Iteration   1: 1432.654 ±(99.9%) 74.103 ms/op
                 executeFilterQuery·p0.00:   1405.092 ms/op
                 executeFilterQuery·p0.50:   1411.383 ms/op
                 executeFilterQuery·p0.90:   1476.395 ms/op
                 executeFilterQuery·p0.95:   1476.395 ms/op
                 executeFilterQuery·p0.99:   1476.395 ms/op
                 executeFilterQuery·p0.999:  1476.395 ms/op
                 executeFilterQuery·p0.9999: 1476.395 ms/op
                 executeFilterQuery·p1.00:   1476.395 ms/op

Iteration   2: 1393.558 ±(99.9%) 26.597 ms/op
                 executeFilterQuery·p0.00:   1377.829 ms/op
                 executeFilterQuery·p0.50:   1392.509 ms/op
                 executeFilterQuery·p0.90:   1421.869 ms/op
                 executeFilterQuery·p0.95:   1421.869 ms/op
                 executeFilterQuery·p0.99:   1421.869 ms/op
                 executeFilterQuery·p0.999:  1421.869 ms/op
                 executeFilterQuery·p0.9999: 1421.869 ms/op
                 executeFilterQuery·p1.00:   1421.869 ms/op

Iteration   3: 1400.111 ±(99.9%) 29.147 ms/op
                 executeFilterQuery·p0.00:   1377.829 ms/op
                 executeFilterQuery·p0.50:   1402.995 ms/op
                 executeFilterQuery·p0.90:   1419.772 ms/op
                 executeFilterQuery·p0.95:   1419.772 ms/op
                 executeFilterQuery·p0.99:   1419.772 ms/op
                 executeFilterQuery·p0.999:  1419.772 ms/op
                 executeFilterQuery·p0.9999: 1419.772 ms/op
                 executeFilterQuery·p1.00:   1419.772 ms/op

Iteration   4: 1397.752 ±(99.9%) 23.770 ms/op
                 executeFilterQuery·p0.00:   1377.829 ms/op
                 executeFilterQuery·p0.50:   1396.703 ms/op
                 executeFilterQuery·p0.90:   1415.578 ms/op
                 executeFilterQuery·p0.95:   1415.578 ms/op
                 executeFilterQuery·p0.99:   1415.578 ms/op
                 executeFilterQuery·p0.999:  1415.578 ms/op
                 executeFilterQuery·p0.9999: 1415.578 ms/op
                 executeFilterQuery·p1.00:   1415.578 ms/op

Iteration   5: 1436.250 ±(99.9%) 44.428 ms/op
                 executeFilterQuery·p0.00:   1396.703 ms/op
                 executeFilterQuery·p0.50:   1444.938 ms/op
                 executeFilterQuery·p0.90:   1453.326 ms/op
                 executeFilterQuery·p0.95:   1453.326 ms/op
                 executeFilterQuery·p0.99:   1453.326 ms/op
                 executeFilterQuery·p0.999:  1453.326 ms/op
                 executeFilterQuery·p0.9999: 1453.326 ms/op
                 executeFilterQuery·p1.00:   1453.326 ms/op


# Run progress: 54.11% complete, ETA 10:20:54
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

1472.500 ±(99.9%) 223.868 ms/op
# Warmup Iteration   2: 1417.937 ±(99.9%) 52.693 ms/op
# Warmup Iteration   3: 1466.508 ±(99.9%) 42.133 ms/op
# Warmup Iteration   4: 1453.926 ±(99.9%) 12.997 ms/op
# Warmup Iteration   5: 1452.727 ±(99.9%) 19.420 ms/op
Iteration   1: 1452.428 ±(99.9%) 15.392 ms/op
                 executeFilterQuery·p0.00:   1444.938 ms/op
                 executeFilterQuery·p0.50:   1451.229 ms/op
                 executeFilterQuery·p0.90:   1465.909 ms/op
                 executeFilterQuery·p0.95:   1465.909 ms/op
                 executeFilterQuery·p0.99:   1465.909 ms/op
                 executeFilterQuery·p0.999:  1465.909 ms/op
                 executeFilterQuery·p0.9999: 1465.909 ms/op
                 executeFilterQuery·p1.00:   1465.909 ms/op

Iteration   2: 1453.027 ±(99.9%) 24.456 ms/op
                 executeFilterQuery·p0.00:   1440.743 ms/op
                 executeFilterQuery·p0.50:   1451.229 ms/op
                 executeFilterQuery·p0.90:   1474.298 ms/op
                 executeFilterQuery·p0.95:   1474.298 ms/op
                 executeFilterQuery·p0.99:   1474.298 ms/op
                 executeFilterQuery·p0.999:  1474.298 ms/op
                 executeFilterQuery·p0.9999: 1474.298 ms/op
                 executeFilterQuery·p1.00:   1474.298 ms/op

Iteration   3: 1453.027 ±(99.9%) 10.711 ms/op
                 executeFilterQuery·p0.00:   1447.035 ms/op
                 executeFilterQuery·p0.50:   1453.326 ms/op
                 executeFilterQuery·p0.90:   1457.521 ms/op
                 executeFilterQuery·p0.95:   1457.521 ms/op
                 executeFilterQuery·p0.99:   1457.521 ms/op
                 executeFilterQuery·p0.999:  1457.521 ms/op
                 executeFilterQuery·p0.9999: 1457.521 ms/op
                 executeFilterQuery·p1.00:   1457.521 ms/op

Iteration   4: 1446.735 ±(99.9%) 62.389 ms/op
                 executeFilterQuery·p0.00:   1394.606 ms/op
                 executeFilterQuery·p0.50:   1459.618 ms/op
                 executeFilterQuery·p0.90:   1472.201 ms/op
                 executeFilterQuery·p0.95:   1472.201 ms/op
                 executeFilterQuery·p0.99:   1472.201 ms/op
                 executeFilterQuery·p0.999:  1472.201 ms/op
                 executeFilterQuery·p0.9999: 1472.201 ms/op
                 executeFilterQuery·p1.00:   1472.201 ms/op

Iteration   5: 1396.703 ±(99.9%) 21.752 ms/op
                 executeFilterQuery·p0.00:   1379.926 ms/op
                 executeFilterQuery·p0.50:   1394.606 ms/op
                 executeFilterQuery·p0.90:   1411.383 ms/op
                 executeFilterQuery·p0.95:   1411.383 ms/op
                 executeFilterQuery·p0.99:   1411.383 ms/op
                 executeFilterQuery·p0.999:  1411.383 ms/op
                 executeFilterQuery·p0.9999: 1411.383 ms/op
                 executeFilterQuery·p1.00:   1411.383 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 74
  mean =   1424.646 ±(99.9%) 11.948 ms/op

  Histogram, ms/op:
    [1370.000, 1380.000) = 5 
    [1380.000, 1390.000) = 4 
    [1390.000, 1400.000) = 13 
    [1400.000, 1410.000) = 9 
    [1410.000, 1420.000) = 6 
    [1420.000, 1430.000) = 3 
    [1430.000, 1440.000) = 0 
    [1440.000, 1450.000) = 12 
    [1450.000, 1460.000) = 16 
    [1460.000, 1470.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =   1377.829 ms/op
     p(50.0000) =   1420.820 ms/op
     p(90.0000) =   1459.618 ms/op
     p(95.0000) =   1472.725 ms/op
     p(99.0000) =   1476.395 ms/op
     p(99.9000) =   1476.395 ms/op
     p(99.9900) =   1476.395 ms/op
     p(99.9990) =   1476.395 ms/op
     p(99.9999) =   1476.395 ms/op
    p(100.0000) =   1476.395 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/)

# Run progress: 54.43% complete, ETA 10:14:31
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

1933.574 ±(99.9%) 317.171 ms/op
# Warmup Iteration   2: 2007.394 ±(99.9%) 25.791 ms/op
# Warmup Iteration   3: 2003.619 ±(99.9%) 9.207 ms/op
# Warmup Iteration   4: 1995.650 ±(99.9%) 16.745 ms/op
# Warmup Iteration   5: 1994.392 ±(99.9%) 38.831 ms/op
Iteration   1: 1989.498 ±(99.9%) 35.415 ms/op
                 executeFilterQuery·p0.00:   1975.517 ms/op
                 executeFilterQuery·p0.50:   1992.294 ms/op
                 executeFilterQuery·p0.90:   2000.683 ms/op
                 executeFilterQuery·p0.95:   2000.683 ms/op
                 executeFilterQuery·p0.99:   2000.683 ms/op
                 executeFilterQuery·p0.999:  2000.683 ms/op
                 executeFilterQuery·p0.9999: 2000.683 ms/op
                 executeFilterQuery·p1.00:   2000.683 ms/op

Iteration   2: 2004.038 ±(99.9%) 28.321 ms/op
                 executeFilterQuery·p0.00:   1996.489 ms/op
                 executeFilterQuery·p0.50:   2006.974 ms/op
                 executeFilterQuery·p0.90:   2013.266 ms/op
                 executeFilterQuery·p0.95:   2013.266 ms/op
                 executeFilterQuery·p0.99:   2013.266 ms/op
                 executeFilterQuery·p0.999:  2013.266 ms/op
                 executeFilterQuery·p0.9999: 2013.266 ms/op
                 executeFilterQuery·p1.00:   2013.266 ms/op

Iteration   3: 2002.780 ±(99.9%) 28.551 ms/op
                 executeFilterQuery·p0.00:   1992.294 ms/op
                 executeFilterQuery·p0.50:   2004.877 ms/op
                 executeFilterQuery·p0.90:   2011.169 ms/op
                 executeFilterQuery·p0.95:   2011.169 ms/op
                 executeFilterQuery·p0.99:   2011.169 ms/op
                 executeFilterQuery·p0.999:  2011.169 ms/op
                 executeFilterQuery·p0.9999: 2011.169 ms/op
                 executeFilterQuery·p1.00:   2011.169 ms/op

Iteration   4: 2003.619 ±(99.9%) 17.692 ms/op
                 executeFilterQuery·p0.00:   1996.489 ms/op
                 executeFilterQuery·p0.50:   2004.877 ms/op
                 executeFilterQuery·p0.90:   2009.072 ms/op
                 executeFilterQuery·p0.95:   2009.072 ms/op
                 executeFilterQuery·p0.99:   2009.072 ms/op
                 executeFilterQuery·p0.999:  2009.072 ms/op
                 executeFilterQuery·p0.9999: 2009.072 ms/op
                 executeFilterQuery·p1.00:   2009.072 ms/op

Iteration   5: 2004.038 ±(99.9%) 9.207 ms/op
                 executeFilterQuery·p0.00:   2000.683 ms/op
                 executeFilterQuery·p0.50:   2004.877 ms/op
                 executeFilterQuery·p0.90:   2006.974 ms/op
                 executeFilterQuery·p0.95:   2006.974 ms/op
                 executeFilterQuery·p0.99:   2006.974 ms/op
                 executeFilterQuery·p0.999:  2006.974 ms/op
                 executeFilterQuery·p0.9999: 2006.974 ms/op
                 executeFilterQuery·p1.00:   2006.974 ms/op


# Run progress: 54.75% complete, ETA 10:08:12
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int[] ordinal_0_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_1_sel_vec = cCtx.getAllocationManager().getIntVector();
int[] ordinal_2_sel_vec = cCtx.getAllocationManager().getIntVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_0, 3000, ordinal_0_sel_vec);
    int ordinal_1_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_1, 3000, ordinal_1_sel_vec, ordinal_0_sel_vec, ordinal_0_sel_vec_length);
    int ordinal_2_sel_vec_length = VectorisedFilterOperators.lt(filter_query_table_vc_2, 3000, ordinal_2_sel_vec, ordinal_1_sel_vec, ordinal_1_sel_vec_length);
    count += ordinal_2_sel_vec_length;
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_sel_vec);
cCtx.getAllocationManager().release(ordinal_1_sel_vec);
cCtx.getAllocationManager().release(ordinal_2_sel_vec);

1899.321 ±(99.9%) 383.989 ms/op
# Warmup Iteration   2: 2012.846 ±(99.9%) 18.415 ms/op
# Warmup Iteration   3: 2009.072 ±(99.9%) 12.768 ms/op
# Warmup Iteration   4: 2015.363 ±(99.9%) 25.537 ms/op
# Warmup Iteration   5: 2011.169 ±(99.9%) 31.793 ms/op
Iteration   1: 2013.266 ±(99.9%) 15.108 ms/op
                 executeFilterQuery·p0.00:   2006.974 ms/op
                 executeFilterQuery·p0.50:   2013.266 ms/op
                 executeFilterQuery·p0.90:   2017.460 ms/op
                 executeFilterQuery·p0.95:   2017.460 ms/op
                 executeFilterQuery·p0.99:   2017.460 ms/op
                 executeFilterQuery·p0.999:  2017.460 ms/op
                 executeFilterQuery·p0.9999: 2017.460 ms/op
                 executeFilterQuery·p1.00:   2017.460 ms/op

Iteration   2: 2015.363 ±(99.9%) 20.588 ms/op
                 executeFilterQuery·p0.00:   2009.072 ms/op
                 executeFilterQuery·p0.50:   2015.363 ms/op
                 executeFilterQuery·p0.90:   2023.752 ms/op
                 executeFilterQuery·p0.95:   2023.752 ms/op
                 executeFilterQuery·p0.99:   2023.752 ms/op
                 executeFilterQuery·p0.999:  2023.752 ms/op
                 executeFilterQuery·p0.9999: 2023.752 ms/op
                 executeFilterQuery·p1.00:   2023.752 ms/op

Iteration   3: 2011.588 ±(99.9%) 30.430 ms/op
                 executeFilterQuery·p0.00:   2002.780 ms/op
                 executeFilterQuery·p0.50:   2011.169 ms/op
                 executeFilterQuery·p0.90:   2023.752 ms/op
                 executeFilterQuery·p0.95:   2023.752 ms/op
                 executeFilterQuery·p0.99:   2023.752 ms/op
                 executeFilterQuery·p0.999:  2023.752 ms/op
                 executeFilterQuery·p0.9999: 2023.752 ms/op
                 executeFilterQuery·p1.00:   2023.752 ms/op

Iteration   4: 2010.330 ±(99.9%) 33.588 ms/op
                 executeFilterQuery·p0.00:   2002.780 ms/op
                 executeFilterQuery·p0.50:   2009.072 ms/op
                 executeFilterQuery·p0.90:   2023.752 ms/op
                 executeFilterQuery·p0.95:   2023.752 ms/op
                 executeFilterQuery·p0.99:   2023.752 ms/op
                 executeFilterQuery·p0.999:  2023.752 ms/op
                 executeFilterQuery·p0.9999: 2023.752 ms/op
                 executeFilterQuery·p1.00:   2023.752 ms/op

Iteration   5: 2010.330 ±(99.9%) 7.223 ms/op
                 executeFilterQuery·p0.00:   2009.072 ms/op
                 executeFilterQuery·p0.50:   2009.072 ms/op
                 executeFilterQuery·p0.90:   2013.266 ms/op
                 executeFilterQuery·p0.95:   2013.266 ms/op
                 executeFilterQuery·p0.99:   2013.266 ms/op
                 executeFilterQuery·p0.999:  2013.266 ms/op
                 executeFilterQuery·p0.9999: 2013.266 ms/op
                 executeFilterQuery·p1.00:   2013.266 ms/op



Result "benchmarks.filter_query.VectorisedNonSimd.executeFilterQuery":
  N = 51
  mean =   2006.152 ±(99.9%) 4.838 ms/op

  Histogram, ms/op:
    [1970.000, 1975.000) = 0 
    [1975.000, 1980.000) = 2 
    [1980.000, 1985.000) = 1 
    [1985.000, 1990.000) = 0 
    [1990.000, 1995.000) = 1 
    [1995.000, 2000.000) = 4 
    [2000.000, 2005.000) = 14 
    [2005.000, 2010.000) = 12 
    [2010.000, 2015.000) = 10 
    [2015.000, 2020.000) = 4 
    [2020.000, 2025.000) = 3 

  Percentiles, ms/op:
      p(0.0000) =   1975.517 ms/op
     p(50.0000) =   2006.974 ms/op
     p(90.0000) =   2015.363 ms/op
     p(95.0000) =   2023.752 ms/op
     p(99.0000) =   2023.752 ms/op
     p(99.9000) =   2023.752 ms/op
     p(99.9900) =   2023.752 ms/op
     p(99.9990) =   2023.752 ms/op
     p(99.9999) =   2023.752 ms/op
    p(100.0000) =   2023.752 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/)

# Run progress: 55.06% complete, ETA 10:01:54
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

502.818 ±(99.9%) 242.441 ms/op
# Warmup Iteration   2: 325.498 ±(99.9%) 3.381 ms/op
# Warmup Iteration   3: 324.365 ±(99.9%) 2.517 ms/op
# Warmup Iteration   4: 322.420 ±(99.9%) 1.109 ms/op
# Warmup Iteration   5: 322.133 ±(99.9%) 1.752 ms/op
Iteration   1: 321.831 ±(99.9%) 1.132 ms/op
                 executeFilterQuery·p0.00:   319.816 ms/op
                 executeFilterQuery·p0.50:   321.126 ms/op
                 executeFilterQuery·p0.90:   324.744 ms/op
                 executeFilterQuery·p0.95:   325.766 ms/op
                 executeFilterQuery·p0.99:   326.107 ms/op
                 executeFilterQuery·p0.999:  326.107 ms/op
                 executeFilterQuery·p0.9999: 326.107 ms/op
                 executeFilterQuery·p1.00:   326.107 ms/op

Iteration   2: 322.826 ±(99.9%) 1.893 ms/op
                 executeFilterQuery·p0.00:   319.291 ms/op
                 executeFilterQuery·p0.50:   321.913 ms/op
                 executeFilterQuery·p0.90:   326.107 ms/op
                 executeFilterQuery·p0.95:   329.672 ms/op
                 executeFilterQuery·p0.99:   335.020 ms/op
                 executeFilterQuery·p0.999:  335.020 ms/op
                 executeFilterQuery·p0.9999: 335.020 ms/op
                 executeFilterQuery·p1.00:   335.020 ms/op

Iteration   3: 322.183 ±(99.9%) 1.124 ms/op
                 executeFilterQuery·p0.00:   319.816 ms/op
                 executeFilterQuery·p0.50:   321.913 ms/op
                 executeFilterQuery·p0.90:   325.478 ms/op
                 executeFilterQuery·p0.95:   326.002 ms/op
                 executeFilterQuery·p0.99:   326.631 ms/op
                 executeFilterQuery·p0.999:  326.631 ms/op
                 executeFilterQuery·p0.9999: 326.631 ms/op
                 executeFilterQuery·p1.00:   326.631 ms/op

Iteration   4: 322.183 ±(99.9%) 1.454 ms/op
                 executeFilterQuery·p0.00:   315.097 ms/op
                 executeFilterQuery·p0.50:   321.913 ms/op
                 executeFilterQuery·p0.90:   325.478 ms/op
                 executeFilterQuery·p0.95:   326.107 ms/op
                 executeFilterQuery·p0.99:   326.107 ms/op
                 executeFilterQuery·p0.999:  326.107 ms/op
                 executeFilterQuery·p0.9999: 326.107 ms/op
                 executeFilterQuery·p1.00:   326.107 ms/op

Iteration   5: 320.979 ±(99.9%) 0.936 ms/op
                 executeFilterQuery·p0.00:   319.291 ms/op
                 executeFilterQuery·p0.50:   320.602 ms/op
                 executeFilterQuery·p0.90:   323.328 ms/op
                 executeFilterQuery·p0.95:   324.377 ms/op
                 executeFilterQuery·p0.99:   325.059 ms/op
                 executeFilterQuery·p0.999:  325.059 ms/op
                 executeFilterQuery·p0.9999: 325.059 ms/op
                 executeFilterQuery·p1.00:   325.059 ms/op


# Run progress: 55.38% complete, ETA 09:55:38
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

509.057 ±(99.9%) 244.834 ms/op
# Warmup Iteration   2: 324.145 ±(99.9%) 3.449 ms/op
# Warmup Iteration   3: 323.114 ±(99.9%) 2.463 ms/op
# Warmup Iteration   4: 321.602 ±(99.9%) 1.064 ms/op
# Warmup Iteration   5: 321.274 ±(99.9%) 1.111 ms/op
Iteration   1: 320.913 ±(99.9%) 1.482 ms/op
                 executeFilterQuery·p0.00:   315.621 ms/op
                 executeFilterQuery·p0.50:   320.340 ms/op
                 executeFilterQuery·p0.90:   324.534 ms/op
                 executeFilterQuery·p0.95:   325.426 ms/op
                 executeFilterQuery·p0.99:   326.107 ms/op
                 executeFilterQuery·p0.999:  326.107 ms/op
                 executeFilterQuery·p0.9999: 326.107 ms/op
                 executeFilterQuery·p1.00:   326.107 ms/op

Iteration   2: 321.765 ±(99.9%) 1.429 ms/op
                 executeFilterQuery·p0.00:   317.719 ms/op
                 executeFilterQuery·p0.50:   321.126 ms/op
                 executeFilterQuery·p0.90:   325.059 ms/op
                 executeFilterQuery·p0.95:   326.815 ms/op
                 executeFilterQuery·p0.99:   327.156 ms/op
                 executeFilterQuery·p0.999:  327.156 ms/op
                 executeFilterQuery·p0.9999: 327.156 ms/op
                 executeFilterQuery·p1.00:   327.156 ms/op

Iteration   3: 321.257 ±(99.9%) 1.167 ms/op
                 executeFilterQuery·p0.00:   318.767 ms/op
                 executeFilterQuery·p0.50:   320.864 ms/op
                 executeFilterQuery·p0.90:   323.853 ms/op
                 executeFilterQuery·p0.95:   325.268 ms/op
                 executeFilterQuery·p0.99:   326.631 ms/op
                 executeFilterQuery·p0.999:  326.631 ms/op
                 executeFilterQuery·p0.9999: 326.631 ms/op
                 executeFilterQuery·p1.00:   326.631 ms/op

Iteration   4: 322.031 ±(99.9%) 2.201 ms/op
                 executeFilterQuery·p0.00:   319.291 ms/op
                 executeFilterQuery·p0.50:   320.864 ms/op
                 executeFilterQuery·p0.90:   326.107 ms/op
                 executeFilterQuery·p0.95:   330.511 ms/op
                 executeFilterQuery·p0.99:   335.544 ms/op
                 executeFilterQuery·p0.999:  335.544 ms/op
                 executeFilterQuery·p0.9999: 335.544 ms/op
                 executeFilterQuery·p1.00:   335.544 ms/op

Iteration   5: 320.946 ±(99.9%) 1.161 ms/op
                 executeFilterQuery·p0.00:   318.243 ms/op
                 executeFilterQuery·p0.50:   320.340 ms/op
                 executeFilterQuery·p0.90:   323.853 ms/op
                 executeFilterQuery·p0.95:   325.766 ms/op
                 executeFilterQuery·p0.99:   326.107 ms/op
                 executeFilterQuery·p0.999:  326.107 ms/op
                 executeFilterQuery·p0.9999: 326.107 ms/op
                 executeFilterQuery·p1.00:   326.107 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 316
  mean =    321.684 ±(99.9%) 0.425 ms/op

  Histogram, ms/op:
    [310.000, 312.500) = 0 
    [312.500, 315.000) = 0 
    [315.000, 317.500) = 2 
    [317.500, 320.000) = 61 
    [320.000, 322.500) = 173 
    [322.500, 325.000) = 47 
    [325.000, 327.500) = 31 
    [327.500, 330.000) = 0 
    [330.000, 332.500) = 0 
    [332.500, 335.000) = 0 
    [335.000, 337.500) = 2 

  Percentiles, ms/op:
      p(0.0000) =    315.097 ms/op
     p(50.0000) =    320.864 ms/op
     p(90.0000) =    325.059 ms/op
     p(95.0000) =    326.107 ms/op
     p(99.0000) =    327.156 ms/op
     p(99.9000) =    335.544 ms/op
     p(99.9900) =    335.544 ms/op
     p(99.9990) =    335.544 ms/op
     p(99.9999) =    335.544 ms/op
    p(100.0000) =    335.544 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/)

# Run progress: 55.70% complete, ETA 09:49:26
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

501.114 ±(99.9%) 241.984 ms/op
# Warmup Iteration   2: 327.934 ±(99.9%) 3.596 ms/op
# Warmup Iteration   3: 324.111 ±(99.9%) 2.276 ms/op
# Warmup Iteration   4: 323.418 ±(99.9%) 1.506 ms/op
# Warmup Iteration   5: 324.044 ±(99.9%) 1.135 ms/op
Iteration   1: 324.500 ±(99.9%) 1.691 ms/op
                 executeFilterQuery·p0.00:   318.243 ms/op
                 executeFilterQuery·p0.50:   324.534 ms/op
                 executeFilterQuery·p0.90:   327.680 ms/op
                 executeFilterQuery·p0.95:   328.099 ms/op
                 executeFilterQuery·p0.99:   328.729 ms/op
                 executeFilterQuery·p0.999:  328.729 ms/op
                 executeFilterQuery·p0.9999: 328.729 ms/op
                 executeFilterQuery·p1.00:   328.729 ms/op

Iteration   2: 323.452 ±(99.9%) 1.721 ms/op
                 executeFilterQuery·p0.00:   318.243 ms/op
                 executeFilterQuery·p0.50:   324.010 ms/op
                 executeFilterQuery·p0.90:   326.946 ms/op
                 executeFilterQuery·p0.95:   327.890 ms/op
                 executeFilterQuery·p0.99:   328.204 ms/op
                 executeFilterQuery·p0.999:  328.204 ms/op
                 executeFilterQuery·p0.9999: 328.204 ms/op
                 executeFilterQuery·p1.00:   328.204 ms/op

Iteration   3: 323.503 ±(99.9%) 1.669 ms/op
                 executeFilterQuery·p0.00:   317.719 ms/op
                 executeFilterQuery·p0.50:   323.486 ms/op
                 executeFilterQuery·p0.90:   326.631 ms/op
                 executeFilterQuery·p0.95:   327.365 ms/op
                 executeFilterQuery·p0.99:   327.680 ms/op
                 executeFilterQuery·p0.999:  327.680 ms/op
                 executeFilterQuery·p0.9999: 327.680 ms/op
                 executeFilterQuery·p1.00:   327.680 ms/op

Iteration   4: 322.928 ±(99.9%) 1.832 ms/op
                 executeFilterQuery·p0.00:   315.621 ms/op
                 executeFilterQuery·p0.50:   323.486 ms/op
                 executeFilterQuery·p0.90:   327.051 ms/op
                 executeFilterQuery·p0.95:   327.156 ms/op
                 executeFilterQuery·p0.99:   327.156 ms/op
                 executeFilterQuery·p0.999:  327.156 ms/op
                 executeFilterQuery·p0.9999: 327.156 ms/op
                 executeFilterQuery·p1.00:   327.156 ms/op

Iteration   5: 322.877 ±(99.9%) 1.196 ms/op
                 executeFilterQuery·p0.00:   317.194 ms/op
                 executeFilterQuery·p0.50:   322.961 ms/op
                 executeFilterQuery·p0.90:   325.583 ms/op
                 executeFilterQuery·p0.95:   326.107 ms/op
                 executeFilterQuery·p0.99:   326.107 ms/op
                 executeFilterQuery·p0.999:  326.107 ms/op
                 executeFilterQuery·p0.9999: 326.107 ms/op
                 executeFilterQuery·p1.00:   326.107 ms/op


# Run progress: 56.01% complete, ETA 09:43:15
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

500.407 ±(99.9%) 240.067 ms/op
# Warmup Iteration   2: 325.650 ±(99.9%) 3.501 ms/op
# Warmup Iteration   3: 320.455 ±(99.9%) 2.723 ms/op
# Warmup Iteration   4: 322.403 ±(99.9%) 1.429 ms/op
# Warmup Iteration   5: 320.651 ±(99.9%) 2.297 ms/op
Iteration   1: 316.260 ±(99.9%) 1.153 ms/op
                 executeFilterQuery·p0.00:   313.000 ms/op
                 executeFilterQuery·p0.50:   316.146 ms/op
                 executeFilterQuery·p0.90:   318.767 ms/op
                 executeFilterQuery·p0.95:   320.340 ms/op
                 executeFilterQuery·p0.99:   320.340 ms/op
                 executeFilterQuery·p0.999:  320.340 ms/op
                 executeFilterQuery·p0.9999: 320.340 ms/op
                 executeFilterQuery·p1.00:   320.340 ms/op

Iteration   2: 322.200 ±(99.9%) 1.172 ms/op
                 executeFilterQuery·p0.00:   319.291 ms/op
                 executeFilterQuery·p0.50:   321.389 ms/op
                 executeFilterQuery·p0.90:   324.954 ms/op
                 executeFilterQuery·p0.95:   326.317 ms/op
                 executeFilterQuery·p0.99:   326.631 ms/op
                 executeFilterQuery·p0.999:  326.631 ms/op
                 executeFilterQuery·p0.9999: 326.631 ms/op
                 executeFilterQuery·p1.00:   326.631 ms/op

Iteration   3: 321.947 ±(99.9%) 1.003 ms/op
                 executeFilterQuery·p0.00:   319.816 ms/op
                 executeFilterQuery·p0.50:   321.389 ms/op
                 executeFilterQuery·p0.90:   324.534 ms/op
                 executeFilterQuery·p0.95:   325.373 ms/op
                 executeFilterQuery·p0.99:   326.631 ms/op
                 executeFilterQuery·p0.999:  326.631 ms/op
                 executeFilterQuery·p0.9999: 326.631 ms/op
                 executeFilterQuery·p1.00:   326.631 ms/op

Iteration   4: 321.487 ±(99.9%) 0.999 ms/op
                 executeFilterQuery·p0.00:   319.816 ms/op
                 executeFilterQuery·p0.50:   320.864 ms/op
                 executeFilterQuery·p0.90:   324.010 ms/op
                 executeFilterQuery·p0.95:   325.242 ms/op
                 executeFilterQuery·p0.99:   325.583 ms/op
                 executeFilterQuery·p0.999:  325.583 ms/op
                 executeFilterQuery·p0.9999: 325.583 ms/op
                 executeFilterQuery·p1.00:   325.583 ms/op

Iteration   5: 321.602 ±(99.9%) 1.138 ms/op
                 executeFilterQuery·p0.00:   318.767 ms/op
                 executeFilterQuery·p0.50:   321.389 ms/op
                 executeFilterQuery·p0.90:   324.534 ms/op
                 executeFilterQuery·p0.95:   325.268 ms/op
                 executeFilterQuery·p0.99:   326.631 ms/op
                 executeFilterQuery·p0.999:  326.631 ms/op
                 executeFilterQuery·p0.9999: 326.631 ms/op
                 executeFilterQuery·p1.00:   326.631 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 313
  mean =    322.054 ±(99.9%) 0.565 ms/op

  Histogram, ms/op:
    [310.000, 311.250) = 0 
    [311.250, 312.500) = 0 
    [312.500, 313.750) = 2 
    [313.750, 315.000) = 5 
    [315.000, 316.250) = 13 
    [316.250, 317.500) = 7 
    [317.500, 318.750) = 9 
    [318.750, 320.000) = 24 
    [320.000, 321.250) = 46 
    [321.250, 322.500) = 66 
    [322.500, 323.750) = 54 
    [323.750, 325.000) = 39 
    [325.000, 326.250) = 26 
    [326.250, 327.500) = 14 
    [327.500, 328.750) = 8 

  Percentiles, ms/op:
      p(0.0000) =    313.000 ms/op
     p(50.0000) =    322.437 ms/op
     p(90.0000) =    325.583 ms/op
     p(95.0000) =    326.789 ms/op
     p(99.0000) =    327.680 ms/op
     p(99.9000) =    328.729 ms/op
     p(99.9900) =    328.729 ms/op
     p(99.9990) =    328.729 ms/op
     p(99.9999) =    328.729 ms/op
    p(100.0000) =    328.729 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/)

# Run progress: 56.33% complete, ETA 09:37:09
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

502.294 ±(99.9%) 239.057 ms/op
# Warmup Iteration   2: 328.018 ±(99.9%) 3.071 ms/op
# Warmup Iteration   3: 325.752 ±(99.9%) 1.758 ms/op
# Warmup Iteration   4: 325.059 ±(99.9%) 0.930 ms/op
# Warmup Iteration   5: 324.873 ±(99.9%) 1.084 ms/op
Iteration   1: 324.095 ±(99.9%) 1.536 ms/op
                 executeFilterQuery·p0.00:   316.670 ms/op
                 executeFilterQuery·p0.50:   324.010 ms/op
                 executeFilterQuery·p0.90:   326.002 ms/op
                 executeFilterQuery·p0.95:   328.624 ms/op
                 executeFilterQuery·p0.99:   332.399 ms/op
                 executeFilterQuery·p0.999:  332.399 ms/op
                 executeFilterQuery·p0.9999: 332.399 ms/op
                 executeFilterQuery·p1.00:   332.399 ms/op

Iteration   2: 323.655 ±(99.9%) 1.557 ms/op
                 executeFilterQuery·p0.00:   316.146 ms/op
                 executeFilterQuery·p0.50:   324.010 ms/op
                 executeFilterQuery·p0.90:   326.631 ms/op
                 executeFilterQuery·p0.95:   327.890 ms/op
                 executeFilterQuery·p0.99:   328.204 ms/op
                 executeFilterQuery·p0.999:  328.204 ms/op
                 executeFilterQuery·p0.9999: 328.204 ms/op
                 executeFilterQuery·p1.00:   328.204 ms/op

Iteration   3: 323.181 ±(99.9%) 1.670 ms/op
                 executeFilterQuery·p0.00:   316.146 ms/op
                 executeFilterQuery·p0.50:   323.486 ms/op
                 executeFilterQuery·p0.90:   326.422 ms/op
                 executeFilterQuery·p0.95:   328.099 ms/op
                 executeFilterQuery·p0.99:   328.729 ms/op
                 executeFilterQuery·p0.999:  328.729 ms/op
                 executeFilterQuery·p0.9999: 328.729 ms/op
                 executeFilterQuery·p1.00:   328.729 ms/op

Iteration   4: 322.911 ±(99.9%) 2.055 ms/op
                 executeFilterQuery·p0.00:   315.621 ms/op
                 executeFilterQuery·p0.50:   323.486 ms/op
                 executeFilterQuery·p0.90:   326.946 ms/op
                 executeFilterQuery·p0.95:   327.575 ms/op
                 executeFilterQuery·p0.99:   328.204 ms/op
                 executeFilterQuery·p0.999:  328.204 ms/op
                 executeFilterQuery·p0.9999: 328.204 ms/op
                 executeFilterQuery·p1.00:   328.204 ms/op

Iteration   5: 321.405 ±(99.9%) 2.594 ms/op
                 executeFilterQuery·p0.00:   315.621 ms/op
                 executeFilterQuery·p0.50:   322.437 ms/op
                 executeFilterQuery·p0.90:   327.208 ms/op
                 executeFilterQuery·p0.95:   328.729 ms/op
                 executeFilterQuery·p0.99:   328.729 ms/op
                 executeFilterQuery·p0.999:  328.729 ms/op
                 executeFilterQuery·p0.9999: 328.729 ms/op
                 executeFilterQuery·p1.00:   328.729 ms/op


# Run progress: 56.65% complete, ETA 09:31:05
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

489.460 ±(99.9%) 231.054 ms/op
# Warmup Iteration   2: 322.454 ±(99.9%) 3.106 ms/op
# Warmup Iteration   3: 321.536 ±(99.9%) 1.819 ms/op
# Warmup Iteration   4: 320.684 ±(99.9%) 1.032 ms/op
# Warmup Iteration   5: 322.420 ±(99.9%) 2.110 ms/op
Iteration   1: 320.799 ±(99.9%) 1.159 ms/op
                 executeFilterQuery·p0.00:   318.243 ms/op
                 executeFilterQuery·p0.50:   320.078 ms/op
                 executeFilterQuery·p0.90:   323.853 ms/op
                 executeFilterQuery·p0.95:   324.377 ms/op
                 executeFilterQuery·p0.99:   325.059 ms/op
                 executeFilterQuery·p0.999:  325.059 ms/op
                 executeFilterQuery·p0.9999: 325.059 ms/op
                 executeFilterQuery·p1.00:   325.059 ms/op

Iteration   2: 319.783 ±(99.9%) 1.105 ms/op
                 executeFilterQuery·p0.00:   317.719 ms/op
                 executeFilterQuery·p0.50:   319.291 ms/op
                 executeFilterQuery·p0.90:   323.171 ms/op
                 executeFilterQuery·p0.95:   323.669 ms/op
                 executeFilterQuery·p0.99:   324.010 ms/op
                 executeFilterQuery·p0.999:  324.010 ms/op
                 executeFilterQuery·p0.9999: 324.010 ms/op
                 executeFilterQuery·p1.00:   324.010 ms/op

Iteration   3: 317.030 ±(99.9%) 1.097 ms/op
                 executeFilterQuery·p0.00:   314.573 ms/op
                 executeFilterQuery·p0.50:   316.670 ms/op
                 executeFilterQuery·p0.90:   320.025 ms/op
                 executeFilterQuery·p0.95:   321.389 ms/op
                 executeFilterQuery·p0.99:   321.389 ms/op
                 executeFilterQuery·p0.999:  321.389 ms/op
                 executeFilterQuery·p0.9999: 321.389 ms/op
                 executeFilterQuery·p1.00:   321.389 ms/op

Iteration   4: 316.817 ±(99.9%) 1.388 ms/op
                 executeFilterQuery·p0.00:   312.476 ms/op
                 executeFilterQuery·p0.50:   316.408 ms/op
                 executeFilterQuery·p0.90:   319.658 ms/op
                 executeFilterQuery·p0.95:   321.756 ms/op
                 executeFilterQuery·p0.99:   322.437 ms/op
                 executeFilterQuery·p0.999:  322.437 ms/op
                 executeFilterQuery·p0.9999: 322.437 ms/op
                 executeFilterQuery·p1.00:   322.437 ms/op

Iteration   5: 316.424 ±(99.9%) 1.151 ms/op
                 executeFilterQuery·p0.00:   311.427 ms/op
                 executeFilterQuery·p0.50:   316.146 ms/op
                 executeFilterQuery·p0.90:   319.501 ms/op
                 executeFilterQuery·p0.95:   320.183 ms/op
                 executeFilterQuery·p0.99:   320.864 ms/op
                 executeFilterQuery·p0.999:  320.864 ms/op
                 executeFilterQuery·p0.9999: 320.864 ms/op
                 executeFilterQuery·p1.00:   320.864 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 316
  mean =    320.574 ±(99.9%) 0.696 ms/op

  Histogram, ms/op:
    [310.000, 312.500) = 2 
    [312.500, 315.000) = 9 
    [315.000, 317.500) = 74 
    [317.500, 320.000) = 69 
    [320.000, 322.500) = 48 
    [322.500, 325.000) = 78 
    [325.000, 327.500) = 27 
    [327.500, 330.000) = 8 
    [330.000, 332.500) = 1 
    [332.500, 335.000) = 0 
    [335.000, 337.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =    311.427 ms/op
     p(50.0000) =    320.340 ms/op
     p(90.0000) =    325.059 ms/op
     p(95.0000) =    326.107 ms/op
     p(99.0000) =    328.729 ms/op
     p(99.9000) =    332.399 ms/op
     p(99.9900) =    332.399 ms/op
     p(99.9990) =    332.399 ms/op
     p(99.9999) =    332.399 ms/op
    p(100.0000) =    332.399 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/)

# Run progress: 56.96% complete, ETA 09:25:04
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

4451.555 ±(99.9%) 34401.749 ms/op
# Warmup Iteration   2: 3186.622 ±(99.9%) 94.862 ms/op
# Warmup Iteration   3: 3175.088 ±(99.9%) 0.001 ms/op
# Warmup Iteration   4: 3149.922 ±(99.9%) 114.991 ms/op
# Warmup Iteration   5: 3157.262 ±(99.9%) 13.552 ms/op
Iteration   1: 3153.068 ±(99.9%) 25.950 ms/op
                 executeFilterQuery·p0.00:   3149.922 ms/op
                 executeFilterQuery·p0.50:   3152.019 ms/op
                 executeFilterQuery·p0.90:   3158.311 ms/op
                 executeFilterQuery·p0.95:   3158.311 ms/op
                 executeFilterQuery·p0.99:   3158.311 ms/op
                 executeFilterQuery·p0.999:  3158.311 ms/op
                 executeFilterQuery·p0.9999: 3158.311 ms/op
                 executeFilterQuery·p1.00:   3158.311 ms/op

Iteration   2: 3152.019 ±(99.9%) 34.991 ms/op
                 executeFilterQuery·p0.00:   3145.728 ms/op
                 executeFilterQuery·p0.50:   3152.019 ms/op
                 executeFilterQuery·p0.90:   3158.311 ms/op
                 executeFilterQuery·p0.95:   3158.311 ms/op
                 executeFilterQuery·p0.99:   3158.311 ms/op
                 executeFilterQuery·p0.999:  3158.311 ms/op
                 executeFilterQuery·p0.9999: 3158.311 ms/op
                 executeFilterQuery·p1.00:   3158.311 ms/op

Iteration   3: 3126.854 ±(99.9%) 208.186 ms/op
                 executeFilterQuery·p0.00:   3091.202 ms/op
                 executeFilterQuery·p0.50:   3131.048 ms/op
                 executeFilterQuery·p0.90:   3154.117 ms/op
                 executeFilterQuery·p0.95:   3154.117 ms/op
                 executeFilterQuery·p0.99:   3154.117 ms/op
                 executeFilterQuery·p0.999:  3154.117 ms/op
                 executeFilterQuery·p0.9999: 3154.117 ms/op
                 executeFilterQuery·p1.00:   3154.117 ms/op

Iteration   4: 3120.562 ±(99.9%) 164.120 ms/op
                 executeFilterQuery·p0.00:   3095.396 ms/op
                 executeFilterQuery·p0.50:   3118.465 ms/op
                 executeFilterQuery·p0.90:   3149.922 ms/op
                 executeFilterQuery·p0.95:   3149.922 ms/op
                 executeFilterQuery·p0.99:   3149.922 ms/op
                 executeFilterQuery·p0.999:  3149.922 ms/op
                 executeFilterQuery·p0.9999: 3149.922 ms/op
                 executeFilterQuery·p1.00:   3149.922 ms/op

Iteration   5: 3149.922 ±(99.9%) 31.296 ms/op
                 executeFilterQuery·p0.00:   3145.728 ms/op
                 executeFilterQuery·p0.50:   3149.922 ms/op
                 executeFilterQuery·p0.90:   3154.117 ms/op
                 executeFilterQuery·p0.95:   3154.117 ms/op
                 executeFilterQuery·p0.99:   3154.117 ms/op
                 executeFilterQuery·p0.999:  3154.117 ms/op
                 executeFilterQuery·p0.9999: 3154.117 ms/op
                 executeFilterQuery·p1.00:   3154.117 ms/op


# Run progress: 57.28% complete, ETA 09:19:25
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

4402.621 ±(99.9%) 35812.727 ms/op
# Warmup Iteration   2: 3261.071 ±(99.9%) 502.939 ms/op
# Warmup Iteration   3: 3205.497 ±(99.9%) 25.950 ms/op
# Warmup Iteration   4: 3191.865 ±(99.9%) 0.001 ms/op
# Warmup Iteration   5: 3197.108 ±(99.9%) 89.551 ms/op
Iteration   1: 3200.254 ±(99.9%) 96.462 ms/op
                 executeFilterQuery·p0.00:   3187.671 ms/op
                 executeFilterQuery·p0.50:   3198.157 ms/op
                 executeFilterQuery·p0.90:   3217.031 ms/op
                 executeFilterQuery·p0.95:   3217.031 ms/op
                 executeFilterQuery·p0.99:   3217.031 ms/op
                 executeFilterQuery·p0.999:  3217.031 ms/op
                 executeFilterQuery·p0.9999: 3217.031 ms/op
                 executeFilterQuery·p1.00:   3217.031 ms/op

Iteration   2: 3195.011 ±(99.9%) 94.862 ms/op
                 executeFilterQuery·p0.00:   3187.671 ms/op
                 executeFilterQuery·p0.50:   3187.671 ms/op
                 executeFilterQuery·p0.90:   3217.031 ms/op
                 executeFilterQuery·p0.95:   3217.031 ms/op
                 executeFilterQuery·p0.99:   3217.031 ms/op
                 executeFilterQuery·p0.999:  3217.031 ms/op
                 executeFilterQuery·p0.9999: 3217.031 ms/op
                 executeFilterQuery·p1.00:   3217.031 ms/op

Iteration   3: 3203.400 ±(99.9%) 46.288 ms/op
                 executeFilterQuery·p0.00:   3196.060 ms/op
                 executeFilterQuery·p0.50:   3202.351 ms/op
                 executeFilterQuery·p0.90:   3212.837 ms/op
                 executeFilterQuery·p0.95:   3212.837 ms/op
                 executeFilterQuery·p0.99:   3212.837 ms/op
                 executeFilterQuery·p0.999:  3212.837 ms/op
                 executeFilterQuery·p0.9999: 3212.837 ms/op
                 executeFilterQuery·p1.00:   3212.837 ms/op

Iteration   4: 3191.865 ±(99.9%) 127.127 ms/op
                 executeFilterQuery·p0.00:   3162.505 ms/op
                 executeFilterQuery·p0.50:   3200.254 ms/op
                 executeFilterQuery·p0.90:   3204.448 ms/op
                 executeFilterQuery·p0.95:   3204.448 ms/op
                 executeFilterQuery·p0.99:   3204.448 ms/op
                 executeFilterQuery·p0.999:  3204.448 ms/op
                 executeFilterQuery·p0.9999: 3204.448 ms/op
                 executeFilterQuery·p1.00:   3204.448 ms/op

Iteration   5: 3196.060 ±(99.9%) 44.260 ms/op
                 executeFilterQuery·p0.00:   3187.671 ms/op
                 executeFilterQuery·p0.50:   3196.060 ms/op
                 executeFilterQuery·p0.90:   3204.448 ms/op
                 executeFilterQuery·p0.95:   3204.448 ms/op
                 executeFilterQuery·p0.99:   3204.448 ms/op
                 executeFilterQuery·p0.999:  3204.448 ms/op
                 executeFilterQuery·p0.9999: 3204.448 ms/op
                 executeFilterQuery·p1.00:   3204.448 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 40
  mean =   3168.902 ±(99.9%) 19.005 ms/op

  Histogram, ms/op:
    [3000.000, 3025.000) = 0 
    [3025.000, 3050.000) = 0 
    [3050.000, 3075.000) = 0 
    [3075.000, 3100.000) = 2 
    [3100.000, 3125.000) = 2 
    [3125.000, 3150.000) = 8 
    [3150.000, 3175.000) = 9 
    [3175.000, 3200.000) = 9 
    [3200.000, 3225.000) = 10 
    [3225.000, 3250.000) = 0 
    [3250.000, 3275.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   3091.202 ms/op
     p(50.0000) =   3160.408 ms/op
     p(90.0000) =   3208.223 ms/op
     p(95.0000) =   3216.821 ms/op
     p(99.0000) =   3217.031 ms/op
     p(99.9000) =   3217.031 ms/op
     p(99.9900) =   3217.031 ms/op
     p(99.9990) =   3217.031 ms/op
     p(99.9999) =   3217.031 ms/op
    p(100.0000) =   3217.031 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/)

# Run progress: 57.59% complete, ETA 09:13:50
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

4334.114 ±(99.9%) 35696.456 ms/op
# Warmup Iteration   2: 3189.768 ±(99.9%) 135.518 ms/op
# Warmup Iteration   3: 3219.128 ±(99.9%) 637.750 ms/op
# Warmup Iteration   4: 3155.165 ±(99.9%) 71.281 ms/op
# Warmup Iteration   5: 3145.728 ±(99.9%) 58.550 ms/op
Iteration   1: 3167.748 ±(99.9%) 274.960 ms/op
                 executeFilterQuery·p0.00:   3133.145 ms/op
                 executeFilterQuery·p0.50:   3154.117 ms/op
                 executeFilterQuery·p0.90:   3229.614 ms/op
                 executeFilterQuery·p0.95:   3229.614 ms/op
                 executeFilterQuery·p0.99:   3229.614 ms/op
                 executeFilterQuery·p0.999:  3229.614 ms/op
                 executeFilterQuery·p0.9999: 3229.614 ms/op
                 executeFilterQuery·p1.00:   3229.614 ms/op

Iteration   2: 3148.874 ±(99.9%) 51.306 ms/op
                 executeFilterQuery·p0.00:   3137.339 ms/op
                 executeFilterQuery·p0.50:   3152.019 ms/op
                 executeFilterQuery·p0.90:   3154.117 ms/op
                 executeFilterQuery·p0.95:   3154.117 ms/op
                 executeFilterQuery·p0.99:   3154.117 ms/op
                 executeFilterQuery·p0.999:  3154.117 ms/op
                 executeFilterQuery·p0.9999: 3154.117 ms/op
                 executeFilterQuery·p1.00:   3154.117 ms/op

Iteration   3: 3176.137 ±(99.9%) 109.258 ms/op
                 executeFilterQuery·p0.00:   3158.311 ms/op
                 executeFilterQuery·p0.50:   3175.088 ms/op
                 executeFilterQuery·p0.90:   3196.060 ms/op
                 executeFilterQuery·p0.95:   3196.060 ms/op
                 executeFilterQuery·p0.99:   3196.060 ms/op
                 executeFilterQuery·p0.999:  3196.060 ms/op
                 executeFilterQuery·p0.9999: 3196.060 ms/op
                 executeFilterQuery·p1.00:   3196.060 ms/op

Iteration   4: 3148.874 ±(99.9%) 40.655 ms/op
                 executeFilterQuery·p0.00:   3141.534 ms/op
                 executeFilterQuery·p0.50:   3149.922 ms/op
                 executeFilterQuery·p0.90:   3154.117 ms/op
                 executeFilterQuery·p0.95:   3154.117 ms/op
                 executeFilterQuery·p0.99:   3154.117 ms/op
                 executeFilterQuery·p0.999:  3154.117 ms/op
                 executeFilterQuery·p0.9999: 3154.117 ms/op
                 executeFilterQuery·p1.00:   3154.117 ms/op

Iteration   5: 3156.214 ±(99.9%) 34.991 ms/op
                 executeFilterQuery·p0.00:   3149.922 ms/op
                 executeFilterQuery·p0.50:   3156.214 ms/op
                 executeFilterQuery·p0.90:   3162.505 ms/op
                 executeFilterQuery·p0.95:   3162.505 ms/op
                 executeFilterQuery·p0.99:   3162.505 ms/op
                 executeFilterQuery·p0.999:  3162.505 ms/op
                 executeFilterQuery·p0.9999: 3162.505 ms/op
                 executeFilterQuery·p1.00:   3162.505 ms/op


# Run progress: 57.91% complete, ETA 09:08:15
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

4408.214 ±(99.9%) 35985.183 ms/op
# Warmup Iteration   2: 3233.808 ±(99.9%) 58.550 ms/op
# Warmup Iteration   3: 3219.128 ±(99.9%) 27.104 ms/op
# Warmup Iteration   4: 3208.643 ±(99.9%) 31.296 ms/op
# Warmup Iteration   5: 3208.643 ±(99.9%) 76.660 ms/op
Iteration   1: 3197.108 ±(99.9%) 25.950 ms/op
                 executeFilterQuery·p0.00:   3191.865 ms/op
                 executeFilterQuery·p0.50:   3198.157 ms/op
                 executeFilterQuery·p0.90:   3200.254 ms/op
                 executeFilterQuery·p0.95:   3200.254 ms/op
                 executeFilterQuery·p0.99:   3200.254 ms/op
                 executeFilterQuery·p0.999:  3200.254 ms/op
                 executeFilterQuery·p0.9999: 3200.254 ms/op
                 executeFilterQuery·p1.00:   3200.254 ms/op

Iteration   2: 3201.303 ±(99.9%) 51.306 ms/op
                 executeFilterQuery·p0.00:   3196.060 ms/op
                 executeFilterQuery·p0.50:   3198.157 ms/op
                 executeFilterQuery·p0.90:   3212.837 ms/op
                 executeFilterQuery·p0.95:   3212.837 ms/op
                 executeFilterQuery·p0.99:   3212.837 ms/op
                 executeFilterQuery·p0.999:  3212.837 ms/op
                 executeFilterQuery·p0.9999: 3212.837 ms/op
                 executeFilterQuery·p1.00:   3212.837 ms/op

Iteration   3: 3211.788 ±(99.9%) 46.288 ms/op
                 executeFilterQuery·p0.00:   3204.448 ms/op
                 executeFilterQuery·p0.50:   3210.740 ms/op
                 executeFilterQuery·p0.90:   3221.225 ms/op
                 executeFilterQuery·p0.95:   3221.225 ms/op
                 executeFilterQuery·p0.99:   3221.225 ms/op
                 executeFilterQuery·p0.999:  3221.225 ms/op
                 executeFilterQuery·p0.9999: 3221.225 ms/op
                 executeFilterQuery·p1.00:   3221.225 ms/op

Iteration   4: 3195.011 ±(99.9%) 86.774 ms/op
                 executeFilterQuery·p0.00:   3175.088 ms/op
                 executeFilterQuery·p0.50:   3200.254 ms/op
                 executeFilterQuery·p0.90:   3204.448 ms/op
                 executeFilterQuery·p0.95:   3204.448 ms/op
                 executeFilterQuery·p0.99:   3204.448 ms/op
                 executeFilterQuery·p0.999:  3204.448 ms/op
                 executeFilterQuery·p0.9999: 3204.448 ms/op
                 executeFilterQuery·p1.00:   3204.448 ms/op

Iteration   5: 3195.011 ±(99.9%) 13.552 ms/op
                 executeFilterQuery·p0.00:   3191.865 ms/op
                 executeFilterQuery·p0.50:   3196.060 ms/op
                 executeFilterQuery·p0.90:   3196.060 ms/op
                 executeFilterQuery·p0.95:   3196.060 ms/op
                 executeFilterQuery·p0.99:   3196.060 ms/op
                 executeFilterQuery·p0.999:  3196.060 ms/op
                 executeFilterQuery·p0.9999: 3196.060 ms/op
                 executeFilterQuery·p1.00:   3196.060 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 40
  mean =   3179.807 ±(99.9%) 14.839 ms/op

  Histogram, ms/op:
    [3130.000, 3140.000) = 2 
    [3140.000, 3150.000) = 5 
    [3150.000, 3160.000) = 8 
    [3160.000, 3170.000) = 2 
    [3170.000, 3180.000) = 1 
    [3180.000, 3190.000) = 1 
    [3190.000, 3200.000) = 9 
    [3200.000, 3210.000) = 8 
    [3210.000, 3220.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =   3133.145 ms/op
     p(50.0000) =   3191.865 ms/op
     p(90.0000) =   3212.417 ms/op
     p(95.0000) =   3220.806 ms/op
     p(99.0000) =   3229.614 ms/op
     p(99.9000) =   3229.614 ms/op
     p(99.9900) =   3229.614 ms/op
     p(99.9990) =   3229.614 ms/op
     p(99.9999) =   3229.614 ms/op
    p(100.0000) =   3229.614 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/)

# Run progress: 58.23% complete, ETA 09:02:45
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

5167.383 ms/op
# Warmup Iteration   2: 3419.756 ±(99.9%) 116.886 ms/op
# Warmup Iteration   3: 3416.960 ±(99.9%) 116.886 ms/op
# Warmup Iteration   4: 3409.969 ±(99.9%) 76.520 ms/op
# Warmup Iteration   5: 3407.173 ±(99.9%) 44.179 ms/op
Iteration   1: 3401.581 ±(99.9%) 132.536 ms/op
                 executeFilterQuery·p0.00:   3397.386 ms/op
                 executeFilterQuery·p0.50:   3397.386 ms/op
                 executeFilterQuery·p0.90:   3409.969 ms/op
                 executeFilterQuery·p0.95:   3409.969 ms/op
                 executeFilterQuery·p0.99:   3409.969 ms/op
                 executeFilterQuery·p0.999:  3409.969 ms/op
                 executeFilterQuery·p0.9999: 3409.969 ms/op
                 executeFilterQuery·p1.00:   3409.969 ms/op

Iteration   2: 3401.581 ±(99.9%) 76.520 ms/op
                 executeFilterQuery·p0.00:   3397.386 ms/op
                 executeFilterQuery·p0.50:   3401.581 ms/op
                 executeFilterQuery·p0.90:   3405.775 ms/op
                 executeFilterQuery·p0.95:   3405.775 ms/op
                 executeFilterQuery·p0.99:   3405.775 ms/op
                 executeFilterQuery·p0.999:  3405.775 ms/op
                 executeFilterQuery·p0.9999: 3405.775 ms/op
                 executeFilterQuery·p1.00:   3405.775 ms/op

Iteration   3: 3390.396 ±(99.9%) 220.893 ms/op
                 executeFilterQuery·p0.00:   3376.415 ms/op
                 executeFilterQuery·p0.50:   3397.386 ms/op
                 executeFilterQuery·p0.90:   3397.386 ms/op
                 executeFilterQuery·p0.95:   3397.386 ms/op
                 executeFilterQuery·p0.99:   3397.386 ms/op
                 executeFilterQuery·p0.999:  3397.386 ms/op
                 executeFilterQuery·p0.9999: 3397.386 ms/op
                 executeFilterQuery·p1.00:   3397.386 ms/op

Iteration   4: 3380.609 ±(99.9%) 350.657 ms/op
                 executeFilterQuery·p0.00:   3359.638 ms/op
                 executeFilterQuery·p0.50:   3384.803 ms/op
                 executeFilterQuery·p0.90:   3397.386 ms/op
                 executeFilterQuery·p0.95:   3397.386 ms/op
                 executeFilterQuery·p0.99:   3397.386 ms/op
                 executeFilterQuery·p0.999:  3397.386 ms/op
                 executeFilterQuery·p0.9999: 3397.386 ms/op
                 executeFilterQuery·p1.00:   3397.386 ms/op

Iteration   5: 3383.405 ±(99.9%) 353.429 ms/op
                 executeFilterQuery·p0.00:   3372.220 ms/op
                 executeFilterQuery·p0.50:   3372.220 ms/op
                 executeFilterQuery·p0.90:   3405.775 ms/op
                 executeFilterQuery·p0.95:   3405.775 ms/op
                 executeFilterQuery·p0.99:   3405.775 ms/op
                 executeFilterQuery·p0.999:  3405.775 ms/op
                 executeFilterQuery·p0.9999: 3405.775 ms/op
                 executeFilterQuery·p1.00:   3405.775 ms/op


# Run progress: 58.54% complete, ETA 08:56:57
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

4397.029 ±(99.9%) 36160.756 ms/op
# Warmup Iteration   2: 3224.371 ±(99.9%) 131.622 ms/op
# Warmup Iteration   3: 3213.885 ±(99.9%) 34.105 ms/op
# Warmup Iteration   4: 3210.740 ±(99.9%) 15.648 ms/op
# Warmup Iteration   5: 3206.545 ±(99.9%) 15.648 ms/op
Iteration   1: 3204.448 ±(99.9%) 0.001 ms/op
                 executeFilterQuery·p0.00:   3204.448 ms/op
                 executeFilterQuery·p0.50:   3204.448 ms/op
                 executeFilterQuery·p0.90:   3204.448 ms/op
                 executeFilterQuery·p0.95:   3204.448 ms/op
                 executeFilterQuery·p0.99:   3204.448 ms/op
                 executeFilterQuery·p0.999:  3204.448 ms/op
                 executeFilterQuery·p0.9999: 3204.448 ms/op
                 executeFilterQuery·p1.00:   3204.448 ms/op

Iteration   2: 3204.448 ±(99.9%) 22.130 ms/op
                 executeFilterQuery·p0.00:   3200.254 ms/op
                 executeFilterQuery·p0.50:   3204.448 ms/op
                 executeFilterQuery·p0.90:   3208.643 ms/op
                 executeFilterQuery·p0.95:   3208.643 ms/op
                 executeFilterQuery·p0.99:   3208.643 ms/op
                 executeFilterQuery·p0.999:  3208.643 ms/op
                 executeFilterQuery·p0.9999: 3208.643 ms/op
                 executeFilterQuery·p1.00:   3208.643 ms/op

Iteration   3: 3201.303 ±(99.9%) 13.552 ms/op
                 executeFilterQuery·p0.00:   3200.254 ms/op
                 executeFilterQuery·p0.50:   3200.254 ms/op
                 executeFilterQuery·p0.90:   3204.448 ms/op
                 executeFilterQuery·p0.95:   3204.448 ms/op
                 executeFilterQuery·p0.99:   3204.448 ms/op
                 executeFilterQuery·p0.999:  3204.448 ms/op
                 executeFilterQuery·p0.9999: 3204.448 ms/op
                 executeFilterQuery·p1.00:   3204.448 ms/op

Iteration   4: 3190.817 ±(99.9%) 104.680 ms/op
                 executeFilterQuery·p0.00:   3166.700 ms/op
                 executeFilterQuery·p0.50:   3198.157 ms/op
                 executeFilterQuery·p0.90:   3200.254 ms/op
                 executeFilterQuery·p0.95:   3200.254 ms/op
                 executeFilterQuery·p0.99:   3200.254 ms/op
                 executeFilterQuery·p0.999:  3200.254 ms/op
                 executeFilterQuery·p0.9999: 3200.254 ms/op
                 executeFilterQuery·p1.00:   3200.254 ms/op

Iteration   5: 3200.254 ±(99.9%) 0.001 ms/op
                 executeFilterQuery·p0.00:   3200.254 ms/op
                 executeFilterQuery·p0.50:   3200.254 ms/op
                 executeFilterQuery·p0.90:   3200.254 ms/op
                 executeFilterQuery·p0.95:   3200.254 ms/op
                 executeFilterQuery·p0.99:   3200.254 ms/op
                 executeFilterQuery·p0.999:  3200.254 ms/op
                 executeFilterQuery·p0.9999: 3200.254 ms/op
                 executeFilterQuery·p1.00:   3200.254 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 35
  mean =   3282.223 ±(99.9%) 58.859 ms/op

  Histogram, ms/op:
    [3100.000, 3125.000) = 0 
    [3125.000, 3150.000) = 0 
    [3150.000, 3175.000) = 1 
    [3175.000, 3200.000) = 1 
    [3200.000, 3225.000) = 18 
    [3225.000, 3250.000) = 0 
    [3250.000, 3275.000) = 0 
    [3275.000, 3300.000) = 0 
    [3300.000, 3325.000) = 0 
    [3325.000, 3350.000) = 0 
    [3350.000, 3375.000) = 3 
    [3375.000, 3400.000) = 8 
    [3400.000, 3425.000) = 4 
    [3425.000, 3450.000) = 0 
    [3450.000, 3475.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   3166.700 ms/op
     p(50.0000) =   3204.448 ms/op
     p(90.0000) =   3403.258 ms/op
     p(95.0000) =   3406.614 ms/op
     p(99.0000) =   3409.969 ms/op
     p(99.9000) =   3409.969 ms/op
     p(99.9900) =   3409.969 ms/op
     p(99.9990) =   3409.969 ms/op
     p(99.9999) =   3409.969 ms/op
    p(100.0000) =   3409.969 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/)

# Run progress: 58.86% complete, ETA 08:51:31
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

8191.476 ms/op
# Warmup Iteration   2: 6387.925 ms/op
# Warmup Iteration   3: 6350.176 ms/op
# Warmup Iteration   4: 6325.010 ms/op
# Warmup Iteration   5: 6320.816 ms/op
Iteration   1: 6304.039 ms/op
                 executeFilterQuery·p0.00:   6299.845 ms/op
                 executeFilterQuery·p0.50:   6304.039 ms/op
                 executeFilterQuery·p0.90:   6308.233 ms/op
                 executeFilterQuery·p0.95:   6308.233 ms/op
                 executeFilterQuery·p0.99:   6308.233 ms/op
                 executeFilterQuery·p0.999:  6308.233 ms/op
                 executeFilterQuery·p0.9999: 6308.233 ms/op
                 executeFilterQuery·p1.00:   6308.233 ms/op

Iteration   2: 6320.816 ms/op
                 executeFilterQuery·p0.00:   6316.622 ms/op
                 executeFilterQuery·p0.50:   6320.816 ms/op
                 executeFilterQuery·p0.90:   6325.010 ms/op
                 executeFilterQuery·p0.95:   6325.010 ms/op
                 executeFilterQuery·p0.99:   6325.010 ms/op
                 executeFilterQuery·p0.999:  6325.010 ms/op
                 executeFilterQuery·p0.9999: 6325.010 ms/op
                 executeFilterQuery·p1.00:   6325.010 ms/op

Iteration   3: 6308.233 ms/op
                 executeFilterQuery·p0.00:   6299.845 ms/op
                 executeFilterQuery·p0.50:   6308.233 ms/op
                 executeFilterQuery·p0.90:   6316.622 ms/op
                 executeFilterQuery·p0.95:   6316.622 ms/op
                 executeFilterQuery·p0.99:   6316.622 ms/op
                 executeFilterQuery·p0.999:  6316.622 ms/op
                 executeFilterQuery·p0.9999: 6316.622 ms/op
                 executeFilterQuery·p1.00:   6316.622 ms/op

Iteration   4: 6320.816 ms/op
                 executeFilterQuery·p0.00:   6316.622 ms/op
                 executeFilterQuery·p0.50:   6320.816 ms/op
                 executeFilterQuery·p0.90:   6325.010 ms/op
                 executeFilterQuery·p0.95:   6325.010 ms/op
                 executeFilterQuery·p0.99:   6325.010 ms/op
                 executeFilterQuery·p0.999:  6325.010 ms/op
                 executeFilterQuery·p0.9999: 6325.010 ms/op
                 executeFilterQuery·p1.00:   6325.010 ms/op

Iteration   5: 6308.233 ms/op
                 executeFilterQuery·p0.00:   6308.233 ms/op
                 executeFilterQuery·p0.50:   6308.233 ms/op
                 executeFilterQuery·p0.90:   6308.233 ms/op
                 executeFilterQuery·p0.95:   6308.233 ms/op
                 executeFilterQuery·p0.99:   6308.233 ms/op
                 executeFilterQuery·p0.999:  6308.233 ms/op
                 executeFilterQuery·p0.9999: 6308.233 ms/op
                 executeFilterQuery·p1.00:   6308.233 ms/op


# Run progress: 59.18% complete, ETA 08:46:07
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

10435.428 ms/op
# Warmup Iteration   2: 6849.298 ms/op
# Warmup Iteration   3: 6811.550 ms/op
# Warmup Iteration   4: 6790.578 ms/op
# Warmup Iteration   5: 6782.190 ms/op
Iteration   1: 6782.190 ms/op
                 executeFilterQuery·p0.00:   6777.995 ms/op
                 executeFilterQuery·p0.50:   6782.190 ms/op
                 executeFilterQuery·p0.90:   6786.384 ms/op
                 executeFilterQuery·p0.95:   6786.384 ms/op
                 executeFilterQuery·p0.99:   6786.384 ms/op
                 executeFilterQuery·p0.999:  6786.384 ms/op
                 executeFilterQuery·p0.9999: 6786.384 ms/op
                 executeFilterQuery·p1.00:   6786.384 ms/op

Iteration   2: 6777.995 ms/op
                 executeFilterQuery·p0.00:   6769.607 ms/op
                 executeFilterQuery·p0.50:   6777.995 ms/op
                 executeFilterQuery·p0.90:   6786.384 ms/op
                 executeFilterQuery·p0.95:   6786.384 ms/op
                 executeFilterQuery·p0.99:   6786.384 ms/op
                 executeFilterQuery·p0.999:  6786.384 ms/op
                 executeFilterQuery·p0.9999: 6786.384 ms/op
                 executeFilterQuery·p1.00:   6786.384 ms/op

Iteration   3: 6736.052 ms/op
                 executeFilterQuery·p0.00:   6710.886 ms/op
                 executeFilterQuery·p0.50:   6736.052 ms/op
                 executeFilterQuery·p0.90:   6761.218 ms/op
                 executeFilterQuery·p0.95:   6761.218 ms/op
                 executeFilterQuery·p0.99:   6761.218 ms/op
                 executeFilterQuery·p0.999:  6761.218 ms/op
                 executeFilterQuery·p0.9999: 6761.218 ms/op
                 executeFilterQuery·p1.00:   6761.218 ms/op

Iteration   4: 6777.995 ms/op
                 executeFilterQuery·p0.00:   6769.607 ms/op
                 executeFilterQuery·p0.50:   6777.995 ms/op
                 executeFilterQuery·p0.90:   6786.384 ms/op
                 executeFilterQuery·p0.95:   6786.384 ms/op
                 executeFilterQuery·p0.99:   6786.384 ms/op
                 executeFilterQuery·p0.999:  6786.384 ms/op
                 executeFilterQuery·p0.9999: 6786.384 ms/op
                 executeFilterQuery·p1.00:   6786.384 ms/op

Iteration   5: 6727.664 ms/op
                 executeFilterQuery·p0.00:   6677.332 ms/op
                 executeFilterQuery·p0.50:   6727.664 ms/op
                 executeFilterQuery·p0.90:   6777.995 ms/op
                 executeFilterQuery·p0.95:   6777.995 ms/op
                 executeFilterQuery·p0.99:   6777.995 ms/op
                 executeFilterQuery·p0.999:  6777.995 ms/op
                 executeFilterQuery·p0.9999: 6777.995 ms/op
                 executeFilterQuery·p1.00:   6777.995 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 20
  mean =   6536.403 ±(99.9%) 200.823 ms/op

  Histogram, ms/op:
    [6200.000, 6250.000) = 0 
    [6250.000, 6300.000) = 2 
    [6300.000, 6350.000) = 8 
    [6350.000, 6400.000) = 0 
    [6400.000, 6450.000) = 0 
    [6450.000, 6500.000) = 0 
    [6500.000, 6550.000) = 0 
    [6550.000, 6600.000) = 0 
    [6600.000, 6650.000) = 0 
    [6650.000, 6700.000) = 1 
    [6700.000, 6750.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   6299.845 ms/op
     p(50.0000) =   6501.171 ms/op
     p(90.0000) =   6786.384 ms/op
     p(95.0000) =   6786.384 ms/op
     p(99.0000) =   6786.384 ms/op
     p(99.9000) =   6786.384 ms/op
     p(99.9900) =   6786.384 ms/op
     p(99.9990) =   6786.384 ms/op
     p(99.9999) =   6786.384 ms/op
    p(100.0000) =   6786.384 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/)

# Run progress: 59.49% complete, ETA 08:40:48
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

8279.556 ms/op
# Warmup Iteration   2: 6429.868 ms/op
# Warmup Iteration   3: 6366.953 ms/op
# Warmup Iteration   4: 6408.897 ms/op
# Warmup Iteration   5: 6408.897 ms/op
Iteration   1: 6375.342 ms/op
                 executeFilterQuery·p0.00:   6358.565 ms/op
                 executeFilterQuery·p0.50:   6375.342 ms/op
                 executeFilterQuery·p0.90:   6392.119 ms/op
                 executeFilterQuery·p0.95:   6392.119 ms/op
                 executeFilterQuery·p0.99:   6392.119 ms/op
                 executeFilterQuery·p0.999:  6392.119 ms/op
                 executeFilterQuery·p0.9999: 6392.119 ms/op
                 executeFilterQuery·p1.00:   6392.119 ms/op

Iteration   2: 6358.565 ms/op
                 executeFilterQuery·p0.00:   6325.010 ms/op
                 executeFilterQuery·p0.50:   6358.565 ms/op
                 executeFilterQuery·p0.90:   6392.119 ms/op
                 executeFilterQuery·p0.95:   6392.119 ms/op
                 executeFilterQuery·p0.99:   6392.119 ms/op
                 executeFilterQuery·p0.999:  6392.119 ms/op
                 executeFilterQuery·p0.9999: 6392.119 ms/op
                 executeFilterQuery·p1.00:   6392.119 ms/op

Iteration   3: 6387.925 ms/op
                 executeFilterQuery·p0.00:   6366.953 ms/op
                 executeFilterQuery·p0.50:   6387.925 ms/op
                 executeFilterQuery·p0.90:   6408.897 ms/op
                 executeFilterQuery·p0.95:   6408.897 ms/op
                 executeFilterQuery·p0.99:   6408.897 ms/op
                 executeFilterQuery·p0.999:  6408.897 ms/op
                 executeFilterQuery·p0.9999: 6408.897 ms/op
                 executeFilterQuery·p1.00:   6408.897 ms/op

Iteration   4: 6404.702 ms/op
                 executeFilterQuery·p0.00:   6400.508 ms/op
                 executeFilterQuery·p0.50:   6404.702 ms/op
                 executeFilterQuery·p0.90:   6408.897 ms/op
                 executeFilterQuery·p0.95:   6408.897 ms/op
                 executeFilterQuery·p0.99:   6408.897 ms/op
                 executeFilterQuery·p0.999:  6408.897 ms/op
                 executeFilterQuery·p0.9999: 6408.897 ms/op
                 executeFilterQuery·p1.00:   6408.897 ms/op

Iteration   5: 6375.342 ms/op
                 executeFilterQuery·p0.00:   6375.342 ms/op
                 executeFilterQuery·p0.50:   6375.342 ms/op
                 executeFilterQuery·p0.90:   6375.342 ms/op
                 executeFilterQuery·p0.95:   6375.342 ms/op
                 executeFilterQuery·p0.99:   6375.342 ms/op
                 executeFilterQuery·p0.999:  6375.342 ms/op
                 executeFilterQuery·p0.9999: 6375.342 ms/op
                 executeFilterQuery·p1.00:   6375.342 ms/op


# Run progress: 59.81% complete, ETA 08:35:30
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

8145.338 ms/op
# Warmup Iteration   2: 6413.091 ms/op
# Warmup Iteration   3: 6333.399 ms/op
# Warmup Iteration   4: 6392.119 ms/op
# Warmup Iteration   5: 6425.674 ms/op
Iteration   1: 6371.148 ms/op
                 executeFilterQuery·p0.00:   6325.010 ms/op
                 executeFilterQuery·p0.50:   6371.148 ms/op
                 executeFilterQuery·p0.90:   6417.285 ms/op
                 executeFilterQuery·p0.95:   6417.285 ms/op
                 executeFilterQuery·p0.99:   6417.285 ms/op
                 executeFilterQuery·p0.999:  6417.285 ms/op
                 executeFilterQuery·p0.9999: 6417.285 ms/op
                 executeFilterQuery·p1.00:   6417.285 ms/op

Iteration   2: 6362.759 ms/op
                 executeFilterQuery·p0.00:   6308.233 ms/op
                 executeFilterQuery·p0.50:   6362.759 ms/op
                 executeFilterQuery·p0.90:   6417.285 ms/op
                 executeFilterQuery·p0.95:   6417.285 ms/op
                 executeFilterQuery·p0.99:   6417.285 ms/op
                 executeFilterQuery·p0.999:  6417.285 ms/op
                 executeFilterQuery·p0.9999: 6417.285 ms/op
                 executeFilterQuery·p1.00:   6417.285 ms/op

Iteration   3: 6417.285 ms/op
                 executeFilterQuery·p0.00:   6417.285 ms/op
                 executeFilterQuery·p0.50:   6417.285 ms/op
                 executeFilterQuery·p0.90:   6417.285 ms/op
                 executeFilterQuery·p0.95:   6417.285 ms/op
                 executeFilterQuery·p0.99:   6417.285 ms/op
                 executeFilterQuery·p0.999:  6417.285 ms/op
                 executeFilterQuery·p0.9999: 6417.285 ms/op
                 executeFilterQuery·p1.00:   6417.285 ms/op

Iteration   4: 6408.897 ms/op
                 executeFilterQuery·p0.00:   6408.897 ms/op
                 executeFilterQuery·p0.50:   6408.897 ms/op
                 executeFilterQuery·p0.90:   6408.897 ms/op
                 executeFilterQuery·p0.95:   6408.897 ms/op
                 executeFilterQuery·p0.99:   6408.897 ms/op
                 executeFilterQuery·p0.999:  6408.897 ms/op
                 executeFilterQuery·p0.9999: 6408.897 ms/op
                 executeFilterQuery·p1.00:   6408.897 ms/op

Iteration   5: 6413.091 ms/op
                 executeFilterQuery·p0.00:   6408.897 ms/op
                 executeFilterQuery·p0.50:   6413.091 ms/op
                 executeFilterQuery·p0.90:   6417.285 ms/op
                 executeFilterQuery·p0.95:   6417.285 ms/op
                 executeFilterQuery·p0.99:   6417.285 ms/op
                 executeFilterQuery·p0.999:  6417.285 ms/op
                 executeFilterQuery·p0.9999: 6417.285 ms/op
                 executeFilterQuery·p1.00:   6417.285 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 20
  mean =   6387.506 ±(99.9%) 29.938 ms/op

  Histogram, ms/op:
    [6300.000, 6312.500) = 1 
    [6312.500, 6325.000) = 0 
    [6325.000, 6337.500) = 2 
    [6337.500, 6350.000) = 0 
    [6350.000, 6362.500) = 1 
    [6362.500, 6375.000) = 1 
    [6375.000, 6387.500) = 2 
    [6387.500, 6400.000) = 2 
    [6400.000, 6412.500) = 6 
    [6412.500, 6425.000) = 5 
    [6425.000, 6437.500) = 0 
    [6437.500, 6450.000) = 0 
    [6450.000, 6462.500) = 0 
    [6462.500, 6475.000) = 0 
    [6475.000, 6487.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   6308.233 ms/op
     p(50.0000) =   6404.702 ms/op
     p(90.0000) =   6417.285 ms/op
     p(95.0000) =   6417.285 ms/op
     p(99.0000) =   6417.285 ms/op
     p(99.9000) =   6417.285 ms/op
     p(99.9900) =   6417.285 ms/op
     p(99.9990) =   6417.285 ms/op
     p(99.9999) =   6417.285 ms/op
    p(100.0000) =   6417.285 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.filter_query.VectorisedSimd.executeFilterQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/)

# Run progress: 60.13% complete, ETA 08:30:13
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

10401.874 ms/op
# Warmup Iteration   2: 7113.540 ms/op
# Warmup Iteration   3: 6761.218 ms/op
# Warmup Iteration   4: 6782.190 ms/op
# Warmup Iteration   5: 6723.469 ms/op
Iteration   1: 6790.578 ms/op
                 executeFilterQuery·p0.00:   6786.384 ms/op
                 executeFilterQuery·p0.50:   6790.578 ms/op
                 executeFilterQuery·p0.90:   6794.772 ms/op
                 executeFilterQuery·p0.95:   6794.772 ms/op
                 executeFilterQuery·p0.99:   6794.772 ms/op
                 executeFilterQuery·p0.999:  6794.772 ms/op
                 executeFilterQuery·p0.9999: 6794.772 ms/op
                 executeFilterQuery·p1.00:   6794.772 ms/op

Iteration   2: 6798.967 ms/op
                 executeFilterQuery·p0.00:   6794.772 ms/op
                 executeFilterQuery·p0.50:   6798.967 ms/op
                 executeFilterQuery·p0.90:   6803.161 ms/op
                 executeFilterQuery·p0.95:   6803.161 ms/op
                 executeFilterQuery·p0.99:   6803.161 ms/op
                 executeFilterQuery·p0.999:  6803.161 ms/op
                 executeFilterQuery·p0.9999: 6803.161 ms/op
                 executeFilterQuery·p1.00:   6803.161 ms/op

Iteration   3: 6727.664 ms/op
                 executeFilterQuery·p0.00:   6677.332 ms/op
                 executeFilterQuery·p0.50:   6727.664 ms/op
                 executeFilterQuery·p0.90:   6777.995 ms/op
                 executeFilterQuery·p0.95:   6777.995 ms/op
                 executeFilterQuery·p0.99:   6777.995 ms/op
                 executeFilterQuery·p0.999:  6777.995 ms/op
                 executeFilterQuery·p0.9999: 6777.995 ms/op
                 executeFilterQuery·p1.00:   6777.995 ms/op

Iteration   4: 6777.995 ms/op
                 executeFilterQuery·p0.00:   6769.607 ms/op
                 executeFilterQuery·p0.50:   6777.995 ms/op
                 executeFilterQuery·p0.90:   6786.384 ms/op
                 executeFilterQuery·p0.95:   6786.384 ms/op
                 executeFilterQuery·p0.99:   6786.384 ms/op
                 executeFilterQuery·p0.999:  6786.384 ms/op
                 executeFilterQuery·p0.9999: 6786.384 ms/op
                 executeFilterQuery·p1.00:   6786.384 ms/op

Iteration   5: 6794.772 ms/op
                 executeFilterQuery·p0.00:   6794.772 ms/op
                 executeFilterQuery·p0.50:   6794.772 ms/op
                 executeFilterQuery·p0.90:   6794.772 ms/op
                 executeFilterQuery·p0.95:   6794.772 ms/op
                 executeFilterQuery·p0.99:   6794.772 ms/op
                 executeFilterQuery·p0.999:  6794.772 ms/op
                 executeFilterQuery·p0.9999: 6794.772 ms/op
                 executeFilterQuery·p1.00:   6794.772 ms/op


# Run progress: 60.44% complete, ETA 08:25:00
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
boolean[] ordinal_0_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_1_val_mask = cCtx.getAllocationManager().getBooleanVector();
boolean[] ordinal_2_val_mask = cCtx.getAllocationManager().getBooleanVector();
long count = 0;
ArrowTableReader filter_query_table = cCtx.getArrowReader(0);
while (filter_query_table.loadNextBatch()) {
    org.apache.arrow.vector.IntVector filter_query_table_vc_0 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(0));
    org.apache.arrow.vector.IntVector filter_query_table_vc_1 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(1));
    org.apache.arrow.vector.IntVector filter_query_table_vc_2 = ((org.apache.arrow.vector.IntVector) filter_query_table.getVector(2));
    int ordinal_0_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_0, 3000, ordinal_0_val_mask);
    int ordinal_1_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_1, 3000, ordinal_1_val_mask, ordinal_0_val_mask, ordinal_0_val_mask_length);
    int ordinal_2_val_mask_length = VectorisedFilterOperators.ltSIMD(filter_query_table_vc_2, 3000, ordinal_2_val_mask, ordinal_1_val_mask, ordinal_1_val_mask_length);
    count += VectorisedAggregationOperators.count(ordinal_2_val_mask, ordinal_2_val_mask_length);
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);
cCtx.getAllocationManager().release(ordinal_0_val_mask);
cCtx.getAllocationManager().release(ordinal_1_val_mask);
cCtx.getAllocationManager().release(ordinal_2_val_mask);

8178.893 ms/op
# Warmup Iteration   2: 6530.531 ms/op
# Warmup Iteration   3: 6379.536 ms/op
# Warmup Iteration   4: 6358.565 ms/op
# Warmup Iteration   5: 6350.176 ms/op
Iteration   1: 6350.176 ms/op
                 executeFilterQuery·p0.00:   6341.788 ms/op
                 executeFilterQuery·p0.50:   6350.176 ms/op
                 executeFilterQuery·p0.90:   6358.565 ms/op
                 executeFilterQuery·p0.95:   6358.565 ms/op
                 executeFilterQuery·p0.99:   6358.565 ms/op
                 executeFilterQuery·p0.999:  6358.565 ms/op
                 executeFilterQuery·p0.9999: 6358.565 ms/op
                 executeFilterQuery·p1.00:   6358.565 ms/op

Iteration   2: 6358.565 ms/op
                 executeFilterQuery·p0.00:   6350.176 ms/op
                 executeFilterQuery·p0.50:   6358.565 ms/op
                 executeFilterQuery·p0.90:   6366.953 ms/op
                 executeFilterQuery·p0.95:   6366.953 ms/op
                 executeFilterQuery·p0.99:   6366.953 ms/op
                 executeFilterQuery·p0.999:  6366.953 ms/op
                 executeFilterQuery·p0.9999: 6366.953 ms/op
                 executeFilterQuery·p1.00:   6366.953 ms/op

Iteration   3: 6354.371 ms/op
                 executeFilterQuery·p0.00:   6350.176 ms/op
                 executeFilterQuery·p0.50:   6354.371 ms/op
                 executeFilterQuery·p0.90:   6358.565 ms/op
                 executeFilterQuery·p0.95:   6358.565 ms/op
                 executeFilterQuery·p0.99:   6358.565 ms/op
                 executeFilterQuery·p0.999:  6358.565 ms/op
                 executeFilterQuery·p0.9999: 6358.565 ms/op
                 executeFilterQuery·p1.00:   6358.565 ms/op

Iteration   4: 6350.176 ms/op
                 executeFilterQuery·p0.00:   6350.176 ms/op
                 executeFilterQuery·p0.50:   6350.176 ms/op
                 executeFilterQuery·p0.90:   6350.176 ms/op
                 executeFilterQuery·p0.95:   6350.176 ms/op
                 executeFilterQuery·p0.99:   6350.176 ms/op
                 executeFilterQuery·p0.999:  6350.176 ms/op
                 executeFilterQuery·p0.9999: 6350.176 ms/op
                 executeFilterQuery·p1.00:   6350.176 ms/op

Iteration   5: 6354.371 ms/op
                 executeFilterQuery·p0.00:   6350.176 ms/op
                 executeFilterQuery·p0.50:   6354.371 ms/op
                 executeFilterQuery·p0.90:   6358.565 ms/op
                 executeFilterQuery·p0.95:   6358.565 ms/op
                 executeFilterQuery·p0.99:   6358.565 ms/op
                 executeFilterQuery·p0.999:  6358.565 ms/op
                 executeFilterQuery·p0.9999: 6358.565 ms/op
                 executeFilterQuery·p1.00:   6358.565 ms/op



Result "benchmarks.filter_query.VectorisedSimd.executeFilterQuery":
  N = 20
  mean =   6565.763 ±(99.9%) 190.393 ms/op

  Histogram, ms/op:
    [6300.000, 6350.000) = 1 
    [6350.000, 6400.000) = 9 
    [6400.000, 6450.000) = 0 
    [6450.000, 6500.000) = 0 
    [6500.000, 6550.000) = 0 
    [6550.000, 6600.000) = 0 
    [6600.000, 6650.000) = 0 
    [6650.000, 6700.000) = 1 
    [6700.000, 6750.000) = 0 
    [6750.000, 6800.000) = 8 
    [6800.000, 6850.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   6341.788 ms/op
     p(50.0000) =   6522.143 ms/op
     p(90.0000) =   6794.772 ms/op
     p(95.0000) =   6802.742 ms/op
     p(99.0000) =   6803.161 ms/op
     p(99.9000) =   6803.161 ms/op
     p(99.9900) =   6803.161 ms/op
     p(99.9990) =   6803.161 ms/op
     p(99.9999) =   6803.161 ms/op
    p(100.0000) =   6803.161 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 60.76% complete, ETA 08:19:47
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
private final class KeyMultiRecordMap_2085662372 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_2085662372() {
        this(4);
    }
    public KeyMultiRecordMap_2085662372(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_2085662372 join_map = new KeyMultiRecordMap_2085662372();
private final class KeyMultiRecordMap_1638995636 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1638995636() {
        this(4);
    }
    public KeyMultiRecordMap_1638995636(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1638995636 join_map_0 = new KeyMultiRecordMap_1638995636();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int recordCount = table_A_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_A_vc_0.get(aviv);
        long left_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = table_A_vc_1.get(aviv);
        int ordinal_value_1 = table_A_vc_2.get(aviv);
        join_map_0.associate(ordinal_value, left_join_key_prehash, ordinal_value, ordinal_value_0, ordinal_value_1);
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int recordCount = table_B_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_B_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map_0.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_B_vc_1.get(aviv);
        int ordinal_value_1 = table_B_vc_2.get(aviv);
        int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
            long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
            join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, ordinal_value, ordinal_value_0, ordinal_value_1);
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int recordCount = table_C_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_C_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_C_vc_1.get(aviv);
        int ordinal_value_1 = table_C_vc_2.get(aviv);
        int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
            int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
            int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
            int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
            count++;
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5158.994 ms/op
# Warmup Iteration   2: 4910.132 ±(99.9%) 1540.563 ms/op
# Warmup Iteration   3: 4898.947 ±(99.9%) 3049.289 ms/op
# Warmup Iteration   4: 4700.417 ±(99.9%) 1018.987 ms/op
# Warmup Iteration   5: 4767.526 ±(99.9%) 3443.671 ms/op
Iteration   1: 4756.341 ±(99.9%) 2223.026 ms/op
                 executeQuery·p0.00:   4630.512 ms/op
                 executeQuery·p0.50:   4764.729 ms/op
                 executeQuery·p0.90:   4873.781 ms/op
                 executeQuery·p0.95:   4873.781 ms/op
                 executeQuery·p0.99:   4873.781 ms/op
                 executeQuery·p0.999:  4873.781 ms/op
                 executeQuery·p0.9999: 4873.781 ms/op
                 executeQuery·p1.00:   4873.781 ms/op

Iteration   2: 4736.767 ±(99.9%) 2831.574 ms/op
                 executeQuery·p0.00:   4638.900 ms/op
                 executeQuery·p0.50:   4655.677 ms/op
                 executeQuery·p0.90:   4915.724 ms/op
                 executeQuery·p0.95:   4915.724 ms/op
                 executeQuery·p0.99:   4915.724 ms/op
                 executeQuery·p0.999:  4915.724 ms/op
                 executeQuery·p0.9999: 4915.724 ms/op
                 executeQuery·p1.00:   4915.724 ms/op

Iteration   3: 4747.952 ±(99.9%) 2528.627 ms/op
                 executeQuery·p0.00:   4588.569 ms/op
                 executeQuery·p0.50:   4815.061 ms/op
                 executeQuery·p0.90:   4840.227 ms/op
                 executeQuery·p0.95:   4840.227 ms/op
                 executeQuery·p0.99:   4840.227 ms/op
                 executeQuery·p0.999:  4840.227 ms/op
                 executeQuery·p0.9999: 4840.227 ms/op
                 executeQuery·p1.00:   4840.227 ms/op

Iteration   4: 4661.270 ±(99.9%) 1107.115 ms/op
                 executeQuery·p0.00:   4622.123 ms/op
                 executeQuery·p0.50:   4630.512 ms/op
                 executeQuery·p0.90:   4731.175 ms/op
                 executeQuery·p0.95:   4731.175 ms/op
                 executeQuery·p0.99:   4731.175 ms/op
                 executeQuery·p0.999:  4731.175 ms/op
                 executeQuery·p0.9999: 4731.175 ms/op
                 executeQuery·p1.00:   4731.175 ms/op

Iteration   5: 4764.729 ±(99.9%) 2158.887 ms/op
                 executeQuery·p0.00:   4638.900 ms/op
                 executeQuery·p0.50:   4781.507 ms/op
                 executeQuery·p0.90:   4873.781 ms/op
                 executeQuery·p0.95:   4873.781 ms/op
                 executeQuery·p0.99:   4873.781 ms/op
                 executeQuery·p0.999:  4873.781 ms/op
                 executeQuery·p0.9999: 4873.781 ms/op
                 executeQuery·p1.00:   4873.781 ms/op


# Run progress: 61.08% complete, ETA 08:14:41
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
private final class KeyMultiRecordMap_433423373 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_433423373() {
        this(4);
    }
    public KeyMultiRecordMap_433423373(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_433423373 join_map = new KeyMultiRecordMap_433423373();
private final class KeyMultiRecordMap_1188733428 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1188733428() {
        this(4);
    }
    public KeyMultiRecordMap_1188733428(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1188733428 join_map_0 = new KeyMultiRecordMap_1188733428();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int recordCount = table_A_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_A_vc_0.get(aviv);
        long left_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = table_A_vc_1.get(aviv);
        int ordinal_value_1 = table_A_vc_2.get(aviv);
        join_map_0.associate(ordinal_value, left_join_key_prehash, ordinal_value, ordinal_value_0, ordinal_value_1);
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int recordCount = table_B_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_B_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map_0.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_B_vc_1.get(aviv);
        int ordinal_value_1 = table_B_vc_2.get(aviv);
        int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
            long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
            join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, ordinal_value, ordinal_value_0, ordinal_value_1);
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int recordCount = table_C_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_C_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_C_vc_1.get(aviv);
        int ordinal_value_1 = table_C_vc_2.get(aviv);
        int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
            int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
            int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
            int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
            count++;
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5108.662 ms/op
# Warmup Iteration   2: 5024.776 ms/op
# Warmup Iteration   3: 5020.582 ms/op
# Warmup Iteration   4: 4809.469 ±(99.9%) 4917.149 ms/op
# Warmup Iteration   5: 4711.601 ±(99.9%) 1548.146 ms/op
Iteration   1: 4789.895 ±(99.9%) 2405.204 ms/op
                 executeQuery·p0.00:   4672.455 ms/op
                 executeQuery·p0.50:   4764.729 ms/op
                 executeQuery·p0.90:   4932.502 ms/op
                 executeQuery·p0.95:   4932.502 ms/op
                 executeQuery·p0.99:   4932.502 ms/op
                 executeQuery·p0.999:  4932.502 ms/op
                 executeQuery·p0.9999: 4932.502 ms/op
                 executeQuery·p1.00:   4932.502 ms/op

Iteration   2: 4770.322 ±(99.9%) 537.457 ms/op
                 executeQuery·p0.00:   4739.564 ms/op
                 executeQuery·p0.50:   4773.118 ms/op
                 executeQuery·p0.90:   4798.284 ms/op
                 executeQuery·p0.95:   4798.284 ms/op
                 executeQuery·p0.99:   4798.284 ms/op
                 executeQuery·p0.999:  4798.284 ms/op
                 executeQuery·p0.9999: 4798.284 ms/op
                 executeQuery·p1.00:   4798.284 ms/op

Iteration   3: 4764.729 ±(99.9%) 1459.903 ms/op
                 executeQuery·p0.00:   4689.232 ms/op
                 executeQuery·p0.50:   4756.341 ms/op
                 executeQuery·p0.90:   4848.615 ms/op
                 executeQuery·p0.95:   4848.615 ms/op
                 executeQuery·p0.99:   4848.615 ms/op
                 executeQuery·p0.999:  4848.615 ms/op
                 executeQuery·p0.9999: 4848.615 ms/op
                 executeQuery·p1.00:   4848.615 ms/op

Iteration   4: 4742.360 ±(99.9%) 2342.720 ms/op
                 executeQuery·p0.00:   4664.066 ms/op
                 executeQuery·p0.50:   4672.455 ms/op
                 executeQuery·p0.90:   4890.558 ms/op
                 executeQuery·p0.95:   4890.558 ms/op
                 executeQuery·p0.99:   4890.558 ms/op
                 executeQuery·p0.999:  4890.558 ms/op
                 executeQuery·p0.9999: 4890.558 ms/op
                 executeQuery·p1.00:   4890.558 ms/op

Iteration   5: 4689.232 ±(99.9%) 1655.375 ms/op
                 executeQuery·p0.00:   4613.734 ms/op
                 executeQuery·p0.50:   4664.066 ms/op
                 executeQuery·p0.90:   4789.895 ms/op
                 executeQuery·p0.95:   4789.895 ms/op
                 executeQuery·p0.99:   4789.895 ms/op
                 executeQuery·p0.999:  4789.895 ms/op
                 executeQuery·p0.9999: 4789.895 ms/op
                 executeQuery·p1.00:   4789.895 ms/op



Result "benchmarks.join_query.NonVectorisedNonSimd.executeQuery":
  N = 30
  mean =   4742.360 ±(99.9%) 66.985 ms/op

  Histogram, ms/op:
    [4500.000, 4550.000) = 0 
    [4550.000, 4600.000) = 1 
    [4600.000, 4650.000) = 6 
    [4650.000, 4700.000) = 6 
    [4700.000, 4750.000) = 2 
    [4750.000, 4800.000) = 7 
    [4800.000, 4850.000) = 3 
    [4850.000, 4900.000) = 3 
    [4900.000, 4950.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =   4588.569 ms/op
     p(50.0000) =   4747.952 ms/op
     p(90.0000) =   4888.881 ms/op
     p(95.0000) =   4923.274 ms/op
     p(99.0000) =   4932.502 ms/op
     p(99.9000) =   4932.502 ms/op
     p(99.9900) =   4932.502 ms/op
     p(99.9990) =   4932.502 ms/op
     p(99.9999) =   4932.502 ms/op
    p(100.0000) =   4932.502 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 61.39% complete, ETA 08:09:31
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
private final class KeyMultiRecordMap_433423373 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_433423373() {
        this(4);
    }
    public KeyMultiRecordMap_433423373(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_433423373 join_map = new KeyMultiRecordMap_433423373();
private final class KeyMultiRecordMap_1188733428 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1188733428() {
        this(4);
    }
    public KeyMultiRecordMap_1188733428(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1188733428 join_map_0 = new KeyMultiRecordMap_1188733428();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int recordCount = table_A_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_A_vc_0.get(aviv);
        long left_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = table_A_vc_1.get(aviv);
        int ordinal_value_1 = table_A_vc_2.get(aviv);
        join_map_0.associate(ordinal_value, left_join_key_prehash, ordinal_value, ordinal_value_0, ordinal_value_1);
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int recordCount = table_B_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_B_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map_0.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_B_vc_1.get(aviv);
        int ordinal_value_1 = table_B_vc_2.get(aviv);
        int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
            long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
            join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, ordinal_value, ordinal_value_0, ordinal_value_1);
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int recordCount = table_C_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_C_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_C_vc_1.get(aviv);
        int ordinal_value_1 = table_C_vc_2.get(aviv);
        int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
            int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
            int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
            int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
            count++;
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

57713.623 ms/op
# Warmup Iteration   2: 55163.486 ms/op
# Warmup Iteration   3: 55700.357 ms/op
# Warmup Iteration   4: 53552.873 ms/op
# Warmup Iteration   5: 54827.942 ms/op
Iteration   1: 54492.398 ms/op
                 executeQuery·p0.00:   54492.398 ms/op
                 executeQuery·p0.50:   54492.398 ms/op
                 executeQuery·p0.90:   54492.398 ms/op
                 executeQuery·p0.95:   54492.398 ms/op
                 executeQuery·p0.99:   54492.398 ms/op
                 executeQuery·p0.999:  54492.398 ms/op
                 executeQuery·p0.9999: 54492.398 ms/op
                 executeQuery·p1.00:   54492.398 ms/op

Iteration   2: 54291.071 ms/op
                 executeQuery·p0.00:   54291.071 ms/op
                 executeQuery·p0.50:   54291.071 ms/op
                 executeQuery·p0.90:   54291.071 ms/op
                 executeQuery·p0.95:   54291.071 ms/op
                 executeQuery·p0.99:   54291.071 ms/op
                 executeQuery·p0.999:  54291.071 ms/op
                 executeQuery·p0.9999: 54291.071 ms/op
                 executeQuery·p1.00:   54291.071 ms/op

Iteration   3: 54827.942 ms/op
                 executeQuery·p0.00:   54827.942 ms/op
                 executeQuery·p0.50:   54827.942 ms/op
                 executeQuery·p0.90:   54827.942 ms/op
                 executeQuery·p0.95:   54827.942 ms/op
                 executeQuery·p0.99:   54827.942 ms/op
                 executeQuery·p0.999:  54827.942 ms/op
                 executeQuery·p0.9999: 54827.942 ms/op
                 executeQuery·p1.00:   54827.942 ms/op

Iteration   4: 54693.724 ms/op
                 executeQuery·p0.00:   54693.724 ms/op
                 executeQuery·p0.50:   54693.724 ms/op
                 executeQuery·p0.90:   54693.724 ms/op
                 executeQuery·p0.95:   54693.724 ms/op
                 executeQuery·p0.99:   54693.724 ms/op
                 executeQuery·p0.999:  54693.724 ms/op
                 executeQuery·p0.9999: 54693.724 ms/op
                 executeQuery·p1.00:   54693.724 ms/op

Iteration   5: 53687.091 ms/op
                 executeQuery·p0.00:   53687.091 ms/op
                 executeQuery·p0.50:   53687.091 ms/op
                 executeQuery·p0.90:   53687.091 ms/op
                 executeQuery·p0.95:   53687.091 ms/op
                 executeQuery·p0.99:   53687.091 ms/op
                 executeQuery·p0.999:  53687.091 ms/op
                 executeQuery·p0.9999: 53687.091 ms/op
                 executeQuery·p1.00:   53687.091 ms/op


# Run progress: 61.71% complete, ETA 08:08:44
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
private final class KeyMultiRecordMap_433423373 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_433423373() {
        this(4);
    }
    public KeyMultiRecordMap_433423373(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_433423373 join_map = new KeyMultiRecordMap_433423373();
private final class KeyMultiRecordMap_1188733428 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1188733428() {
        this(4);
    }
    public KeyMultiRecordMap_1188733428(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1188733428 join_map_0 = new KeyMultiRecordMap_1188733428();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int recordCount = table_A_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_A_vc_0.get(aviv);
        long left_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int ordinal_value_0 = table_A_vc_1.get(aviv);
        int ordinal_value_1 = table_A_vc_2.get(aviv);
        join_map_0.associate(ordinal_value, left_join_key_prehash, ordinal_value, ordinal_value_0, ordinal_value_1);
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int recordCount = table_B_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_B_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map_0.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_B_vc_1.get(aviv);
        int ordinal_value_1 = table_B_vc_2.get(aviv);
        int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
            long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
            join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, ordinal_value, ordinal_value_0, ordinal_value_1);
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int recordCount = table_C_vc_0.getValueCount();
    for (int aviv = 0; aviv < recordCount; aviv++) {
        int ordinal_value = table_C_vc_0.get(aviv);
        long right_join_key_prehash = Int_Hash_Function.preHash(ordinal_value);
        int records_to_join_index = join_map.getIndex(ordinal_value, right_join_key_prehash);
        if ((records_to_join_index == -1)) {
            continue;
        }
        int ordinal_value_0 = table_C_vc_1.get(aviv);
        int ordinal_value_1 = table_C_vc_2.get(aviv);
        int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
        for (int i = 0; i < left_join_record_count; i++) {
            int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
            int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
            int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
            int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
            int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
            int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
            count++;
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

57109.643 ms/op
# Warmup Iteration   2: 55566.139 ms/op
# Warmup Iteration   3: 55029.268 ms/op
# Warmup Iteration   4: 53619.982 ms/op
# Warmup Iteration   5: 54022.636 ms/op
Iteration   1: 54626.615 ms/op
                 executeQuery·p0.00:   54626.615 ms/op
                 executeQuery·p0.50:   54626.615 ms/op
                 executeQuery·p0.90:   54626.615 ms/op
                 executeQuery·p0.95:   54626.615 ms/op
                 executeQuery·p0.99:   54626.615 ms/op
                 executeQuery·p0.999:  54626.615 ms/op
                 executeQuery·p0.9999: 54626.615 ms/op
                 executeQuery·p1.00:   54626.615 ms/op

Iteration   2: 54425.289 ms/op
                 executeQuery·p0.00:   54425.289 ms/op
                 executeQuery·p0.50:   54425.289 ms/op
                 executeQuery·p0.90:   54425.289 ms/op
                 executeQuery·p0.95:   54425.289 ms/op
                 executeQuery·p0.99:   54425.289 ms/op
                 executeQuery·p0.999:  54425.289 ms/op
                 executeQuery·p0.9999: 54425.289 ms/op
                 executeQuery·p1.00:   54425.289 ms/op

Iteration   3: 54760.833 ms/op
                 executeQuery·p0.00:   54760.833 ms/op
                 executeQuery·p0.50:   54760.833 ms/op
                 executeQuery·p0.90:   54760.833 ms/op
                 executeQuery·p0.95:   54760.833 ms/op
                 executeQuery·p0.99:   54760.833 ms/op
                 executeQuery·p0.999:  54760.833 ms/op
                 executeQuery·p0.9999: 54760.833 ms/op
                 executeQuery·p1.00:   54760.833 ms/op

Iteration   4: 55297.704 ms/op
                 executeQuery·p0.00:   55297.704 ms/op
                 executeQuery·p0.50:   55297.704 ms/op
                 executeQuery·p0.90:   55297.704 ms/op
                 executeQuery·p0.95:   55297.704 ms/op
                 executeQuery·p0.99:   55297.704 ms/op
                 executeQuery·p0.999:  55297.704 ms/op
                 executeQuery·p0.9999: 55297.704 ms/op
                 executeQuery·p1.00:   55297.704 ms/op

Iteration   5: 53955.527 ms/op
                 executeQuery·p0.00:   53955.527 ms/op
                 executeQuery·p0.50:   53955.527 ms/op
                 executeQuery·p0.90:   53955.527 ms/op
                 executeQuery·p0.95:   53955.527 ms/op
                 executeQuery·p0.99:   53955.527 ms/op
                 executeQuery·p0.999:  53955.527 ms/op
                 executeQuery·p0.9999: 53955.527 ms/op
                 executeQuery·p1.00:   53955.527 ms/op



Result "benchmarks.join_query.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  54505.819 ±(99.9%) 689.457 ms/op

  Histogram, ms/op:
    [53000.000, 53250.000) = 0 
    [53250.000, 53500.000) = 0 
    [53500.000, 53750.000) = 1 
    [53750.000, 54000.000) = 1 
    [54000.000, 54250.000) = 0 
    [54250.000, 54500.000) = 3 
    [54500.000, 54750.000) = 2 
    [54750.000, 55000.000) = 2 
    [55000.000, 55250.000) = 0 
    [55250.000, 55500.000) = 1 
    [55500.000, 55750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  53687.091 ms/op
     p(50.0000) =  54559.506 ms/op
     p(90.0000) =  55250.728 ms/op
     p(95.0000) =  55297.704 ms/op
     p(99.0000) =  55297.704 ms/op
     p(99.9000) =  55297.704 ms/op
     p(99.9900) =  55297.704 ms/op
     p(99.9990) =  55297.704 ms/op
     p(99.9999) =  55297.704 ms/op
    p(100.0000) =  55297.704 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 62.03% complete, ETA 08:07:51
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_0 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_0 = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_1 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_1 = oCtx.getVectorSpeciesInt();
long count = 0;
private final class KeyMultiRecordMap_105746591 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_105746591() {
        this(4);
    }
    public KeyMultiRecordMap_105746591(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_105746591 join_map = new KeyMultiRecordMap_105746591();
private final class KeyMultiRecordMap_1680848641 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1680848641() {
        this(4);
    }
    public KeyMultiRecordMap_1680848641(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1680848641 join_map_0 = new KeyMultiRecordMap_1680848641();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int arrowVectorLength = table_A_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_A_vc_0.getDataBufferAddress(), (arrowVectorLength * table_A_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_A_vc_1.getDataBufferAddress(), (arrowVectorLength * table_A_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_A_vc_2.getDataBufferAddress(), (arrowVectorLength * table_A_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * table_A_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_A_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            join_map_0.associate(flattened_key, pre_hash_value, flattened_key, table_A_vc_1.get((currentVectorOffset + simd_vector_i)), table_A_vc_2.get((currentVectorOffset + simd_vector_i)));
        }
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int arrowVectorLength = table_B_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_B_vc_0.getDataBufferAddress(), (arrowVectorLength * table_B_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_B_vc_1.getDataBufferAddress(), (arrowVectorLength * table_B_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_B_vc_2.getDataBufferAddress(), (arrowVectorLength * table_B_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_0) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_0.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_0, col_0_ms, (currentVectorOffset * table_B_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_0; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_B_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map_0.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_B_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_B_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
                long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
                join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, flattened_key, right_join_ord_1, right_join_ord_2);
            }
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int arrowVectorLength = table_C_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_C_vc_0.getDataBufferAddress(), (arrowVectorLength * table_C_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_C_vc_1.getDataBufferAddress(), (arrowVectorLength * table_C_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_C_vc_2.getDataBufferAddress(), (arrowVectorLength * table_C_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_1) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_1.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_1, col_0_ms, (currentVectorOffset * table_C_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_1; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_C_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_C_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_C_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
                int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
                int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
                int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
                count++;
            }
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5662.310 ms/op
# Warmup Iteration   2: 5276.434 ms/op
# Warmup Iteration   3: 5200.937 ms/op
# Warmup Iteration   4: 5892.997 ms/op
# Warmup Iteration   5: 5335.155 ms/op
Iteration   1: 5297.406 ms/op
                 executeQuery·p0.00:   5251.269 ms/op
                 executeQuery·p0.50:   5297.406 ms/op
                 executeQuery·p0.90:   5343.543 ms/op
                 executeQuery·p0.95:   5343.543 ms/op
                 executeQuery·p0.99:   5343.543 ms/op
                 executeQuery·p0.999:  5343.543 ms/op
                 executeQuery·p0.9999: 5343.543 ms/op
                 executeQuery·p1.00:   5343.543 ms/op

Iteration   2: 5326.766 ms/op
                 executeQuery·p0.00:   5309.989 ms/op
                 executeQuery·p0.50:   5326.766 ms/op
                 executeQuery·p0.90:   5343.543 ms/op
                 executeQuery·p0.95:   5343.543 ms/op
                 executeQuery·p0.99:   5343.543 ms/op
                 executeQuery·p0.999:  5343.543 ms/op
                 executeQuery·p0.9999: 5343.543 ms/op
                 executeQuery·p1.00:   5343.543 ms/op

Iteration   3: 5305.795 ms/op
                 executeQuery·p0.00:   5293.212 ms/op
                 executeQuery·p0.50:   5305.795 ms/op
                 executeQuery·p0.90:   5318.377 ms/op
                 executeQuery·p0.95:   5318.377 ms/op
                 executeQuery·p0.99:   5318.377 ms/op
                 executeQuery·p0.999:  5318.377 ms/op
                 executeQuery·p0.9999: 5318.377 ms/op
                 executeQuery·p1.00:   5318.377 ms/op

Iteration   4: 5255.463 ms/op
                 executeQuery·p0.00:   5184.160 ms/op
                 executeQuery·p0.50:   5255.463 ms/op
                 executeQuery·p0.90:   5326.766 ms/op
                 executeQuery·p0.95:   5326.766 ms/op
                 executeQuery·p0.99:   5326.766 ms/op
                 executeQuery·p0.999:  5326.766 ms/op
                 executeQuery·p0.9999: 5326.766 ms/op
                 executeQuery·p1.00:   5326.766 ms/op

Iteration   5: 5284.823 ms/op
                 executeQuery·p0.00:   5184.160 ms/op
                 executeQuery·p0.50:   5284.823 ms/op
                 executeQuery·p0.90:   5385.486 ms/op
                 executeQuery·p0.95:   5385.486 ms/op
                 executeQuery·p0.99:   5385.486 ms/op
                 executeQuery·p0.999:  5385.486 ms/op
                 executeQuery·p0.9999: 5385.486 ms/op
                 executeQuery·p1.00:   5385.486 ms/op


# Run progress: 62.34% complete, ETA 08:02:26
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_0 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_0 = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_1 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_1 = oCtx.getVectorSpeciesInt();
long count = 0;
private final class KeyMultiRecordMap_1919527595 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1919527595() {
        this(4);
    }
    public KeyMultiRecordMap_1919527595(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1919527595 join_map = new KeyMultiRecordMap_1919527595();
private final class KeyMultiRecordMap_1771906161 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1771906161() {
        this(4);
    }
    public KeyMultiRecordMap_1771906161(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1771906161 join_map_0 = new KeyMultiRecordMap_1771906161();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int arrowVectorLength = table_A_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_A_vc_0.getDataBufferAddress(), (arrowVectorLength * table_A_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_A_vc_1.getDataBufferAddress(), (arrowVectorLength * table_A_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_A_vc_2.getDataBufferAddress(), (arrowVectorLength * table_A_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * table_A_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_A_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            join_map_0.associate(flattened_key, pre_hash_value, flattened_key, table_A_vc_1.get((currentVectorOffset + simd_vector_i)), table_A_vc_2.get((currentVectorOffset + simd_vector_i)));
        }
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int arrowVectorLength = table_B_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_B_vc_0.getDataBufferAddress(), (arrowVectorLength * table_B_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_B_vc_1.getDataBufferAddress(), (arrowVectorLength * table_B_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_B_vc_2.getDataBufferAddress(), (arrowVectorLength * table_B_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_0) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_0.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_0, col_0_ms, (currentVectorOffset * table_B_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_0; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_B_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map_0.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_B_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_B_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
                long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
                join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, flattened_key, right_join_ord_1, right_join_ord_2);
            }
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int arrowVectorLength = table_C_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_C_vc_0.getDataBufferAddress(), (arrowVectorLength * table_C_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_C_vc_1.getDataBufferAddress(), (arrowVectorLength * table_C_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_C_vc_2.getDataBufferAddress(), (arrowVectorLength * table_C_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_1) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_1.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_1, col_0_ms, (currentVectorOffset * table_C_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_1; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_C_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_C_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_C_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
                int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
                int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
                int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
                count++;
            }
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5679.088 ms/op
# Warmup Iteration   2: 5502.927 ms/op
# Warmup Iteration   3: 5309.989 ms/op
# Warmup Iteration   4: 5163.188 ms/op
# Warmup Iteration   5: 5117.051 ms/op
Iteration   1: 5209.326 ms/op
                 executeQuery·p0.00:   4982.833 ms/op
                 executeQuery·p0.50:   5209.326 ms/op
                 executeQuery·p0.90:   5435.818 ms/op
                 executeQuery·p0.95:   5435.818 ms/op
                 executeQuery·p0.99:   5435.818 ms/op
                 executeQuery·p0.999:  5435.818 ms/op
                 executeQuery·p0.9999: 5435.818 ms/op
                 executeQuery·p1.00:   5435.818 ms/op

Iteration   2: 5469.372 ms/op
                 executeQuery·p0.00:   5351.932 ms/op
                 executeQuery·p0.50:   5469.372 ms/op
                 executeQuery·p0.90:   5586.813 ms/op
                 executeQuery·p0.95:   5586.813 ms/op
                 executeQuery·p0.99:   5586.813 ms/op
                 executeQuery·p0.999:  5586.813 ms/op
                 executeQuery·p0.9999: 5586.813 ms/op
                 executeQuery·p1.00:   5586.813 ms/op

Iteration   3: 5490.344 ms/op
                 executeQuery·p0.00:   5469.372 ms/op
                 executeQuery·p0.50:   5490.344 ms/op
                 executeQuery·p0.90:   5511.315 ms/op
                 executeQuery·p0.95:   5511.315 ms/op
                 executeQuery·p0.99:   5511.315 ms/op
                 executeQuery·p0.999:  5511.315 ms/op
                 executeQuery·p0.9999: 5511.315 ms/op
                 executeQuery·p1.00:   5511.315 ms/op

Iteration   4: 5263.852 ms/op
                 executeQuery·p0.00:   5158.994 ms/op
                 executeQuery·p0.50:   5263.852 ms/op
                 executeQuery·p0.90:   5368.709 ms/op
                 executeQuery·p0.95:   5368.709 ms/op
                 executeQuery·p0.99:   5368.709 ms/op
                 executeQuery·p0.999:  5368.709 ms/op
                 executeQuery·p0.9999: 5368.709 ms/op
                 executeQuery·p1.00:   5368.709 ms/op

Iteration   5: 5314.183 ms/op
                 executeQuery·p0.00:   5209.326 ms/op
                 executeQuery·p0.50:   5314.183 ms/op
                 executeQuery·p0.90:   5419.041 ms/op
                 executeQuery·p0.95:   5419.041 ms/op
                 executeQuery·p0.99:   5419.041 ms/op
                 executeQuery·p0.999:  5419.041 ms/op
                 executeQuery·p0.9999: 5419.041 ms/op
                 executeQuery·p1.00:   5419.041 ms/op



Result "benchmarks.join_query.NonVectorisedSimd.executeQuery":
  N = 20
  mean =   5321.733 ±(99.9%) 118.930 ms/op

  Histogram, ms/op:
    [4900.000, 4950.000) = 0 
    [4950.000, 5000.000) = 1 
    [5000.000, 5050.000) = 0 
    [5050.000, 5100.000) = 0 
    [5100.000, 5150.000) = 0 
    [5150.000, 5200.000) = 3 
    [5200.000, 5250.000) = 1 
    [5250.000, 5300.000) = 2 
    [5300.000, 5350.000) = 5 
    [5350.000, 5400.000) = 3 
    [5400.000, 5450.000) = 2 
    [5450.000, 5500.000) = 1 
    [5500.000, 5550.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4982.833 ms/op
     p(50.0000) =   5335.155 ms/op
     p(90.0000) =   5507.121 ms/op
     p(95.0000) =   5583.038 ms/op
     p(99.0000) =   5586.813 ms/op
     p(99.9000) =   5586.813 ms/op
     p(99.9900) =   5586.813 ms/op
     p(99.9990) =   5586.813 ms/op
     p(99.9999) =   5586.813 ms/op
    p(100.0000) =   5586.813 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 62.66% complete, ETA 07:57:04
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_0 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_0 = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_1 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_1 = oCtx.getVectorSpeciesInt();
long count = 0;
private final class KeyMultiRecordMap_375646439 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_375646439() {
        this(4);
    }
    public KeyMultiRecordMap_375646439(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_375646439 join_map = new KeyMultiRecordMap_375646439();
private final class KeyMultiRecordMap_1432611477 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1432611477() {
        this(4);
    }
    public KeyMultiRecordMap_1432611477(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1432611477 join_map_0 = new KeyMultiRecordMap_1432611477();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int arrowVectorLength = table_A_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_A_vc_0.getDataBufferAddress(), (arrowVectorLength * table_A_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_A_vc_1.getDataBufferAddress(), (arrowVectorLength * table_A_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_A_vc_2.getDataBufferAddress(), (arrowVectorLength * table_A_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * table_A_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_A_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            join_map_0.associate(flattened_key, pre_hash_value, flattened_key, table_A_vc_1.get((currentVectorOffset + simd_vector_i)), table_A_vc_2.get((currentVectorOffset + simd_vector_i)));
        }
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int arrowVectorLength = table_B_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_B_vc_0.getDataBufferAddress(), (arrowVectorLength * table_B_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_B_vc_1.getDataBufferAddress(), (arrowVectorLength * table_B_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_B_vc_2.getDataBufferAddress(), (arrowVectorLength * table_B_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_0) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_0.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_0, col_0_ms, (currentVectorOffset * table_B_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_0; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_B_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map_0.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_B_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_B_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
                long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
                join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, flattened_key, right_join_ord_1, right_join_ord_2);
            }
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int arrowVectorLength = table_C_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_C_vc_0.getDataBufferAddress(), (arrowVectorLength * table_C_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_C_vc_1.getDataBufferAddress(), (arrowVectorLength * table_C_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_C_vc_2.getDataBufferAddress(), (arrowVectorLength * table_C_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_1) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_1.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_1, col_0_ms, (currentVectorOffset * table_C_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_1; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_C_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_C_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_C_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
                int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
                int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
                int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
                count++;
            }
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

62142.808 ms/op
# Warmup Iteration   2: 58518.929 ms/op
# Warmup Iteration   3: 56371.446 ms/op
# Warmup Iteration   4: 60800.631 ms/op
# Warmup Iteration   5: 59995.324 ms/op
Iteration   1: 60532.195 ms/op
                 executeQuery·p0.00:   60532.195 ms/op
                 executeQuery·p0.50:   60532.195 ms/op
                 executeQuery·p0.90:   60532.195 ms/op
                 executeQuery·p0.95:   60532.195 ms/op
                 executeQuery·p0.99:   60532.195 ms/op
                 executeQuery·p0.999:  60532.195 ms/op
                 executeQuery·p0.9999: 60532.195 ms/op
                 executeQuery·p1.00:   60532.195 ms/op

Iteration   2: 60867.740 ms/op
                 executeQuery·p0.00:   60867.740 ms/op
                 executeQuery·p0.50:   60867.740 ms/op
                 executeQuery·p0.90:   60867.740 ms/op
                 executeQuery·p0.95:   60867.740 ms/op
                 executeQuery·p0.99:   60867.740 ms/op
                 executeQuery·p0.999:  60867.740 ms/op
                 executeQuery·p0.9999: 60867.740 ms/op
                 executeQuery·p1.00:   60867.740 ms/op

Iteration   3: 60397.978 ms/op
                 executeQuery·p0.00:   60397.978 ms/op
                 executeQuery·p0.50:   60397.978 ms/op
                 executeQuery·p0.90:   60397.978 ms/op
                 executeQuery·p0.95:   60397.978 ms/op
                 executeQuery·p0.99:   60397.978 ms/op
                 executeQuery·p0.999:  60397.978 ms/op
                 executeQuery·p0.9999: 60397.978 ms/op
                 executeQuery·p1.00:   60397.978 ms/op

Iteration   4: 60666.413 ms/op
                 executeQuery·p0.00:   60666.413 ms/op
                 executeQuery·p0.50:   60666.413 ms/op
                 executeQuery·p0.90:   60666.413 ms/op
                 executeQuery·p0.95:   60666.413 ms/op
                 executeQuery·p0.99:   60666.413 ms/op
                 executeQuery·p0.999:  60666.413 ms/op
                 executeQuery·p0.9999: 60666.413 ms/op
                 executeQuery·p1.00:   60666.413 ms/op

Iteration   5: 60666.413 ms/op
                 executeQuery·p0.00:   60666.413 ms/op
                 executeQuery·p0.50:   60666.413 ms/op
                 executeQuery·p0.90:   60666.413 ms/op
                 executeQuery·p0.95:   60666.413 ms/op
                 executeQuery·p0.99:   60666.413 ms/op
                 executeQuery·p0.999:  60666.413 ms/op
                 executeQuery·p0.9999: 60666.413 ms/op
                 executeQuery·p1.00:   60666.413 ms/op


# Run progress: 62.97% complete, ETA 07:56:34
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
int commonSIMDVectorLength = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_0 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_0 = oCtx.getVectorSpeciesInt();
int commonSIMDVectorLength_1 = 8;
jdk.incubator.vector.VectorSpecies<Integer> IntVectorSpecies_1 = oCtx.getVectorSpeciesInt();
long count = 0;
private final class KeyMultiRecordMap_105746591 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_105746591() {
        this(4);
    }
    public KeyMultiRecordMap_105746591(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_105746591 join_map = new KeyMultiRecordMap_105746591();
private final class KeyMultiRecordMap_1680848641 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1680848641() {
        this(4);
    }
    public KeyMultiRecordMap_1680848641(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1680848641 join_map_0 = new KeyMultiRecordMap_1680848641();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    int arrowVectorLength = table_A_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_A_vc_0.getDataBufferAddress(), (arrowVectorLength * table_A_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_A_vc_1.getDataBufferAddress(), (arrowVectorLength * table_A_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_A_vc_2.getDataBufferAddress(), (arrowVectorLength * table_A_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies, col_0_ms, (currentVectorOffset * table_A_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_A_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            join_map_0.associate(flattened_key, pre_hash_value, flattened_key, table_A_vc_1.get((currentVectorOffset + simd_vector_i)), table_A_vc_2.get((currentVectorOffset + simd_vector_i)));
        }
    }
}
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    int arrowVectorLength = table_B_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_B_vc_0.getDataBufferAddress(), (arrowVectorLength * table_B_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_B_vc_1.getDataBufferAddress(), (arrowVectorLength * table_B_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_B_vc_2.getDataBufferAddress(), (arrowVectorLength * table_B_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_0) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_0.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_0, col_0_ms, (currentVectorOffset * table_B_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_0; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_B_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map_0.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_B_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_B_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map_0.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map_0.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map_0.values_record_ord_2[records_to_join_index][i];
                long left_join_key_prehash = Int_Hash_Function.preHash(left_join_ord_1);
                join_map.associate(left_join_ord_1, left_join_key_prehash, left_join_ord_0, left_join_ord_1, left_join_ord_2, flattened_key, right_join_ord_1, right_join_ord_2);
            }
        }
    }
}
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    int arrowVectorLength = table_C_vc_0.getValueCount();
    MemorySegment col_0_ms = oCtx.createMemorySegmentForAddress(table_C_vc_0.getDataBufferAddress(), (arrowVectorLength * table_C_vc_0.TYPE_WIDTH));
    MemorySegment col_1_ms = oCtx.createMemorySegmentForAddress(table_C_vc_1.getDataBufferAddress(), (arrowVectorLength * table_C_vc_1.TYPE_WIDTH));
    MemorySegment col_2_ms = oCtx.createMemorySegmentForAddress(table_C_vc_2.getDataBufferAddress(), (arrowVectorLength * table_C_vc_2.TYPE_WIDTH));
    for (int currentVectorOffset = 0; currentVectorOffset < arrowVectorLength; currentVectorOffset += commonSIMDVectorLength_1) {
        jdk.incubator.vector.VectorMask<Integer> inRangeSIMDMask = IntVectorSpecies_1.indexInRange(currentVectorOffset, arrowVectorLength);
        jdk.incubator.vector.IntVector SIMD_Key_Vector_Int = oCtx.createIntVector(IntVectorSpecies_1, col_0_ms, (currentVectorOffset * table_C_vc_0.TYPE_WIDTH), java.nio.ByteOrder.LITTLE_ENDIAN, inRangeSIMDMask);
        jdk.incubator.vector.LongVector SIMD_Key_Vector_Long = ((jdk.incubator.vector.LongVector) SIMD_Key_Vector_Int.castShape(oCtx.getVectorSpeciesLong(), 0));
        jdk.incubator.vector.LongVector SIMD_a_mul_key_vector = SIMD_Key_Vector_Long.mul(Int_Hash_Function.hashConstantA);
        jdk.incubator.vector.LongVector SIMD_a_mul_key_plus_b_vector = SIMD_a_mul_key_vector.add(Int_Hash_Function.hashConstantB);
        long[] pre_hash_values = SIMD_a_mul_key_plus_b_vector.toLongArray();
        for (int simd_vector_i = 0; simd_vector_i < commonSIMDVectorLength_1; simd_vector_i++) {
            if (!(inRangeSIMDMask.laneIsSet(simd_vector_i))) {
                continue;
            }
            int flattened_key = table_C_vc_0.get((currentVectorOffset + simd_vector_i));
            long pre_hash_value = (pre_hash_values[simd_vector_i] % Int_Hash_Function.hashConstantP);
            int records_to_join_index = join_map.getIndex(flattened_key, pre_hash_value);
            if ((records_to_join_index == -1)) {
                continue;
            }
            int right_join_ord_1 = table_C_vc_1.get((currentVectorOffset + simd_vector_i));
            int right_join_ord_2 = table_C_vc_2.get((currentVectorOffset + simd_vector_i));
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            for (int i = 0; i < left_join_record_count; i++) {
                int left_join_ord_0 = join_map.values_record_ord_0[records_to_join_index][i];
                int left_join_ord_1 = join_map.values_record_ord_1[records_to_join_index][i];
                int left_join_ord_2 = join_map.values_record_ord_2[records_to_join_index][i];
                int left_join_ord_3 = join_map.values_record_ord_3[records_to_join_index][i];
                int left_join_ord_4 = join_map.values_record_ord_4[records_to_join_index][i];
                int left_join_ord_5 = join_map.values_record_ord_5[records_to_join_index][i];
                count++;
            }
        }
    }
}
cCtx.getResultConsumptionTarget().consumeResultItem(count);

62344.135 ms/op
# Warmup Iteration   2: 59122.909 ms/op
# Warmup Iteration   3: 58116.276 ms/op
# Warmup Iteration   4: 59458.454 ms/op
# Warmup Iteration   5: 60330.869 ms/op
Iteration   1: 61605.937 ms/op
                 executeQuery·p0.00:   61605.937 ms/op
                 executeQuery·p0.50:   61605.937 ms/op
                 executeQuery·p0.90:   61605.937 ms/op
                 executeQuery·p0.95:   61605.937 ms/op
                 executeQuery·p0.99:   61605.937 ms/op
                 executeQuery·p0.999:  61605.937 ms/op
                 executeQuery·p0.9999: 61605.937 ms/op
                 executeQuery·p1.00:   61605.937 ms/op

Iteration   2: 60867.740 ms/op
                 executeQuery·p0.00:   60867.740 ms/op
                 executeQuery·p0.50:   60867.740 ms/op
                 executeQuery·p0.90:   60867.740 ms/op
                 executeQuery·p0.95:   60867.740 ms/op
                 executeQuery·p0.99:   60867.740 ms/op
                 executeQuery·p0.999:  60867.740 ms/op
                 executeQuery·p0.9999: 60867.740 ms/op
                 executeQuery·p1.00:   60867.740 ms/op

Iteration   3: 60733.522 ms/op
                 executeQuery·p0.00:   60733.522 ms/op
                 executeQuery·p0.50:   60733.522 ms/op
                 executeQuery·p0.90:   60733.522 ms/op
                 executeQuery·p0.95:   60733.522 ms/op
                 executeQuery·p0.99:   60733.522 ms/op
                 executeQuery·p0.999:  60733.522 ms/op
                 executeQuery·p0.9999: 60733.522 ms/op
                 executeQuery·p1.00:   60733.522 ms/op

Iteration   4: 61270.393 ms/op
                 executeQuery·p0.00:   61270.393 ms/op
                 executeQuery·p0.50:   61270.393 ms/op
                 executeQuery·p0.90:   61270.393 ms/op
                 executeQuery·p0.95:   61270.393 ms/op
                 executeQuery·p0.99:   61270.393 ms/op
                 executeQuery·p0.999:  61270.393 ms/op
                 executeQuery·p0.9999: 61270.393 ms/op
                 executeQuery·p1.00:   61270.393 ms/op

Iteration   5: 61941.481 ms/op
                 executeQuery·p0.00:   61941.481 ms/op
                 executeQuery·p0.50:   61941.481 ms/op
                 executeQuery·p0.90:   61941.481 ms/op
                 executeQuery·p0.95:   61941.481 ms/op
                 executeQuery·p0.99:   61941.481 ms/op
                 executeQuery·p0.999:  61941.481 ms/op
                 executeQuery·p0.9999: 61941.481 ms/op
                 executeQuery·p1.00:   61941.481 ms/op



Result "benchmarks.join_query.NonVectorisedSimd.executeQuery":
  N = 10
  mean =  60954.981 ±(99.9%) 750.233 ms/op

  Histogram, ms/op:
    [60000.000, 60125.000) = 0 
    [60125.000, 60250.000) = 0 
    [60250.000, 60375.000) = 0 
    [60375.000, 60500.000) = 1 
    [60500.000, 60625.000) = 1 
    [60625.000, 60750.000) = 3 
    [60750.000, 60875.000) = 2 
    [60875.000, 61000.000) = 0 
    [61000.000, 61125.000) = 0 
    [61125.000, 61250.000) = 0 
    [61250.000, 61375.000) = 1 
    [61375.000, 61500.000) = 0 
    [61500.000, 61625.000) = 1 
    [61625.000, 61750.000) = 0 
    [61750.000, 61875.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  60397.978 ms/op
     p(50.0000) =  60800.631 ms/op
     p(90.0000) =  61907.927 ms/op
     p(95.0000) =  61941.481 ms/op
     p(99.0000) =  61941.481 ms/op
     p(99.9000) =  61941.481 ms/op
     p(99.9900) =  61941.481 ms/op
     p(99.9990) =  61941.481 ms/op
     p(99.9999) =  61941.481 ms/op
    p(100.0000) =  61941.481 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 63.29% complete, ETA 07:56:01
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_375621621 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_375621621() {
        this(4);
    }
    public KeyMultiRecordMap_375621621(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_375621621 join_map = new KeyMultiRecordMap_375621621();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_1922603030 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1922603030() {
        this(4);
    }
    public KeyMultiRecordMap_1922603030(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1922603030 join_map_0 = new KeyMultiRecordMap_1922603030();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5037.359 ms/op
# Warmup Iteration   2: 4966.056 ±(99.9%) 667.083 ms/op
# Warmup Iteration   3: 5138.022 ms/op
# Warmup Iteration   4: 4943.686 ±(99.9%) 1870.173 ms/op
# Warmup Iteration   5: 4926.909 ±(99.9%) 2562.363 ms/op
Iteration   1: 5062.525 ms/op
                 executeQuery·p0.00:   4815.061 ms/op
                 executeQuery·p0.50:   5062.525 ms/op
                 executeQuery·p0.90:   5309.989 ms/op
                 executeQuery·p0.95:   5309.989 ms/op
                 executeQuery·p0.99:   5309.989 ms/op
                 executeQuery·p0.999:  5309.989 ms/op
                 executeQuery·p0.9999: 5309.989 ms/op
                 executeQuery·p1.00:   5309.989 ms/op

Iteration   2: 4893.355 ±(99.9%) 1851.292 ms/op
                 executeQuery·p0.00:   4815.061 ms/op
                 executeQuery·p0.50:   4857.004 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   3: 4929.705 ±(99.9%) 2566.930 ms/op
                 executeQuery·p0.00:   4840.227 ms/op
                 executeQuery·p0.50:   4857.004 ms/op
                 executeQuery·p0.90:   5091.885 ms/op
                 executeQuery·p0.95:   5091.885 ms/op
                 executeQuery·p0.99:   5091.885 ms/op
                 executeQuery·p0.999:  5091.885 ms/op
                 executeQuery·p0.9999: 5091.885 ms/op
                 executeQuery·p1.00:   5091.885 ms/op

Iteration   4: 4966.056 ±(99.9%) 852.088 ms/op
                 executeQuery·p0.00:   4915.724 ms/op
                 executeQuery·p0.50:   4974.445 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   5: 4904.539 ±(99.9%) 1509.851 ms/op
                 executeQuery·p0.00:   4848.615 ms/op
                 executeQuery·p0.50:   4865.393 ms/op
                 executeQuery·p0.90:   4999.610 ms/op
                 executeQuery·p0.95:   4999.610 ms/op
                 executeQuery·p0.99:   4999.610 ms/op
                 executeQuery·p0.999:  4999.610 ms/op
                 executeQuery·p0.9999: 4999.610 ms/op
                 executeQuery·p1.00:   4999.610 ms/op


# Run progress: 63.61% complete, ETA 07:50:52
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_375621621 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_375621621() {
        this(4);
    }
    public KeyMultiRecordMap_375621621(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_375621621 join_map = new KeyMultiRecordMap_375621621();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_1922603030 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1922603030() {
        this(4);
    }
    public KeyMultiRecordMap_1922603030(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1922603030 join_map_0 = new KeyMultiRecordMap_1922603030();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5003.805 ms/op
# Warmup Iteration   2: 5033.165 ms/op
# Warmup Iteration   3: 5096.079 ms/op
# Warmup Iteration   4: 5049.942 ms/op
# Warmup Iteration   5: 5003.805 ms/op
Iteration   1: 4876.577 ±(99.9%) 637.154 ms/op
                 executeQuery·p0.00:   4848.615 ms/op
                 executeQuery·p0.50:   4865.393 ms/op
                 executeQuery·p0.90:   4915.724 ms/op
                 executeQuery·p0.95:   4915.724 ms/op
                 executeQuery·p0.99:   4915.724 ms/op
                 executeQuery·p0.999:  4915.724 ms/op
                 executeQuery·p0.9999: 4915.724 ms/op
                 executeQuery·p1.00:   4915.724 ms/op

Iteration   2: 5112.857 ms/op
                 executeQuery·p0.00:   4991.222 ms/op
                 executeQuery·p0.50:   5112.857 ms/op
                 executeQuery·p0.90:   5234.491 ms/op
                 executeQuery·p0.95:   5234.491 ms/op
                 executeQuery·p0.99:   5234.491 ms/op
                 executeQuery·p0.999:  5234.491 ms/op
                 executeQuery·p0.9999: 5234.491 ms/op
                 executeQuery·p1.00:   5234.491 ms/op

Iteration   3: 4924.113 ±(99.9%) 1619.617 ms/op
                 executeQuery·p0.00:   4857.004 ms/op
                 executeQuery·p0.50:   4890.558 ms/op
                 executeQuery·p0.90:   5024.776 ms/op
                 executeQuery·p0.95:   5024.776 ms/op
                 executeQuery·p0.99:   5024.776 ms/op
                 executeQuery·p0.999:  5024.776 ms/op
                 executeQuery·p0.9999: 5024.776 ms/op
                 executeQuery·p1.00:   5024.776 ms/op

Iteration   4: 5003.805 ms/op
                 executeQuery·p0.00:   4940.890 ms/op
                 executeQuery·p0.50:   5003.805 ms/op
                 executeQuery·p0.90:   5066.719 ms/op
                 executeQuery·p0.95:   5066.719 ms/op
                 executeQuery·p0.99:   5066.719 ms/op
                 executeQuery·p0.999:  5066.719 ms/op
                 executeQuery·p0.9999: 5066.719 ms/op
                 executeQuery·p1.00:   5066.719 ms/op

Iteration   5: 4907.336 ±(99.9%) 1724.667 ms/op
                 executeQuery·p0.00:   4848.615 ms/op
                 executeQuery·p0.50:   4857.004 ms/op
                 executeQuery·p0.90:   5016.388 ms/op
                 executeQuery·p0.95:   5016.388 ms/op
                 executeQuery·p0.99:   5016.388 ms/op
                 executeQuery·p0.999:  5016.388 ms/op
                 executeQuery·p0.9999: 5016.388 ms/op
                 executeQuery·p1.00:   5016.388 ms/op



Result "benchmarks.join_query.VectorisedNonSimd.executeQuery":
  N = 27
  mean =   4946.793 ±(99.9%) 88.442 ms/op

  Histogram, ms/op:
    [4800.000, 4850.000) = 6 
    [4850.000, 4900.000) = 7 
    [4900.000, 4950.000) = 3 
    [4950.000, 5000.000) = 3 
    [5000.000, 5050.000) = 4 
    [5050.000, 5100.000) = 2 
    [5100.000, 5150.000) = 0 
    [5150.000, 5200.000) = 0 
    [5200.000, 5250.000) = 1 
    [5250.000, 5300.000) = 0 
    [5300.000, 5350.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4815.061 ms/op
     p(50.0000) =   4915.724 ms/op
     p(90.0000) =   5120.406 ms/op
     p(95.0000) =   5279.790 ms/op
     p(99.0000) =   5309.989 ms/op
     p(99.9000) =   5309.989 ms/op
     p(99.9900) =   5309.989 ms/op
     p(99.9990) =   5309.989 ms/op
     p(99.9999) =   5309.989 ms/op
    p(100.0000) =   5309.989 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 63.92% complete, ETA 07:45:34
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_375621621 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_375621621() {
        this(4);
    }
    public KeyMultiRecordMap_375621621(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_375621621 join_map = new KeyMultiRecordMap_375621621();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_1922603030 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1922603030() {
        this(4);
    }
    public KeyMultiRecordMap_1922603030(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1922603030 join_map_0 = new KeyMultiRecordMap_1922603030();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

57512.296 ms/op
# Warmup Iteration   2: 54626.615 ms/op
# Warmup Iteration   3: 55029.268 ms/op
# Warmup Iteration   4: 53150.220 ms/op
# Warmup Iteration   5: 56438.555 ms/op
Iteration   1: 56035.901 ms/op
                 executeQuery·p0.00:   56035.901 ms/op
                 executeQuery·p0.50:   56035.901 ms/op
                 executeQuery·p0.90:   56035.901 ms/op
                 executeQuery·p0.95:   56035.901 ms/op
                 executeQuery·p0.99:   56035.901 ms/op
                 executeQuery·p0.999:  56035.901 ms/op
                 executeQuery·p0.9999: 56035.901 ms/op
                 executeQuery·p1.00:   56035.901 ms/op

Iteration   2: 56304.337 ms/op
                 executeQuery·p0.00:   56304.337 ms/op
                 executeQuery·p0.50:   56304.337 ms/op
                 executeQuery·p0.90:   56304.337 ms/op
                 executeQuery·p0.95:   56304.337 ms/op
                 executeQuery·p0.99:   56304.337 ms/op
                 executeQuery·p0.999:  56304.337 ms/op
                 executeQuery·p0.9999: 56304.337 ms/op
                 executeQuery·p1.00:   56304.337 ms/op

Iteration   3: 55767.466 ms/op
                 executeQuery·p0.00:   55767.466 ms/op
                 executeQuery·p0.50:   55767.466 ms/op
                 executeQuery·p0.90:   55767.466 ms/op
                 executeQuery·p0.95:   55767.466 ms/op
                 executeQuery·p0.99:   55767.466 ms/op
                 executeQuery·p0.999:  55767.466 ms/op
                 executeQuery·p0.9999: 55767.466 ms/op
                 executeQuery·p1.00:   55767.466 ms/op

Iteration   4: 55499.031 ms/op
                 executeQuery·p0.00:   55499.031 ms/op
                 executeQuery·p0.50:   55499.031 ms/op
                 executeQuery·p0.90:   55499.031 ms/op
                 executeQuery·p0.95:   55499.031 ms/op
                 executeQuery·p0.99:   55499.031 ms/op
                 executeQuery·p0.999:  55499.031 ms/op
                 executeQuery·p0.9999: 55499.031 ms/op
                 executeQuery·p1.00:   55499.031 ms/op

Iteration   5: 56035.901 ms/op
                 executeQuery·p0.00:   56035.901 ms/op
                 executeQuery·p0.50:   56035.901 ms/op
                 executeQuery·p0.90:   56035.901 ms/op
                 executeQuery·p0.95:   56035.901 ms/op
                 executeQuery·p0.99:   56035.901 ms/op
                 executeQuery·p0.999:  56035.901 ms/op
                 executeQuery·p0.9999: 56035.901 ms/op
                 executeQuery·p1.00:   56035.901 ms/op


# Run progress: 64.24% complete, ETA 07:44:24
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_375621621 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_375621621() {
        this(4);
    }
    public KeyMultiRecordMap_375621621(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_375621621 join_map = new KeyMultiRecordMap_375621621();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_1922603030 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1922603030() {
        this(4);
    }
    public KeyMultiRecordMap_1922603030(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1922603030 join_map_0 = new KeyMultiRecordMap_1922603030();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVector(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

57512.296 ms/op
# Warmup Iteration   2: 54156.853 ms/op
# Warmup Iteration   3: 54223.962 ms/op
# Warmup Iteration   4: 53955.527 ms/op
# Warmup Iteration   5: 55968.793 ms/op
Iteration   1: 55834.575 ms/op
                 executeQuery·p0.00:   55834.575 ms/op
                 executeQuery·p0.50:   55834.575 ms/op
                 executeQuery·p0.90:   55834.575 ms/op
                 executeQuery·p0.95:   55834.575 ms/op
                 executeQuery·p0.99:   55834.575 ms/op
                 executeQuery·p0.999:  55834.575 ms/op
                 executeQuery·p0.9999: 55834.575 ms/op
                 executeQuery·p1.00:   55834.575 ms/op

Iteration   2: 57378.079 ms/op
                 executeQuery·p0.00:   57378.079 ms/op
                 executeQuery·p0.50:   57378.079 ms/op
                 executeQuery·p0.90:   57378.079 ms/op
                 executeQuery·p0.95:   57378.079 ms/op
                 executeQuery·p0.99:   57378.079 ms/op
                 executeQuery·p0.999:  57378.079 ms/op
                 executeQuery·p0.9999: 57378.079 ms/op
                 executeQuery·p1.00:   57378.079 ms/op

Iteration   3: 55968.793 ms/op
                 executeQuery·p0.00:   55968.793 ms/op
                 executeQuery·p0.50:   55968.793 ms/op
                 executeQuery·p0.90:   55968.793 ms/op
                 executeQuery·p0.95:   55968.793 ms/op
                 executeQuery·p0.99:   55968.793 ms/op
                 executeQuery·p0.999:  55968.793 ms/op
                 executeQuery·p0.9999: 55968.793 ms/op
                 executeQuery·p1.00:   55968.793 ms/op

Iteration   4: 56304.337 ms/op
                 executeQuery·p0.00:   56304.337 ms/op
                 executeQuery·p0.50:   56304.337 ms/op
                 executeQuery·p0.90:   56304.337 ms/op
                 executeQuery·p0.95:   56304.337 ms/op
                 executeQuery·p0.99:   56304.337 ms/op
                 executeQuery·p0.999:  56304.337 ms/op
                 executeQuery·p0.9999: 56304.337 ms/op
                 executeQuery·p1.00:   56304.337 ms/op

Iteration   5: 56304.337 ms/op
                 executeQuery·p0.00:   56304.337 ms/op
                 executeQuery·p0.50:   56304.337 ms/op
                 executeQuery·p0.90:   56304.337 ms/op
                 executeQuery·p0.95:   56304.337 ms/op
                 executeQuery·p0.99:   56304.337 ms/op
                 executeQuery·p0.999:  56304.337 ms/op
                 executeQuery·p0.9999: 56304.337 ms/op
                 executeQuery·p1.00:   56304.337 ms/op



Result "benchmarks.join_query.VectorisedNonSimd.executeQuery":
  N = 10
  mean =  56143.276 ±(99.9%) 765.551 ms/op

  Histogram, ms/op:
    [55000.000, 55250.000) = 0 
    [55250.000, 55500.000) = 1 
    [55500.000, 55750.000) = 0 
    [55750.000, 56000.000) = 3 
    [56000.000, 56250.000) = 2 
    [56250.000, 56500.000) = 3 
    [56500.000, 56750.000) = 0 
    [56750.000, 57000.000) = 0 
    [57000.000, 57250.000) = 0 
    [57250.000, 57500.000) = 1 
    [57500.000, 57750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  55499.031 ms/op
     p(50.0000) =  56035.901 ms/op
     p(90.0000) =  57270.705 ms/op
     p(95.0000) =  57378.079 ms/op
     p(99.0000) =  57378.079 ms/op
     p(99.9000) =  57378.079 ms/op
     p(99.9900) =  57378.079 ms/op
     p(99.9990) =  57378.079 ms/op
     p(99.9999) =  57378.079 ms/op
    p(100.0000) =  57378.079 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 64.56% complete, ETA 07:43:10
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_1321478024 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1321478024() {
        this(4);
    }
    public KeyMultiRecordMap_1321478024(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1321478024 join_map = new KeyMultiRecordMap_1321478024();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_462752491 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_462752491() {
        this(4);
    }
    public KeyMultiRecordMap_462752491(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_462752491 join_map_0 = new KeyMultiRecordMap_462752491();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5104.468 ms/op
# Warmup Iteration   2: 5054.136 ms/op
# Warmup Iteration   3: 5005.203 ±(99.9%) 4672.927 ms/op
# Warmup Iteration   4: 4837.431 ±(99.9%) 3062.064 ms/op
# Warmup Iteration   5: 4907.336 ±(99.9%) 153.039 ms/op
Iteration   1: 5196.743 ms/op
                 executeQuery·p0.00:   5133.828 ms/op
                 executeQuery·p0.50:   5196.743 ms/op
                 executeQuery·p0.90:   5259.657 ms/op
                 executeQuery·p0.95:   5259.657 ms/op
                 executeQuery·p0.99:   5259.657 ms/op
                 executeQuery·p0.999:  5259.657 ms/op
                 executeQuery·p0.9999: 5259.657 ms/op
                 executeQuery·p1.00:   5259.657 ms/op

Iteration   2: 5028.970 ms/op
                 executeQuery·p0.00:   4806.672 ms/op
                 executeQuery·p0.50:   5028.970 ms/op
                 executeQuery·p0.90:   5251.269 ms/op
                 executeQuery·p0.95:   5251.269 ms/op
                 executeQuery·p0.99:   5251.269 ms/op
                 executeQuery·p0.999:  5251.269 ms/op
                 executeQuery·p0.9999: 5251.269 ms/op
                 executeQuery·p1.00:   5251.269 ms/op

Iteration   3: 5041.553 ms/op
                 executeQuery·p0.00:   4999.610 ms/op
                 executeQuery·p0.50:   5041.553 ms/op
                 executeQuery·p0.90:   5083.496 ms/op
                 executeQuery·p0.95:   5083.496 ms/op
                 executeQuery·p0.99:   5083.496 ms/op
                 executeQuery·p0.999:  5083.496 ms/op
                 executeQuery·p0.9999: 5083.496 ms/op
                 executeQuery·p1.00:   5083.496 ms/op

Iteration   4: 4915.724 ±(99.9%) 1553.181 ms/op
                 executeQuery·p0.00:   4840.227 ms/op
                 executeQuery·p0.50:   4898.947 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   5: 4949.279 ±(99.9%) 1619.617 ms/op
                 executeQuery·p0.00:   4882.170 ms/op
                 executeQuery·p0.50:   4915.724 ms/op
                 executeQuery·p0.90:   5049.942 ms/op
                 executeQuery·p0.95:   5049.942 ms/op
                 executeQuery·p0.99:   5049.942 ms/op
                 executeQuery·p0.999:  5049.942 ms/op
                 executeQuery·p0.9999: 5049.942 ms/op
                 executeQuery·p1.00:   5049.942 ms/op


# Run progress: 64.87% complete, ETA 07:37:56
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_1321478024 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1321478024() {
        this(4);
    }
    public KeyMultiRecordMap_1321478024(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1321478024 join_map = new KeyMultiRecordMap_1321478024();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_462752491 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_462752491() {
        this(4);
    }
    public KeyMultiRecordMap_462752491(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_462752491 join_map_0 = new KeyMultiRecordMap_462752491();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

5079.302 ms/op
# Warmup Iteration   2: 4974.445 ±(99.9%) 530.144 ms/op
# Warmup Iteration   3: 5054.136 ms/op
# Warmup Iteration   4: 5028.970 ms/op
# Warmup Iteration   5: 4926.909 ±(99.9%) 1337.089 ms/op
Iteration   1: 5142.217 ms/op
                 executeQuery·p0.00:   4982.833 ms/op
                 executeQuery·p0.50:   5142.217 ms/op
                 executeQuery·p0.90:   5301.600 ms/op
                 executeQuery·p0.95:   5301.600 ms/op
                 executeQuery·p0.99:   5301.600 ms/op
                 executeQuery·p0.999:  5301.600 ms/op
                 executeQuery·p0.9999: 5301.600 ms/op
                 executeQuery·p1.00:   5301.600 ms/op

Iteration   2: 4924.113 ±(99.9%) 1402.630 ms/op
                 executeQuery·p0.00:   4857.004 ms/op
                 executeQuery·p0.50:   4907.336 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   3: 4954.871 ±(99.9%) 1337.089 ms/op
                 executeQuery·p0.00:   4873.781 ms/op
                 executeQuery·p0.50:   4974.445 ms/op
                 executeQuery·p0.90:   5016.388 ms/op
                 executeQuery·p0.95:   5016.388 ms/op
                 executeQuery·p0.99:   5016.388 ms/op
                 executeQuery·p0.999:  5016.388 ms/op
                 executeQuery·p0.9999: 5016.388 ms/op
                 executeQuery·p1.00:   5016.388 ms/op

Iteration   4: 4924.113 ±(99.9%) 2001.250 ms/op
                 executeQuery·p0.00:   4848.615 ms/op
                 executeQuery·p0.50:   4873.781 ms/op
                 executeQuery·p0.90:   5049.942 ms/op
                 executeQuery·p0.95:   5049.942 ms/op
                 executeQuery·p0.99:   5049.942 ms/op
                 executeQuery·p0.999:  5049.942 ms/op
                 executeQuery·p0.9999: 5049.942 ms/op
                 executeQuery·p1.00:   5049.942 ms/op

Iteration   5: 4952.075 ±(99.9%) 1773.762 ms/op
                 executeQuery·p0.00:   4840.227 ms/op
                 executeQuery·p0.50:   4999.610 ms/op
                 executeQuery·p0.90:   5016.388 ms/op
                 executeQuery·p0.95:   5016.388 ms/op
                 executeQuery·p0.99:   5016.388 ms/op
                 executeQuery·p0.999:  5016.388 ms/op
                 executeQuery·p0.9999: 5016.388 ms/op
                 executeQuery·p1.00:   5016.388 ms/op



Result "benchmarks.join_query.VectorisedSimd.executeQuery":
  N = 26
  mean =   4987.673 ±(99.9%) 98.286 ms/op

  Histogram, ms/op:
    [4800.000, 4850.000) = 4 
    [4850.000, 4900.000) = 5 
    [4900.000, 4950.000) = 2 
    [4950.000, 5000.000) = 4 
    [5000.000, 5050.000) = 6 
    [5050.000, 5100.000) = 1 
    [5100.000, 5150.000) = 1 
    [5150.000, 5200.000) = 0 
    [5200.000, 5250.000) = 0 
    [5250.000, 5300.000) = 2 
    [5300.000, 5350.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4806.672 ms/op
     p(50.0000) =   4991.222 ms/op
     p(90.0000) =   5253.785 ms/op
     p(95.0000) =   5286.920 ms/op
     p(99.0000) =   5301.600 ms/op
     p(99.9000) =   5301.600 ms/op
     p(99.9900) =   5301.600 ms/op
     p(99.9990) =   5301.600 ms/op
     p(99.9999) =   5301.600 ms/op
    p(100.0000) =   5301.600 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 65.19% complete, ETA 07:32:47
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_794399046 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_794399046() {
        this(4);
    }
    public KeyMultiRecordMap_794399046(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_794399046 join_map = new KeyMultiRecordMap_794399046();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_856132547 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_856132547() {
        this(4);
    }
    public KeyMultiRecordMap_856132547(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_856132547 join_map_0 = new KeyMultiRecordMap_856132547();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

57646.514 ms/op
# Warmup Iteration   2: 53821.309 ms/op
# Warmup Iteration   3: 55633.248 ms/op
# Warmup Iteration   4: 55901.684 ms/op
# Warmup Iteration   5: 56304.337 ms/op
Iteration   1: 56774.099 ms/op
                 executeQuery·p0.00:   56774.099 ms/op
                 executeQuery·p0.50:   56774.099 ms/op
                 executeQuery·p0.90:   56774.099 ms/op
                 executeQuery·p0.95:   56774.099 ms/op
                 executeQuery·p0.99:   56774.099 ms/op
                 executeQuery·p0.999:  56774.099 ms/op
                 executeQuery·p0.9999: 56774.099 ms/op
                 executeQuery·p1.00:   56774.099 ms/op

Iteration   2: 56170.119 ms/op
                 executeQuery·p0.00:   56170.119 ms/op
                 executeQuery·p0.50:   56170.119 ms/op
                 executeQuery·p0.90:   56170.119 ms/op
                 executeQuery·p0.95:   56170.119 ms/op
                 executeQuery·p0.99:   56170.119 ms/op
                 executeQuery·p0.999:  56170.119 ms/op
                 executeQuery·p0.9999: 56170.119 ms/op
                 executeQuery·p1.00:   56170.119 ms/op

Iteration   3: 57042.534 ms/op
                 executeQuery·p0.00:   57042.534 ms/op
                 executeQuery·p0.50:   57042.534 ms/op
                 executeQuery·p0.90:   57042.534 ms/op
                 executeQuery·p0.95:   57042.534 ms/op
                 executeQuery·p0.99:   57042.534 ms/op
                 executeQuery·p0.999:  57042.534 ms/op
                 executeQuery·p0.9999: 57042.534 ms/op
                 executeQuery·p1.00:   57042.534 ms/op

Iteration   4: 56170.119 ms/op
                 executeQuery·p0.00:   56170.119 ms/op
                 executeQuery·p0.50:   56170.119 ms/op
                 executeQuery·p0.90:   56170.119 ms/op
                 executeQuery·p0.95:   56170.119 ms/op
                 executeQuery·p0.99:   56170.119 ms/op
                 executeQuery·p0.999:  56170.119 ms/op
                 executeQuery·p0.9999: 56170.119 ms/op
                 executeQuery·p1.00:   56170.119 ms/op

Iteration   5: 55968.793 ms/op
                 executeQuery·p0.00:   55968.793 ms/op
                 executeQuery·p0.50:   55968.793 ms/op
                 executeQuery·p0.90:   55968.793 ms/op
                 executeQuery·p0.95:   55968.793 ms/op
                 executeQuery·p0.99:   55968.793 ms/op
                 executeQuery·p0.999:  55968.793 ms/op
                 executeQuery·p0.9999: 55968.793 ms/op
                 executeQuery·p1.00:   55968.793 ms/op


# Run progress: 65.51% complete, ETA 07:31:27
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: Generating query code ...
Arrow reader 0 projects columns  [0, 1, 2]
Arrow reader 1 projects columns  [0, 1, 2]
Arrow reader 2 projects columns  [0, 1, 2]
Finished query code!

[Generated query code]
long count = 0;
long[] pre_hash_vector = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_1321478024 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    public int[][] values_record_ord_3;
    public int[][] values_record_ord_4;
    public int[][] values_record_ord_5;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_1321478024() {
        this(4);
    }
    public KeyMultiRecordMap_1321478024(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.values_record_ord_3 = new int[capacity][8];
        this.values_record_ord_4 = new int[capacity][8];
        this.values_record_ord_5 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2, int record_ord_3, int record_ord_4, int record_ord_5) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
            int[] temp_values_record_ord_3 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_3[index], 0, temp_values_record_ord_3, 0, currentValueArraysSize);
            this.values_record_ord_3[index] = temp_values_record_ord_3;
            int[] temp_values_record_ord_4 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_4[index], 0, temp_values_record_ord_4, 0, currentValueArraysSize);
            this.values_record_ord_4[index] = temp_values_record_ord_4;
            int[] temp_values_record_ord_5 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_5[index], 0, temp_values_record_ord_5, 0, currentValueArraysSize);
            this.values_record_ord_5[index] = temp_values_record_ord_5;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.values_record_ord_3[index][insertionIndex] = record_ord_3;
        this.values_record_ord_4[index][insertionIndex] = record_ord_4;
        this.values_record_ord_5[index][insertionIndex] = record_ord_5;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
        int[][] new_values_record_ord_3 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_3, 0, new_values_record_ord_3, 0, currentSize);
        this.values_record_ord_3 = new_values_record_ord_3;
        int[][] new_values_record_ord_4 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_4, 0, new_values_record_ord_4, 0, currentSize);
        this.values_record_ord_4 = new_values_record_ord_4;
        int[][] new_values_record_ord_5 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_5, 0, new_values_record_ord_5, 0, currentSize);
        this.values_record_ord_5 = new_values_record_ord_5;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_1321478024 join_map = new KeyMultiRecordMap_1321478024();
long[] pre_hash_vector_0 = cCtx.getAllocationManager().getLongVector();
private final class KeyMultiRecordMap_462752491 {
    private int numberOfRecords;
    private int[] keys;
    public int[] keysRecordCount;
    public int[][] values_record_ord_0;
    public int[][] values_record_ord_1;
    public int[][] values_record_ord_2;
    private int[] hashTable;
    private int[] next;

    public KeyMultiRecordMap_462752491() {
        this(4);
    }
    public KeyMultiRecordMap_462752491(int capacity) {
        if (!(((capacity > 1) && ((capacity & (capacity - 1)) == 0)))) {
            throw new java.lang.IllegalArgumentException("The map capacity is required to be a power of two");
        }
        this.numberOfRecords = 0;
        this.keys = new int[capacity];
        Arrays.fill(this.keys, -1);
        this.keysRecordCount = new int[capacity];
        this.values_record_ord_0 = new int[capacity][8];
        this.values_record_ord_1 = new int[capacity][8];
        this.values_record_ord_2 = new int[capacity][8];
        this.hashTable = new int[capacity];
        Arrays.fill(this.hashTable, -1);
        this.next = new int[capacity];
        Arrays.fill(this.next, -1);
    }

    public void associate(int key, long preHash, int record_ord_0, int record_ord_1, int record_ord_2) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        int index = this.find(key, preHash);
        boolean newEntry = false;
        if ((index == -1)) {
            newEntry = true;
            index = this.numberOfRecords++;
            if ((this.keys.length == index)) {
                this.growArrays();
            }
            this.keys[index] = key;
        }
        int insertionIndex = this.keysRecordCount[index];
        if (!((insertionIndex < this.values_record_ord_0[index].length))) {
            int currentValueArraysSize = this.values_record_ord_0[index].length;
            int newValueArraysSize = (2 * currentValueArraysSize);
            int[] temp_values_record_ord_0 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_0[index], 0, temp_values_record_ord_0, 0, currentValueArraysSize);
            this.values_record_ord_0[index] = temp_values_record_ord_0;
            int[] temp_values_record_ord_1 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_1[index], 0, temp_values_record_ord_1, 0, currentValueArraysSize);
            this.values_record_ord_1[index] = temp_values_record_ord_1;
            int[] temp_values_record_ord_2 = new int[newValueArraysSize];
            System.arraycopy(this.values_record_ord_2[index], 0, temp_values_record_ord_2, 0, currentValueArraysSize);
            this.values_record_ord_2[index] = temp_values_record_ord_2;
        }
        this.values_record_ord_0[index][insertionIndex] = record_ord_0;
        this.values_record_ord_1[index][insertionIndex] = record_ord_1;
        this.values_record_ord_2[index][insertionIndex] = record_ord_2;
        this.keysRecordCount[index]++;
        if (newEntry) {
            boolean rehashOnCollision = (this.numberOfRecords > ((3 * this.hashTable.length) / 4));
            this.putHashEntry(key, preHash, index, rehashOnCollision);
        }
    }
    private int find(int key, long preHash) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            return -1;
        }
        int currentIndex = initialIndex;
        while ((this.keys[currentIndex] != key)) {
            int potentialNextIndex = this.next[currentIndex];
            if ((potentialNextIndex == -1)) {
                return -1;
            } else {
                currentIndex = potentialNextIndex;
            }
        }
        return currentIndex;
    }
    private void growArrays() {
        int currentSize = this.keys.length;
        int newSize = (currentSize << 1);
        if ((newSize > (Integer.MAX_VALUE - 1))) {
            throw new java.lang.UnsupportedOperationException("Map has grown too large");
        }
        int[] newKeys = new int[newSize];
        System.arraycopy(this.keys, 0, newKeys, 0, currentSize);
        Arrays.fill(newKeys, currentSize, newSize, -1);
        this.keys = newKeys;
        int[] newKeysRecordCount = new int[newSize];
        System.arraycopy(this.keysRecordCount, 0, newKeysRecordCount, 0, currentSize);
        this.keysRecordCount = newKeysRecordCount;
        int[] newNext = new int[newSize];
        System.arraycopy(this.next, 0, newNext, 0, currentSize);
        Arrays.fill(newNext, currentSize, newSize, -1);
        this.next = newNext;
        int[][] new_values_record_ord_0 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_0, 0, new_values_record_ord_0, 0, currentSize);
        this.values_record_ord_0 = new_values_record_ord_0;
        int[][] new_values_record_ord_1 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_1, 0, new_values_record_ord_1, 0, currentSize);
        this.values_record_ord_1 = new_values_record_ord_1;
        int[][] new_values_record_ord_2 = new int[newSize][8];
        System.arraycopy(this.values_record_ord_2, 0, new_values_record_ord_2, 0, currentSize);
        this.values_record_ord_2 = new_values_record_ord_2;
    }
    private void putHashEntry(int key, long preHash, int index, boolean rehashOnCollision) {
        int htIndex = ((int) (preHash & (this.hashTable.length - 1)));
        int initialIndex = this.hashTable[htIndex];
        if ((initialIndex == -1)) {
            this.hashTable[htIndex] = index;
            return;
        }
        if (rehashOnCollision) {
            this.rehash();
            return;
        }
        int currentIndex = initialIndex;
        while (((this.keys[currentIndex] != key) && (this.next[currentIndex] != -1))) {
            currentIndex = this.next[currentIndex];
        }
        this.next[currentIndex] = index;
    }
    private void rehash() {
        int size = this.hashTable.length;
        while ((size <= this.numberOfRecords)) {
            size = (size << 1);
        }
        size = (size << 1);
        this.hashTable = new int[size];
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
        for (int i = 0; i < this.numberOfRecords; i++) {
            int key = this.keys[i];
            long preHash = Int_Hash_Function.preHash(key);
            this.putHashEntry(key, preHash, i, false);
        }
    }
    public int getIndex(int key, long preHash) {
        if ((key < 0)) {
            throw new java.lang.IllegalArgumentException("The map expects non-negative keys");
        }
        return this.find(key, preHash);
    }
    public void reset() {
        this.numberOfRecords = 0;
        Arrays.fill(this.keys, -1);
        Arrays.fill(this.keysRecordCount, 0);
        Arrays.fill(this.hashTable, -1);
        Arrays.fill(this.next, -1);
    }
}

KeyMultiRecordMap_462752491 join_map_0 = new KeyMultiRecordMap_462752491();
ArrowTableReader table_A = cCtx.getArrowReader(0);
while (table_A.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_A_vc_0 = ((org.apache.arrow.vector.IntVector) table_A.getVector(0));
    org.apache.arrow.vector.IntVector table_A_vc_1 = ((org.apache.arrow.vector.IntVector) table_A.getVector(1));
    org.apache.arrow.vector.IntVector table_A_vc_2 = ((org.apache.arrow.vector.IntVector) table_A.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_A_vc_0, false);
    int recordCount = table_A_vc_0.getValueCount();
    for (int i = 0; i < recordCount; i++) {
        int left_join_record_key = table_A_vc_0.get(i);
        join_map_0.associate(left_join_record_key, pre_hash_vector_0[i], left_join_record_key, table_A_vc_1.get(i), table_A_vc_2.get(i));
    }
}
int[] join_result_vector_ord_0_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5_0 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_B = cCtx.getArrowReader(1);
while (table_B.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_B_vc_0 = ((org.apache.arrow.vector.IntVector) table_B.getVector(0));
    org.apache.arrow.vector.IntVector table_B_vc_1 = ((org.apache.arrow.vector.IntVector) table_B.getVector(1));
    org.apache.arrow.vector.IntVector table_B_vc_2 = ((org.apache.arrow.vector.IntVector) table_B.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector_0, table_B_vc_0, false);
    int recordCount = table_B_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_B_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector_0[currentLoopIndex];
            int records_to_join_index = join_map_0.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map_0.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_B_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_B_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0_0[currentResultIndex] = join_map_0.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1_0[currentResultIndex] = join_map_0.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2_0[currentResultIndex] = join_map_0.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3_0[currentResultIndex] = right_join_key;
                join_result_vector_ord_4_0[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_5_0[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, join_result_vector_ord_1_0, currentResultIndex, false);
        for (int i_0 = 0; i_0 < currentResultIndex; i_0++) {
            int left_join_record_key = join_result_vector_ord_1_0[i_0];
            join_map.associate(left_join_record_key, pre_hash_vector[i_0], join_result_vector_ord_0_0[i_0], left_join_record_key, join_result_vector_ord_2_0[i_0], join_result_vector_ord_3_0[i_0], join_result_vector_ord_4_0[i_0], join_result_vector_ord_5_0[i_0]);
        }
    }
}
cCtx.getAllocationManager().release(pre_hash_vector_0);
cCtx.getAllocationManager().release(join_result_vector_ord_0_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1_0);
cCtx.getAllocationManager().release(join_result_vector_ord_2_0);
cCtx.getAllocationManager().release(join_result_vector_ord_3_0);
cCtx.getAllocationManager().release(join_result_vector_ord_4_0);
cCtx.getAllocationManager().release(join_result_vector_ord_5_0);
int[] join_result_vector_ord_0 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_1 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_2 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_3 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_4 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_5 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_6 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_7 = cCtx.getAllocationManager().getIntVector();
int[] join_result_vector_ord_8 = cCtx.getAllocationManager().getIntVector();
ArrowTableReader table_C = cCtx.getArrowReader(2);
while (table_C.loadNextBatch()) {
    org.apache.arrow.vector.IntVector table_C_vc_0 = ((org.apache.arrow.vector.IntVector) table_C.getVector(0));
    org.apache.arrow.vector.IntVector table_C_vc_1 = ((org.apache.arrow.vector.IntVector) table_C.getVector(1));
    org.apache.arrow.vector.IntVector table_C_vc_2 = ((org.apache.arrow.vector.IntVector) table_C.getVector(2));
    VectorisedHashOperators.constructPreHashKeyVectorSIMD(pre_hash_vector, table_C_vc_0, false);
    int recordCount = table_C_vc_0.getValueCount();
    int currentLoopIndex = 0;
    while ((currentLoopIndex < recordCount)) {
        int currentResultIndex = 0;
        while ((currentLoopIndex < recordCount)) {
            int right_join_key = table_C_vc_0.get(currentLoopIndex);
            long right_join_key_pre_hash = pre_hash_vector[currentLoopIndex];
            int records_to_join_index = join_map.getIndex(right_join_key, right_join_key_pre_hash);
            if ((records_to_join_index == -1)) {
                currentLoopIndex++;
                continue;
            }
            int left_join_record_count = join_map.keysRecordCount[records_to_join_index];
            if ((left_join_record_count > (VectorisedOperators.VECTOR_LENGTH - currentResultIndex))) {
                break;
            }
            int right_join_ord_1 = table_C_vc_1.get(currentLoopIndex);
            int right_join_ord_2 = table_C_vc_2.get(currentLoopIndex);
            for (int i = 0; i < left_join_record_count; i++) {
                join_result_vector_ord_0[currentResultIndex] = join_map.values_record_ord_0[records_to_join_index][i];
                join_result_vector_ord_1[currentResultIndex] = join_map.values_record_ord_1[records_to_join_index][i];
                join_result_vector_ord_2[currentResultIndex] = join_map.values_record_ord_2[records_to_join_index][i];
                join_result_vector_ord_3[currentResultIndex] = join_map.values_record_ord_3[records_to_join_index][i];
                join_result_vector_ord_4[currentResultIndex] = join_map.values_record_ord_4[records_to_join_index][i];
                join_result_vector_ord_5[currentResultIndex] = join_map.values_record_ord_5[records_to_join_index][i];
                join_result_vector_ord_6[currentResultIndex] = right_join_key;
                join_result_vector_ord_7[currentResultIndex] = right_join_ord_1;
                join_result_vector_ord_8[currentResultIndex] = right_join_ord_2;
                currentResultIndex++;
            }
            currentLoopIndex++;
        }
        count += currentResultIndex;
    }
}
cCtx.getAllocationManager().release(pre_hash_vector);
cCtx.getAllocationManager().release(join_result_vector_ord_0);
cCtx.getAllocationManager().release(join_result_vector_ord_1);
cCtx.getAllocationManager().release(join_result_vector_ord_2);
cCtx.getAllocationManager().release(join_result_vector_ord_3);
cCtx.getAllocationManager().release(join_result_vector_ord_4);
cCtx.getAllocationManager().release(join_result_vector_ord_5);
cCtx.getAllocationManager().release(join_result_vector_ord_6);
cCtx.getAllocationManager().release(join_result_vector_ord_7);
cCtx.getAllocationManager().release(join_result_vector_ord_8);
cCtx.getResultConsumptionTarget().consumeResultItem(count);

58317.603 ms/op
# Warmup Iteration   2: 54291.071 ms/op
# Warmup Iteration   3: 54962.160 ms/op
# Warmup Iteration   4: 54626.615 ms/op
# Warmup Iteration   5: 57176.752 ms/op
Iteration   1: 57109.643 ms/op
                 executeQuery·p0.00:   57109.643 ms/op
                 executeQuery·p0.50:   57109.643 ms/op
                 executeQuery·p0.90:   57109.643 ms/op
                 executeQuery·p0.95:   57109.643 ms/op
                 executeQuery·p0.99:   57109.643 ms/op
                 executeQuery·p0.999:  57109.643 ms/op
                 executeQuery·p0.9999: 57109.643 ms/op
                 executeQuery·p1.00:   57109.643 ms/op

Iteration   2: 55700.357 ms/op
                 executeQuery·p0.00:   55700.357 ms/op
                 executeQuery·p0.50:   55700.357 ms/op
                 executeQuery·p0.90:   55700.357 ms/op
                 executeQuery·p0.95:   55700.357 ms/op
                 executeQuery·p0.99:   55700.357 ms/op
                 executeQuery·p0.999:  55700.357 ms/op
                 executeQuery·p0.9999: 55700.357 ms/op
                 executeQuery·p1.00:   55700.357 ms/op

Iteration   3: 56304.337 ms/op
                 executeQuery·p0.00:   56304.337 ms/op
                 executeQuery·p0.50:   56304.337 ms/op
                 executeQuery·p0.90:   56304.337 ms/op
                 executeQuery·p0.95:   56304.337 ms/op
                 executeQuery·p0.99:   56304.337 ms/op
                 executeQuery·p0.999:  56304.337 ms/op
                 executeQuery·p0.9999: 56304.337 ms/op
                 executeQuery·p1.00:   56304.337 ms/op

Iteration   4: 57042.534 ms/op
                 executeQuery·p0.00:   57042.534 ms/op
                 executeQuery·p0.50:   57042.534 ms/op
                 executeQuery·p0.90:   57042.534 ms/op
                 executeQuery·p0.95:   57042.534 ms/op
                 executeQuery·p0.99:   57042.534 ms/op
                 executeQuery·p0.999:  57042.534 ms/op
                 executeQuery·p0.9999: 57042.534 ms/op
                 executeQuery·p1.00:   57042.534 ms/op

Iteration   5: 57109.643 ms/op
                 executeQuery·p0.00:   57109.643 ms/op
                 executeQuery·p0.50:   57109.643 ms/op
                 executeQuery·p0.90:   57109.643 ms/op
                 executeQuery·p0.95:   57109.643 ms/op
                 executeQuery·p0.99:   57109.643 ms/op
                 executeQuery·p0.999:  57109.643 ms/op
                 executeQuery·p0.9999: 57109.643 ms/op
                 executeQuery·p1.00:   57109.643 ms/op



Result "benchmarks.join_query.VectorisedSimd.executeQuery":
  N = 10
  mean =  56539.218 ±(99.9%) 807.788 ms/op

  Histogram, ms/op:
    [55000.000, 55250.000) = 0 
    [55250.000, 55500.000) = 0 
    [55500.000, 55750.000) = 1 
    [55750.000, 56000.000) = 1 
    [56000.000, 56250.000) = 2 
    [56250.000, 56500.000) = 1 
    [56500.000, 56750.000) = 0 
    [56750.000, 57000.000) = 1 
    [57000.000, 57250.000) = 4 
    [57250.000, 57500.000) = 0 
    [57500.000, 57750.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  55700.357 ms/op
     p(50.0000) =  56539.218 ms/op
     p(90.0000) =  57109.643 ms/op
     p(95.0000) =  57109.643 ms/op
     p(99.0000) =  57109.643 ms/op
     p(99.9000) =  57109.643 ms/op
     p(99.9900) =  57109.643 ms/op
     p(99.9990) =  57109.643 ms/op
     p(99.9999) =  57109.643 ms/op
    p(100.0000) =  57109.643 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 65.82% complete, ETA 07:30:04
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2490.368 ±(99.9%) 872.486 ms/op
# Warmup Iteration   2: 2592.080 ±(99.9%) 62.593 ms/op
# Warmup Iteration   3: 2591.031 ±(99.9%) 46.288 ms/op
# Warmup Iteration   4: 2579.497 ±(99.9%) 0.001 ms/op
# Warmup Iteration   5: 2580.546 ±(99.9%) 13.552 ms/op
Iteration   1: 2579.497 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2579.497 ms/op
                 executeQuery·p0.50:   2579.497 ms/op
                 executeQuery·p0.90:   2579.497 ms/op
                 executeQuery·p0.95:   2579.497 ms/op
                 executeQuery·p0.99:   2579.497 ms/op
                 executeQuery·p0.999:  2579.497 ms/op
                 executeQuery·p0.9999: 2579.497 ms/op
                 executeQuery·p1.00:   2579.497 ms/op

Iteration   2: 2580.546 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2579.497 ms/op
                 executeQuery·p0.50:   2579.497 ms/op
                 executeQuery·p0.90:   2583.691 ms/op
                 executeQuery·p0.95:   2583.691 ms/op
                 executeQuery·p0.99:   2583.691 ms/op
                 executeQuery·p0.999:  2583.691 ms/op
                 executeQuery·p0.9999: 2583.691 ms/op
                 executeQuery·p1.00:   2583.691 ms/op

Iteration   3: 2580.546 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2579.497 ms/op
                 executeQuery·p0.50:   2579.497 ms/op
                 executeQuery·p0.90:   2583.691 ms/op
                 executeQuery·p0.95:   2583.691 ms/op
                 executeQuery·p0.99:   2583.691 ms/op
                 executeQuery·p0.999:  2583.691 ms/op
                 executeQuery·p0.9999: 2583.691 ms/op
                 executeQuery·p1.00:   2583.691 ms/op

Iteration   4: 2587.886 ±(99.9%) 145.116 ms/op
                 executeQuery·p0.00:   2575.303 ms/op
                 executeQuery·p0.50:   2577.400 ms/op
                 executeQuery·p0.90:   2621.440 ms/op
                 executeQuery·p0.95:   2621.440 ms/op
                 executeQuery·p0.99:   2621.440 ms/op
                 executeQuery·p0.999:  2621.440 ms/op
                 executeQuery·p0.9999: 2621.440 ms/op
                 executeQuery·p1.00:   2621.440 ms/op

Iteration   5: 2575.303 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2575.303 ms/op
                 executeQuery·p0.50:   2575.303 ms/op
                 executeQuery·p0.90:   2575.303 ms/op
                 executeQuery·p0.95:   2575.303 ms/op
                 executeQuery·p0.99:   2575.303 ms/op
                 executeQuery·p0.999:  2575.303 ms/op
                 executeQuery·p0.9999: 2575.303 ms/op
                 executeQuery·p1.00:   2575.303 ms/op


# Run progress: 66.14% complete, ETA 07:24:41
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2492.465 ±(99.9%) 818.920 ms/op
# Warmup Iteration   2: 2425.985 ±(99.9%) 18.415 ms/op
# Warmup Iteration   3: 2416.758 ±(99.9%) 35.014 ms/op
# Warmup Iteration   4: 2411.725 ±(99.9%) 0.001 ms/op
# Warmup Iteration   5: 2411.725 ±(99.9%) 0.001 ms/op
Iteration   1: 2411.725 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2411.725 ms/op
                 executeQuery·p0.50:   2411.725 ms/op
                 executeQuery·p0.90:   2411.725 ms/op
                 executeQuery·p0.95:   2411.725 ms/op
                 executeQuery·p0.99:   2411.725 ms/op
                 executeQuery·p0.999:  2411.725 ms/op
                 executeQuery·p0.9999: 2411.725 ms/op
                 executeQuery·p1.00:   2411.725 ms/op

Iteration   2: 2411.725 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2411.725 ms/op
                 executeQuery·p0.50:   2411.725 ms/op
                 executeQuery·p0.90:   2411.725 ms/op
                 executeQuery·p0.95:   2411.725 ms/op
                 executeQuery·p0.99:   2411.725 ms/op
                 executeQuery·p0.999:  2411.725 ms/op
                 executeQuery·p0.9999: 2411.725 ms/op
                 executeQuery·p1.00:   2411.725 ms/op

Iteration   3: 2410.886 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2407.530 ms/op
                 executeQuery·p0.50:   2411.725 ms/op
                 executeQuery·p0.90:   2411.725 ms/op
                 executeQuery·p0.95:   2411.725 ms/op
                 executeQuery·p0.99:   2411.725 ms/op
                 executeQuery·p0.999:  2411.725 ms/op
                 executeQuery·p0.9999: 2411.725 ms/op
                 executeQuery·p1.00:   2411.725 ms/op

Iteration   4: 2412.564 ±(99.9%) 70.769 ms/op
                 executeQuery·p0.00:   2403.336 ms/op
                 executeQuery·p0.50:   2403.336 ms/op
                 executeQuery·p0.90:   2445.279 ms/op
                 executeQuery·p0.95:   2445.279 ms/op
                 executeQuery·p0.99:   2445.279 ms/op
                 executeQuery·p0.999:  2445.279 ms/op
                 executeQuery·p0.9999: 2445.279 ms/op
                 executeQuery·p1.00:   2445.279 ms/op

Iteration   5: 2402.497 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2399.142 ms/op
                 executeQuery·p0.50:   2403.336 ms/op
                 executeQuery·p0.90:   2403.336 ms/op
                 executeQuery·p0.95:   2403.336 ms/op
                 executeQuery·p0.99:   2403.336 ms/op
                 executeQuery·p0.999:  2403.336 ms/op
                 executeQuery·p0.9999: 2403.336 ms/op
                 executeQuery·p1.00:   2403.336 ms/op



Result "benchmarks.join_query_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 45
  mean =   2485.824 ±(99.9%) 45.381 ms/op

  Histogram, ms/op:
    [2300.000, 2325.000) = 0 
    [2325.000, 2350.000) = 0 
    [2350.000, 2375.000) = 0 
    [2375.000, 2400.000) = 1 
    [2400.000, 2425.000) = 23 
    [2425.000, 2450.000) = 1 
    [2450.000, 2475.000) = 0 
    [2475.000, 2500.000) = 0 
    [2500.000, 2525.000) = 0 
    [2525.000, 2550.000) = 0 
    [2550.000, 2575.000) = 0 
    [2575.000, 2600.000) = 19 
    [2600.000, 2625.000) = 1 
    [2625.000, 2650.000) = 0 
    [2650.000, 2675.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   2399.142 ms/op
     p(50.0000) =   2411.725 ms/op
     p(90.0000) =   2579.497 ms/op
     p(95.0000) =   2583.691 ms/op
     p(99.0000) =   2621.440 ms/op
     p(99.9000) =   2621.440 ms/op
     p(99.9900) =   2621.440 ms/op
     p(99.9990) =   2621.440 ms/op
     p(99.9999) =   2621.440 ms/op
    p(100.0000) =   2621.440 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 66.46% complete, ETA 07:19:28
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 32984.007 ms/op
# Warmup Iteration   2: 33487.323 ms/op
# Warmup Iteration   3: 31037.850 ms/op
# Warmup Iteration   4: 31071.404 ms/op
# Warmup Iteration   5: 31205.622 ms/op
Iteration   1: 31205.622 ms/op
                 executeQuery·p0.00:   31205.622 ms/op
                 executeQuery·p0.50:   31205.622 ms/op
                 executeQuery·p0.90:   31205.622 ms/op
                 executeQuery·p0.95:   31205.622 ms/op
                 executeQuery·p0.99:   31205.622 ms/op
                 executeQuery·p0.999:  31205.622 ms/op
                 executeQuery·p0.9999: 31205.622 ms/op
                 executeQuery·p1.00:   31205.622 ms/op

Iteration   2: 31205.622 ms/op
                 executeQuery·p0.00:   31205.622 ms/op
                 executeQuery·p0.50:   31205.622 ms/op
                 executeQuery·p0.90:   31205.622 ms/op
                 executeQuery·p0.95:   31205.622 ms/op
                 executeQuery·p0.99:   31205.622 ms/op
                 executeQuery·p0.999:  31205.622 ms/op
                 executeQuery·p0.9999: 31205.622 ms/op
                 executeQuery·p1.00:   31205.622 ms/op

Iteration   3: 31205.622 ms/op
                 executeQuery·p0.00:   31205.622 ms/op
                 executeQuery·p0.50:   31205.622 ms/op
                 executeQuery·p0.90:   31205.622 ms/op
                 executeQuery·p0.95:   31205.622 ms/op
                 executeQuery·p0.99:   31205.622 ms/op
                 executeQuery·p0.999:  31205.622 ms/op
                 executeQuery·p0.9999: 31205.622 ms/op
                 executeQuery·p1.00:   31205.622 ms/op

Iteration   4: 31205.622 ms/op
                 executeQuery·p0.00:   31205.622 ms/op
                 executeQuery·p0.50:   31205.622 ms/op
                 executeQuery·p0.90:   31205.622 ms/op
                 executeQuery·p0.95:   31205.622 ms/op
                 executeQuery·p0.99:   31205.622 ms/op
                 executeQuery·p0.999:  31205.622 ms/op
                 executeQuery·p0.9999: 31205.622 ms/op
                 executeQuery·p1.00:   31205.622 ms/op

Iteration   5: 31205.622 ms/op
                 executeQuery·p0.00:   31205.622 ms/op
                 executeQuery·p0.50:   31205.622 ms/op
                 executeQuery·p0.90:   31205.622 ms/op
                 executeQuery·p0.95:   31205.622 ms/op
                 executeQuery·p0.99:   31205.622 ms/op
                 executeQuery·p0.999:  31205.622 ms/op
                 executeQuery·p0.9999: 31205.622 ms/op
                 executeQuery·p1.00:   31205.622 ms/op


# Run progress: 66.77% complete, ETA 07:16:05
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 33218.888 ms/op
# Warmup Iteration   2: 33789.313 ms/op
# Warmup Iteration   3: 31843.156 ms/op
# Warmup Iteration   4: 31608.275 ms/op
# Warmup Iteration   5: 31608.275 ms/op
Iteration   1: 31608.275 ms/op
                 executeQuery·p0.00:   31608.275 ms/op
                 executeQuery·p0.50:   31608.275 ms/op
                 executeQuery·p0.90:   31608.275 ms/op
                 executeQuery·p0.95:   31608.275 ms/op
                 executeQuery·p0.99:   31608.275 ms/op
                 executeQuery·p0.999:  31608.275 ms/op
                 executeQuery·p0.9999: 31608.275 ms/op
                 executeQuery·p1.00:   31608.275 ms/op

Iteration   2: 31608.275 ms/op
                 executeQuery·p0.00:   31608.275 ms/op
                 executeQuery·p0.50:   31608.275 ms/op
                 executeQuery·p0.90:   31608.275 ms/op
                 executeQuery·p0.95:   31608.275 ms/op
                 executeQuery·p0.99:   31608.275 ms/op
                 executeQuery·p0.999:  31608.275 ms/op
                 executeQuery·p0.9999: 31608.275 ms/op
                 executeQuery·p1.00:   31608.275 ms/op

Iteration   3: 31608.275 ms/op
                 executeQuery·p0.00:   31608.275 ms/op
                 executeQuery·p0.50:   31608.275 ms/op
                 executeQuery·p0.90:   31608.275 ms/op
                 executeQuery·p0.95:   31608.275 ms/op
                 executeQuery·p0.99:   31608.275 ms/op
                 executeQuery·p0.999:  31608.275 ms/op
                 executeQuery·p0.9999: 31608.275 ms/op
                 executeQuery·p1.00:   31608.275 ms/op

Iteration   4: 31608.275 ms/op
                 executeQuery·p0.00:   31608.275 ms/op
                 executeQuery·p0.50:   31608.275 ms/op
                 executeQuery·p0.90:   31608.275 ms/op
                 executeQuery·p0.95:   31608.275 ms/op
                 executeQuery·p0.99:   31608.275 ms/op
                 executeQuery·p0.999:  31608.275 ms/op
                 executeQuery·p0.9999: 31608.275 ms/op
                 executeQuery·p1.00:   31608.275 ms/op

Iteration   5: 31742.493 ms/op
                 executeQuery·p0.00:   31742.493 ms/op
                 executeQuery·p0.50:   31742.493 ms/op
                 executeQuery·p0.90:   31742.493 ms/op
                 executeQuery·p0.95:   31742.493 ms/op
                 executeQuery·p0.99:   31742.493 ms/op
                 executeQuery·p0.999:  31742.493 ms/op
                 executeQuery·p0.9999: 31742.493 ms/op
                 executeQuery·p1.00:   31742.493 ms/op



Result "benchmarks.join_query_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =  31420.370 ±(99.9%) 347.537 ms/op

  Histogram, ms/op:
    [31200.000, 31250.000) = 5 
    [31250.000, 31300.000) = 0 
    [31300.000, 31350.000) = 0 
    [31350.000, 31400.000) = 0 
    [31400.000, 31450.000) = 0 
    [31450.000, 31500.000) = 0 
    [31500.000, 31550.000) = 0 
    [31550.000, 31600.000) = 0 
    [31600.000, 31650.000) = 4 
    [31650.000, 31700.000) = 0 
    [31700.000, 31750.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  31205.622 ms/op
     p(50.0000) =  31406.948 ms/op
     p(90.0000) =  31729.071 ms/op
     p(95.0000) =  31742.493 ms/op
     p(99.0000) =  31742.493 ms/op
     p(99.9000) =  31742.493 ms/op
     p(99.9900) =  31742.493 ms/op
     p(99.9990) =  31742.493 ms/op
     p(99.9999) =  31742.493 ms/op
    p(100.0000) =  31742.493 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 67.09% complete, ETA 07:12:42
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2539.651 ±(99.9%) 1532.809 ms/op
# Warmup Iteration   2: 2480.931 ±(99.9%) 551.254 ms/op
# Warmup Iteration   3: 2584.740 ±(99.9%) 384.179 ms/op
# Warmup Iteration   4: 2673.869 ±(99.9%) 365.312 ms/op
# Warmup Iteration   5: 2867.855 ±(99.9%) 13.552 ms/op
Iteration   1: 2860.515 ±(99.9%) 22.130 ms/op
                 executeQuery·p0.00:   2856.321 ms/op
                 executeQuery·p0.50:   2860.515 ms/op
                 executeQuery·p0.90:   2864.710 ms/op
                 executeQuery·p0.95:   2864.710 ms/op
                 executeQuery·p0.99:   2864.710 ms/op
                 executeQuery·p0.999:  2864.710 ms/op
                 executeQuery·p0.9999: 2864.710 ms/op
                 executeQuery·p1.00:   2864.710 ms/op

Iteration   2: 2857.370 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2856.321 ms/op
                 executeQuery·p0.50:   2856.321 ms/op
                 executeQuery·p0.90:   2860.515 ms/op
                 executeQuery·p0.95:   2860.515 ms/op
                 executeQuery·p0.99:   2860.515 ms/op
                 executeQuery·p0.999:  2860.515 ms/op
                 executeQuery·p0.9999: 2860.515 ms/op
                 executeQuery·p1.00:   2860.515 ms/op

Iteration   3: 2775.581 ±(99.9%) 710.359 ms/op
                 executeQuery·p0.00:   2629.829 ms/op
                 executeQuery·p0.50:   2805.989 ms/op
                 executeQuery·p0.90:   2860.515 ms/op
                 executeQuery·p0.95:   2860.515 ms/op
                 executeQuery·p0.99:   2860.515 ms/op
                 executeQuery·p0.999:  2860.515 ms/op
                 executeQuery·p0.9999: 2860.515 ms/op
                 executeQuery·p1.00:   2860.515 ms/op

Iteration   4: 2639.266 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2638.217 ms/op
                 executeQuery·p0.50:   2638.217 ms/op
                 executeQuery·p0.90:   2642.412 ms/op
                 executeQuery·p0.95:   2642.412 ms/op
                 executeQuery·p0.99:   2642.412 ms/op
                 executeQuery·p0.999:  2642.412 ms/op
                 executeQuery·p0.9999: 2642.412 ms/op
                 executeQuery·p1.00:   2642.412 ms/op

Iteration   5: 2641.363 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2638.217 ms/op
                 executeQuery·p0.50:   2642.412 ms/op
                 executeQuery·p0.90:   2642.412 ms/op
                 executeQuery·p0.95:   2642.412 ms/op
                 executeQuery·p0.99:   2642.412 ms/op
                 executeQuery·p0.999:  2642.412 ms/op
                 executeQuery·p0.9999: 2642.412 ms/op
                 executeQuery·p1.00:   2642.412 ms/op


# Run progress: 67.41% complete, ETA 07:07:27
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2569.011 ±(99.9%) 1565.684 ms/op
# Warmup Iteration   2: 2518.680 ±(99.9%) 587.383 ms/op
# Warmup Iteration   3: 2526.020 ±(99.9%) 40.655 ms/op
# Warmup Iteration   4: 2560.623 ±(99.9%) 322.597 ms/op
# Warmup Iteration   5: 2751.463 ±(99.9%) 0.001 ms/op
Iteration   1: 2749.366 ±(99.9%) 15.648 ms/op
                 executeQuery·p0.00:   2747.269 ms/op
                 executeQuery·p0.50:   2749.366 ms/op
                 executeQuery·p0.90:   2751.463 ms/op
                 executeQuery·p0.95:   2751.463 ms/op
                 executeQuery·p0.99:   2751.463 ms/op
                 executeQuery·p0.999:  2751.463 ms/op
                 executeQuery·p0.9999: 2751.463 ms/op
                 executeQuery·p1.00:   2751.463 ms/op

Iteration   2: 2746.221 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2743.075 ms/op
                 executeQuery·p0.50:   2747.269 ms/op
                 executeQuery·p0.90:   2747.269 ms/op
                 executeQuery·p0.95:   2747.269 ms/op
                 executeQuery·p0.99:   2747.269 ms/op
                 executeQuery·p0.999:  2747.269 ms/op
                 executeQuery·p0.9999: 2747.269 ms/op
                 executeQuery·p1.00:   2747.269 ms/op

Iteration   3: 2691.695 ±(99.9%) 718.244 ms/op
                 executeQuery·p0.00:   2524.971 ms/op
                 executeQuery·p0.50:   2747.269 ms/op
                 executeQuery·p0.90:   2747.269 ms/op
                 executeQuery·p0.95:   2747.269 ms/op
                 executeQuery·p0.99:   2747.269 ms/op
                 executeQuery·p0.999:  2747.269 ms/op
                 executeQuery·p0.9999: 2747.269 ms/op
                 executeQuery·p1.00:   2747.269 ms/op

Iteration   4: 2522.874 ±(99.9%) 46.945 ms/op
                 executeQuery·p0.00:   2512.388 ms/op
                 executeQuery·p0.50:   2524.971 ms/op
                 executeQuery·p0.90:   2529.165 ms/op
                 executeQuery·p0.95:   2529.165 ms/op
                 executeQuery·p0.99:   2529.165 ms/op
                 executeQuery·p0.999:  2529.165 ms/op
                 executeQuery·p0.9999: 2529.165 ms/op
                 executeQuery·p1.00:   2529.165 ms/op

Iteration   5: 2523.922 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2520.777 ms/op
                 executeQuery·p0.50:   2524.971 ms/op
                 executeQuery·p0.90:   2524.971 ms/op
                 executeQuery·p0.95:   2524.971 ms/op
                 executeQuery·p0.99:   2524.971 ms/op
                 executeQuery·p0.999:  2524.971 ms/op
                 executeQuery·p0.9999: 2524.971 ms/op
                 executeQuery·p1.00:   2524.971 ms/op



Result "benchmarks.join_query_hard_coded.NonVectorisedSimd.executeQuery":
  N = 40
  mean =   2700.817 ±(99.9%) 69.496 ms/op

  Histogram, ms/op:
    [2500.000, 2525.000) = 8 
    [2525.000, 2550.000) = 1 
    [2550.000, 2575.000) = 0 
    [2575.000, 2600.000) = 0 
    [2600.000, 2625.000) = 0 
    [2625.000, 2650.000) = 9 
    [2650.000, 2675.000) = 0 
    [2675.000, 2700.000) = 0 
    [2700.000, 2725.000) = 0 
    [2725.000, 2750.000) = 9 
    [2750.000, 2775.000) = 3 
    [2775.000, 2800.000) = 0 
    [2800.000, 2825.000) = 0 
    [2825.000, 2850.000) = 0 
    [2850.000, 2875.000) = 10 

  Percentiles, ms/op:
      p(0.0000) =   2512.388 ms/op
     p(50.0000) =   2747.269 ms/op
     p(90.0000) =   2860.515 ms/op
     p(95.0000) =   2860.515 ms/op
     p(99.0000) =   2864.710 ms/op
     p(99.9000) =   2864.710 ms/op
     p(99.9900) =   2864.710 ms/op
     p(99.9990) =   2864.710 ms/op
     p(99.9999) =   2864.710 ms/op
    p(100.0000) =   2864.710 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.NonVectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 67.72% complete, ETA 07:02:11
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 33722.204 ms/op
# Warmup Iteration   2: 35433.480 ms/op
# Warmup Iteration   3: 33319.551 ms/op
# Warmup Iteration   4: 30769.414 ms/op
# Warmup Iteration   5: 30970.741 ms/op
Iteration   1: 32614.908 ms/op
                 executeQuery·p0.00:   32614.908 ms/op
                 executeQuery·p0.50:   32614.908 ms/op
                 executeQuery·p0.90:   32614.908 ms/op
                 executeQuery·p0.95:   32614.908 ms/op
                 executeQuery·p0.99:   32614.908 ms/op
                 executeQuery·p0.999:  32614.908 ms/op
                 executeQuery·p0.9999: 32614.908 ms/op
                 executeQuery·p1.00:   32614.908 ms/op

Iteration   2: 32849.789 ms/op
                 executeQuery·p0.00:   32849.789 ms/op
                 executeQuery·p0.50:   32849.789 ms/op
                 executeQuery·p0.90:   32849.789 ms/op
                 executeQuery·p0.95:   32849.789 ms/op
                 executeQuery·p0.99:   32849.789 ms/op
                 executeQuery·p0.999:  32849.789 ms/op
                 executeQuery·p0.9999: 32849.789 ms/op
                 executeQuery·p1.00:   32849.789 ms/op

Iteration   3: 32514.245 ms/op
                 executeQuery·p0.00:   32514.245 ms/op
                 executeQuery·p0.50:   32514.245 ms/op
                 executeQuery·p0.90:   32514.245 ms/op
                 executeQuery·p0.95:   32514.245 ms/op
                 executeQuery·p0.99:   32514.245 ms/op
                 executeQuery·p0.999:  32514.245 ms/op
                 executeQuery·p0.9999: 32514.245 ms/op
                 executeQuery·p1.00:   32514.245 ms/op

Iteration   4: 32950.452 ms/op
                 executeQuery·p0.00:   32950.452 ms/op
                 executeQuery·p0.50:   32950.452 ms/op
                 executeQuery·p0.90:   32950.452 ms/op
                 executeQuery·p0.95:   32950.452 ms/op
                 executeQuery·p0.99:   32950.452 ms/op
                 executeQuery·p0.999:  32950.452 ms/op
                 executeQuery·p0.9999: 32950.452 ms/op
                 executeQuery·p1.00:   32950.452 ms/op

Iteration   5: 32480.690 ms/op
                 executeQuery·p0.00:   32480.690 ms/op
                 executeQuery·p0.50:   32480.690 ms/op
                 executeQuery·p0.90:   32480.690 ms/op
                 executeQuery·p0.95:   32480.690 ms/op
                 executeQuery·p0.99:   32480.690 ms/op
                 executeQuery·p0.999:  32480.690 ms/op
                 executeQuery·p0.9999: 32480.690 ms/op
                 executeQuery·p1.00:   32480.690 ms/op


# Run progress: 68.04% complete, ETA 06:58:52
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 33789.313 ms/op
# Warmup Iteration   2: 35634.807 ms/op
# Warmup Iteration   3: 33722.204 ms/op
# Warmup Iteration   4: 31037.850 ms/op
# Warmup Iteration   5: 30970.741 ms/op
Iteration   1: 33252.442 ms/op
                 executeQuery·p0.00:   33252.442 ms/op
                 executeQuery·p0.50:   33252.442 ms/op
                 executeQuery·p0.90:   33252.442 ms/op
                 executeQuery·p0.95:   33252.442 ms/op
                 executeQuery·p0.99:   33252.442 ms/op
                 executeQuery·p0.999:  33252.442 ms/op
                 executeQuery·p0.9999: 33252.442 ms/op
                 executeQuery·p1.00:   33252.442 ms/op

Iteration   2: 32715.571 ms/op
                 executeQuery·p0.00:   32715.571 ms/op
                 executeQuery·p0.50:   32715.571 ms/op
                 executeQuery·p0.90:   32715.571 ms/op
                 executeQuery·p0.95:   32715.571 ms/op
                 executeQuery·p0.99:   32715.571 ms/op
                 executeQuery·p0.999:  32715.571 ms/op
                 executeQuery·p0.9999: 32715.571 ms/op
                 executeQuery·p1.00:   32715.571 ms/op

Iteration   3: 32715.571 ms/op
                 executeQuery·p0.00:   32715.571 ms/op
                 executeQuery·p0.50:   32715.571 ms/op
                 executeQuery·p0.90:   32715.571 ms/op
                 executeQuery·p0.95:   32715.571 ms/op
                 executeQuery·p0.99:   32715.571 ms/op
                 executeQuery·p0.999:  32715.571 ms/op
                 executeQuery·p0.9999: 32715.571 ms/op
                 executeQuery·p1.00:   32715.571 ms/op

Iteration   4: 33218.888 ms/op
                 executeQuery·p0.00:   33218.888 ms/op
                 executeQuery·p0.50:   33218.888 ms/op
                 executeQuery·p0.90:   33218.888 ms/op
                 executeQuery·p0.95:   33218.888 ms/op
                 executeQuery·p0.99:   33218.888 ms/op
                 executeQuery·p0.999:  33218.888 ms/op
                 executeQuery·p0.9999: 33218.888 ms/op
                 executeQuery·p1.00:   33218.888 ms/op

Iteration   5: 32715.571 ms/op
                 executeQuery·p0.00:   32715.571 ms/op
                 executeQuery·p0.50:   32715.571 ms/op
                 executeQuery·p0.90:   32715.571 ms/op
                 executeQuery·p0.95:   32715.571 ms/op
                 executeQuery·p0.99:   32715.571 ms/op
                 executeQuery·p0.999:  32715.571 ms/op
                 executeQuery·p0.9999: 32715.571 ms/op
                 executeQuery·p1.00:   32715.571 ms/op



Result "benchmarks.join_query_hard_coded.NonVectorisedSimd.executeQuery":
  N = 10
  mean =  32802.813 ±(99.9%) 404.566 ms/op

  Histogram, ms/op:
    [32400.000, 32450.000) = 0 
    [32450.000, 32500.000) = 1 
    [32500.000, 32550.000) = 1 
    [32550.000, 32600.000) = 0 
    [32600.000, 32650.000) = 1 
    [32650.000, 32700.000) = 0 
    [32700.000, 32750.000) = 3 
    [32750.000, 32800.000) = 0 
    [32800.000, 32850.000) = 1 
    [32850.000, 32900.000) = 0 
    [32900.000, 32950.000) = 0 
    [32950.000, 33000.000) = 1 
    [33000.000, 33050.000) = 0 
    [33050.000, 33100.000) = 0 
    [33100.000, 33150.000) = 0 
    [33150.000, 33200.000) = 0 
    [33200.000, 33250.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =  32480.690 ms/op
     p(50.0000) =  32715.571 ms/op
     p(90.0000) =  33249.087 ms/op
     p(95.0000) =  33252.442 ms/op
     p(99.0000) =  33252.442 ms/op
     p(99.9000) =  33252.442 ms/op
     p(99.9900) =  33252.442 ms/op
     p(99.9990) =  33252.442 ms/op
     p(99.9999) =  33252.442 ms/op
    p(100.0000) =  33252.442 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 68.35% complete, ETA 06:55:32
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2274.152 ±(99.9%) 169.545 ms/op
# Warmup Iteration   2: 2237.242 ±(99.9%) 21.669 ms/op
# Warmup Iteration   3: 2226.337 ±(99.9%) 7.223 ms/op
# Warmup Iteration   4: 2226.337 ±(99.9%) 7.223 ms/op
# Warmup Iteration   5: 2236.403 ±(99.9%) 70.769 ms/op
Iteration   1: 2227.175 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2227.175 ms/op
                 executeQuery·p0.50:   2227.175 ms/op
                 executeQuery·p0.90:   2227.175 ms/op
                 executeQuery·p0.95:   2227.175 ms/op
                 executeQuery·p0.99:   2227.175 ms/op
                 executeQuery·p0.999:  2227.175 ms/op
                 executeQuery·p0.9999: 2227.175 ms/op
                 executeQuery·p1.00:   2227.175 ms/op

Iteration   2: 2226.337 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2222.981 ms/op
                 executeQuery·p0.50:   2227.175 ms/op
                 executeQuery·p0.90:   2227.175 ms/op
                 executeQuery·p0.95:   2227.175 ms/op
                 executeQuery·p0.99:   2227.175 ms/op
                 executeQuery·p0.999:  2227.175 ms/op
                 executeQuery·p0.9999: 2227.175 ms/op
                 executeQuery·p1.00:   2227.175 ms/op

Iteration   3: 2219.626 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2218.787 ms/op
                 executeQuery·p0.50:   2218.787 ms/op
                 executeQuery·p0.90:   2222.981 ms/op
                 executeQuery·p0.95:   2222.981 ms/op
                 executeQuery·p0.99:   2222.981 ms/op
                 executeQuery·p0.999:  2222.981 ms/op
                 executeQuery·p0.9999: 2222.981 ms/op
                 executeQuery·p1.00:   2222.981 ms/op

Iteration   4: 2222.981 ±(99.9%) 11.420 ms/op
                 executeQuery·p0.00:   2218.787 ms/op
                 executeQuery·p0.50:   2222.981 ms/op
                 executeQuery·p0.90:   2227.175 ms/op
                 executeQuery·p0.95:   2227.175 ms/op
                 executeQuery·p0.99:   2227.175 ms/op
                 executeQuery·p0.999:  2227.175 ms/op
                 executeQuery·p0.9999: 2227.175 ms/op
                 executeQuery·p1.00:   2227.175 ms/op

Iteration   5: 2222.142 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2218.787 ms/op
                 executeQuery·p0.50:   2222.981 ms/op
                 executeQuery·p0.90:   2222.981 ms/op
                 executeQuery·p0.95:   2222.981 ms/op
                 executeQuery·p0.99:   2222.981 ms/op
                 executeQuery·p0.999:  2222.981 ms/op
                 executeQuery·p0.9999: 2222.981 ms/op
                 executeQuery·p1.00:   2222.981 ms/op


# Run progress: 68.67% complete, ETA 06:50:22
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2255.697 ±(99.9%) 107.981 ms/op
# Warmup Iteration   2: 2230.531 ±(99.9%) 28.891 ms/op
# Warmup Iteration   3: 2222.142 ±(99.9%) 13.513 ms/op
# Warmup Iteration   4: 2222.981 ±(99.9%) 22.841 ms/op
# Warmup Iteration   5: 2232.209 ±(99.9%) 7.223 ms/op
Iteration   1: 2239.758 ±(99.9%) 72.228 ms/op
                 executeQuery·p0.00:   2231.370 ms/op
                 executeQuery·p0.50:   2231.370 ms/op
                 executeQuery·p0.90:   2273.313 ms/op
                 executeQuery·p0.95:   2273.313 ms/op
                 executeQuery·p0.99:   2273.313 ms/op
                 executeQuery·p0.999:  2273.313 ms/op
                 executeQuery·p0.9999: 2273.313 ms/op
                 executeQuery·p1.00:   2273.313 ms/op

Iteration   2: 2231.370 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2231.370 ms/op
                 executeQuery·p0.50:   2231.370 ms/op
                 executeQuery·p0.90:   2231.370 ms/op
                 executeQuery·p0.95:   2231.370 ms/op
                 executeQuery·p0.99:   2231.370 ms/op
                 executeQuery·p0.999:  2231.370 ms/op
                 executeQuery·p0.9999: 2231.370 ms/op
                 executeQuery·p1.00:   2231.370 ms/op

Iteration   3: 2227.175 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2227.175 ms/op
                 executeQuery·p0.50:   2227.175 ms/op
                 executeQuery·p0.90:   2227.175 ms/op
                 executeQuery·p0.95:   2227.175 ms/op
                 executeQuery·p0.99:   2227.175 ms/op
                 executeQuery·p0.999:  2227.175 ms/op
                 executeQuery·p0.9999: 2227.175 ms/op
                 executeQuery·p1.00:   2227.175 ms/op

Iteration   4: 2222.142 ±(99.9%) 28.891 ms/op
                 executeQuery·p0.00:   2214.593 ms/op
                 executeQuery·p0.50:   2222.981 ms/op
                 executeQuery·p0.90:   2231.370 ms/op
                 executeQuery·p0.95:   2231.370 ms/op
                 executeQuery·p0.99:   2231.370 ms/op
                 executeQuery·p0.999:  2231.370 ms/op
                 executeQuery·p0.9999: 2231.370 ms/op
                 executeQuery·p1.00:   2231.370 ms/op

Iteration   5: 2222.142 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2218.787 ms/op
                 executeQuery·p0.50:   2222.981 ms/op
                 executeQuery·p0.90:   2222.981 ms/op
                 executeQuery·p0.95:   2222.981 ms/op
                 executeQuery·p0.99:   2222.981 ms/op
                 executeQuery·p0.999:  2222.981 ms/op
                 executeQuery·p0.9999: 2222.981 ms/op
                 executeQuery·p1.00:   2222.981 ms/op



Result "benchmarks.join_query_hard_coded.VectorisedNonSimd.executeQuery":
  N = 50
  mean =   2226.085 ±(99.9%) 4.063 ms/op

  Histogram, ms/op:
    [2210.000, 2215.000) = 2 
    [2215.000, 2220.000) = 7 
    [2220.000, 2225.000) = 14 
    [2225.000, 2230.000) = 16 
    [2230.000, 2235.000) = 10 
    [2235.000, 2240.000) = 0 
    [2240.000, 2245.000) = 0 
    [2245.000, 2250.000) = 0 
    [2250.000, 2255.000) = 0 
    [2255.000, 2260.000) = 0 
    [2260.000, 2265.000) = 0 
    [2265.000, 2270.000) = 0 
    [2270.000, 2275.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2214.593 ms/op
     p(50.0000) =   2227.175 ms/op
     p(90.0000) =   2231.370 ms/op
     p(95.0000) =   2231.370 ms/op
     p(99.0000) =   2273.313 ms/op
     p(99.9000) =   2273.313 ms/op
     p(99.9900) =   2273.313 ms/op
     p(99.9990) =   2273.313 ms/op
     p(99.9999) =   2273.313 ms/op
    p(100.0000) =   2273.313 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 68.99% complete, ETA 06:45:14
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 28991.029 ms/op
# Warmup Iteration   2: 30031.217 ms/op
# Warmup Iteration   3: 29896.999 ms/op
# Warmup Iteration   4: 29896.999 ms/op
# Warmup Iteration   5: 29896.999 ms/op
Iteration   1: 29896.999 ms/op
                 executeQuery·p0.00:   29896.999 ms/op
                 executeQuery·p0.50:   29896.999 ms/op
                 executeQuery·p0.90:   29896.999 ms/op
                 executeQuery·p0.95:   29896.999 ms/op
                 executeQuery·p0.99:   29896.999 ms/op
                 executeQuery·p0.999:  29896.999 ms/op
                 executeQuery·p0.9999: 29896.999 ms/op
                 executeQuery·p1.00:   29896.999 ms/op

Iteration   2: 29896.999 ms/op
                 executeQuery·p0.00:   29896.999 ms/op
                 executeQuery·p0.50:   29896.999 ms/op
                 executeQuery·p0.90:   29896.999 ms/op
                 executeQuery·p0.95:   29896.999 ms/op
                 executeQuery·p0.99:   29896.999 ms/op
                 executeQuery·p0.999:  29896.999 ms/op
                 executeQuery·p0.9999: 29896.999 ms/op
                 executeQuery·p1.00:   29896.999 ms/op

Iteration   3: 29896.999 ms/op
                 executeQuery·p0.00:   29896.999 ms/op
                 executeQuery·p0.50:   29896.999 ms/op
                 executeQuery·p0.90:   29896.999 ms/op
                 executeQuery·p0.95:   29896.999 ms/op
                 executeQuery·p0.99:   29896.999 ms/op
                 executeQuery·p0.999:  29896.999 ms/op
                 executeQuery·p0.9999: 29896.999 ms/op
                 executeQuery·p1.00:   29896.999 ms/op

Iteration   4: 29896.999 ms/op
                 executeQuery·p0.00:   29896.999 ms/op
                 executeQuery·p0.50:   29896.999 ms/op
                 executeQuery·p0.90:   29896.999 ms/op
                 executeQuery·p0.95:   29896.999 ms/op
                 executeQuery·p0.99:   29896.999 ms/op
                 executeQuery·p0.999:  29896.999 ms/op
                 executeQuery·p0.9999: 29896.999 ms/op
                 executeQuery·p1.00:   29896.999 ms/op

Iteration   5: 29896.999 ms/op
                 executeQuery·p0.00:   29896.999 ms/op
                 executeQuery·p0.50:   29896.999 ms/op
                 executeQuery·p0.90:   29896.999 ms/op
                 executeQuery·p0.95:   29896.999 ms/op
                 executeQuery·p0.99:   29896.999 ms/op
                 executeQuery·p0.999:  29896.999 ms/op
                 executeQuery·p0.9999: 29896.999 ms/op
                 executeQuery·p1.00:   29896.999 ms/op


# Run progress: 69.30% complete, ETA 06:41:39
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 27715.961 ms/op
# Warmup Iteration   2: 29729.227 ms/op
# Warmup Iteration   3: 29595.009 ms/op
# Warmup Iteration   4: 29595.009 ms/op
# Warmup Iteration   5: 29561.455 ms/op
Iteration   1: 29595.009 ms/op
                 executeQuery·p0.00:   29595.009 ms/op
                 executeQuery·p0.50:   29595.009 ms/op
                 executeQuery·p0.90:   29595.009 ms/op
                 executeQuery·p0.95:   29595.009 ms/op
                 executeQuery·p0.99:   29595.009 ms/op
                 executeQuery·p0.999:  29595.009 ms/op
                 executeQuery·p0.9999: 29595.009 ms/op
                 executeQuery·p1.00:   29595.009 ms/op

Iteration   2: 29595.009 ms/op
                 executeQuery·p0.00:   29595.009 ms/op
                 executeQuery·p0.50:   29595.009 ms/op
                 executeQuery·p0.90:   29595.009 ms/op
                 executeQuery·p0.95:   29595.009 ms/op
                 executeQuery·p0.99:   29595.009 ms/op
                 executeQuery·p0.999:  29595.009 ms/op
                 executeQuery·p0.9999: 29595.009 ms/op
                 executeQuery·p1.00:   29595.009 ms/op

Iteration   3: 29595.009 ms/op
                 executeQuery·p0.00:   29595.009 ms/op
                 executeQuery·p0.50:   29595.009 ms/op
                 executeQuery·p0.90:   29595.009 ms/op
                 executeQuery·p0.95:   29595.009 ms/op
                 executeQuery·p0.99:   29595.009 ms/op
                 executeQuery·p0.999:  29595.009 ms/op
                 executeQuery·p0.9999: 29595.009 ms/op
                 executeQuery·p1.00:   29595.009 ms/op

Iteration   4: 29561.455 ms/op
                 executeQuery·p0.00:   29561.455 ms/op
                 executeQuery·p0.50:   29561.455 ms/op
                 executeQuery·p0.90:   29561.455 ms/op
                 executeQuery·p0.95:   29561.455 ms/op
                 executeQuery·p0.99:   29561.455 ms/op
                 executeQuery·p0.999:  29561.455 ms/op
                 executeQuery·p0.9999: 29561.455 ms/op
                 executeQuery·p1.00:   29561.455 ms/op

Iteration   5: 29595.009 ms/op
                 executeQuery·p0.00:   29595.009 ms/op
                 executeQuery·p0.50:   29595.009 ms/op
                 executeQuery·p0.90:   29595.009 ms/op
                 executeQuery·p0.95:   29595.009 ms/op
                 executeQuery·p0.99:   29595.009 ms/op
                 executeQuery·p0.999:  29595.009 ms/op
                 executeQuery·p0.9999: 29595.009 ms/op
                 executeQuery·p1.00:   29595.009 ms/op



Result "benchmarks.join_query_hard_coded.VectorisedNonSimd.executeQuery":
  N = 10
  mean =  29742.649 ±(99.9%) 246.443 ms/op

  Histogram, ms/op:
    [29500.000, 29525.000) = 0 
    [29525.000, 29550.000) = 0 
    [29550.000, 29575.000) = 1 
    [29575.000, 29600.000) = 4 
    [29600.000, 29625.000) = 0 
    [29625.000, 29650.000) = 0 
    [29650.000, 29675.000) = 0 
    [29675.000, 29700.000) = 0 
    [29700.000, 29725.000) = 0 
    [29725.000, 29750.000) = 0 
    [29750.000, 29775.000) = 0 
    [29775.000, 29800.000) = 0 
    [29800.000, 29825.000) = 0 
    [29825.000, 29850.000) = 0 
    [29850.000, 29875.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  29561.455 ms/op
     p(50.0000) =  29746.004 ms/op
     p(90.0000) =  29896.999 ms/op
     p(95.0000) =  29896.999 ms/op
     p(99.0000) =  29896.999 ms/op
     p(99.9000) =  29896.999 ms/op
     p(99.9900) =  29896.999 ms/op
     p(99.9990) =  29896.999 ms/op
     p(99.9999) =  29896.999 ms/op
    p(100.0000) =  29896.999 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8)

# Run progress: 69.62% complete, ETA 06:38:01
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2446.957 ±(99.9%) 376.108 ms/op
# Warmup Iteration   2: 2426.824 ±(99.9%) 27.025 ms/op
# Warmup Iteration   3: 2416.758 ±(99.9%) 13.513 ms/op
# Warmup Iteration   4: 2415.919 ±(99.9%) 0.001 ms/op
# Warmup Iteration   5: 2415.919 ±(99.9%) 0.001 ms/op
Iteration   1: 2415.080 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2411.725 ms/op
                 executeQuery·p0.50:   2415.919 ms/op
                 executeQuery·p0.90:   2415.919 ms/op
                 executeQuery·p0.95:   2415.919 ms/op
                 executeQuery·p0.99:   2415.919 ms/op
                 executeQuery·p0.999:  2415.919 ms/op
                 executeQuery·p0.9999: 2415.919 ms/op
                 executeQuery·p1.00:   2415.919 ms/op

Iteration   2: 2415.919 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2415.919 ms/op
                 executeQuery·p0.50:   2415.919 ms/op
                 executeQuery·p0.90:   2415.919 ms/op
                 executeQuery·p0.95:   2415.919 ms/op
                 executeQuery·p0.99:   2415.919 ms/op
                 executeQuery·p0.999:  2415.919 ms/op
                 executeQuery·p0.9999: 2415.919 ms/op
                 executeQuery·p1.00:   2415.919 ms/op

Iteration   3: 2420.113 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2420.113 ms/op
                 executeQuery·p0.50:   2420.113 ms/op
                 executeQuery·p0.90:   2420.113 ms/op
                 executeQuery·p0.95:   2420.113 ms/op
                 executeQuery·p0.99:   2420.113 ms/op
                 executeQuery·p0.999:  2420.113 ms/op
                 executeQuery·p0.9999: 2420.113 ms/op
                 executeQuery·p1.00:   2420.113 ms/op

Iteration   4: 2425.147 ±(99.9%) 17.692 ms/op
                 executeQuery·p0.00:   2420.113 ms/op
                 executeQuery·p0.50:   2424.308 ms/op
                 executeQuery·p0.90:   2432.696 ms/op
                 executeQuery·p0.95:   2432.696 ms/op
                 executeQuery·p0.99:   2432.696 ms/op
                 executeQuery·p0.999:  2432.696 ms/op
                 executeQuery·p0.9999: 2432.696 ms/op
                 executeQuery·p1.00:   2432.696 ms/op

Iteration   5: 2422.630 ±(99.9%) 8.846 ms/op
                 executeQuery·p0.00:   2420.113 ms/op
                 executeQuery·p0.50:   2424.308 ms/op
                 executeQuery·p0.90:   2424.308 ms/op
                 executeQuery·p0.95:   2424.308 ms/op
                 executeQuery·p0.99:   2424.308 ms/op
                 executeQuery·p0.999:  2424.308 ms/op
                 executeQuery·p0.9999: 2424.308 ms/op
                 executeQuery·p1.00:   2424.308 ms/op


# Run progress: 69.94% complete, ETA 06:33:00
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2463.734 ±(99.9%) 338.512 ms/op
# Warmup Iteration   2: 2394.948 ±(99.9%) 32.302 ms/op
# Warmup Iteration   3: 2384.042 ±(99.9%) 8.846 ms/op
# Warmup Iteration   4: 2382.365 ±(99.9%) 0.001 ms/op
# Warmup Iteration   5: 2382.365 ±(99.9%) 0.001 ms/op
Iteration   1: 2382.365 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2382.365 ms/op
                 executeQuery·p0.50:   2382.365 ms/op
                 executeQuery·p0.90:   2382.365 ms/op
                 executeQuery·p0.95:   2382.365 ms/op
                 executeQuery·p0.99:   2382.365 ms/op
                 executeQuery·p0.999:  2382.365 ms/op
                 executeQuery·p0.9999: 2382.365 ms/op
                 executeQuery·p1.00:   2382.365 ms/op

Iteration   2: 2381.526 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2378.170 ms/op
                 executeQuery·p0.50:   2382.365 ms/op
                 executeQuery·p0.90:   2382.365 ms/op
                 executeQuery·p0.95:   2382.365 ms/op
                 executeQuery·p0.99:   2382.365 ms/op
                 executeQuery·p0.999:  2382.365 ms/op
                 executeQuery·p0.9999: 2382.365 ms/op
                 executeQuery·p1.00:   2382.365 ms/op

Iteration   3: 2386.559 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2386.559 ms/op
                 executeQuery·p0.50:   2386.559 ms/op
                 executeQuery·p0.90:   2386.559 ms/op
                 executeQuery·p0.95:   2386.559 ms/op
                 executeQuery·p0.99:   2386.559 ms/op
                 executeQuery·p0.999:  2386.559 ms/op
                 executeQuery·p0.9999: 2386.559 ms/op
                 executeQuery·p1.00:   2386.559 ms/op

Iteration   4: 2389.914 ±(99.9%) 13.513 ms/op
                 executeQuery·p0.00:   2386.559 ms/op
                 executeQuery·p0.50:   2390.753 ms/op
                 executeQuery·p0.90:   2394.948 ms/op
                 executeQuery·p0.95:   2394.948 ms/op
                 executeQuery·p0.99:   2394.948 ms/op
                 executeQuery·p0.999:  2394.948 ms/op
                 executeQuery·p0.9999: 2394.948 ms/op
                 executeQuery·p1.00:   2394.948 ms/op

Iteration   5: 2387.398 ±(99.9%) 7.223 ms/op
                 executeQuery·p0.00:   2386.559 ms/op
                 executeQuery·p0.50:   2386.559 ms/op
                 executeQuery·p0.90:   2390.753 ms/op
                 executeQuery·p0.95:   2390.753 ms/op
                 executeQuery·p0.99:   2390.753 ms/op
                 executeQuery·p0.999:  2390.753 ms/op
                 executeQuery·p0.9999: 2390.753 ms/op
                 executeQuery·p1.00:   2390.753 ms/op



Result "benchmarks.join_query_hard_coded.VectorisedSimd.executeQuery":
  N = 50
  mean =   2402.665 ±(99.9%) 8.793 ms/op

  Histogram, ms/op:
    [2370.000, 2375.000) = 0 
    [2375.000, 2380.000) = 1 
    [2380.000, 2385.000) = 9 
    [2385.000, 2390.000) = 11 
    [2390.000, 2395.000) = 4 
    [2395.000, 2400.000) = 0 
    [2400.000, 2405.000) = 0 
    [2405.000, 2410.000) = 0 
    [2410.000, 2415.000) = 1 
    [2415.000, 2420.000) = 9 
    [2420.000, 2425.000) = 14 
    [2425.000, 2430.000) = 0 
    [2430.000, 2435.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2378.170 ms/op
     p(50.0000) =   2403.336 ms/op
     p(90.0000) =   2424.308 ms/op
     p(95.0000) =   2424.308 ms/op
     p(99.0000) =   2432.696 ms/op
     p(99.9000) =   2432.696 ms/op
     p(99.9900) =   2432.696 ms/op
     p(99.9990) =   2432.696 ms/op
     p(99.9999) =   2432.696 ms/op
    p(100.0000) =   2432.696 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.join_query_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tableFilePath = /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8)

# Run progress: 70.25% complete, ETA 06:27:59
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 29024.584 ms/op
# Warmup Iteration   2: 30031.217 ms/op
# Warmup Iteration   3: 29561.455 ms/op
# Warmup Iteration   4: 29561.455 ms/op
# Warmup Iteration   5: 29561.455 ms/op
Iteration   1: 29527.900 ms/op
                 executeQuery·p0.00:   29527.900 ms/op
                 executeQuery·p0.50:   29527.900 ms/op
                 executeQuery·p0.90:   29527.900 ms/op
                 executeQuery·p0.95:   29527.900 ms/op
                 executeQuery·p0.99:   29527.900 ms/op
                 executeQuery·p0.999:  29527.900 ms/op
                 executeQuery·p0.9999: 29527.900 ms/op
                 executeQuery·p1.00:   29527.900 ms/op

Iteration   2: 29561.455 ms/op
                 executeQuery·p0.00:   29561.455 ms/op
                 executeQuery·p0.50:   29561.455 ms/op
                 executeQuery·p0.90:   29561.455 ms/op
                 executeQuery·p0.95:   29561.455 ms/op
                 executeQuery·p0.99:   29561.455 ms/op
                 executeQuery·p0.999:  29561.455 ms/op
                 executeQuery·p0.9999: 29561.455 ms/op
                 executeQuery·p1.00:   29561.455 ms/op

Iteration   3: 29595.009 ms/op
                 executeQuery·p0.00:   29595.009 ms/op
                 executeQuery·p0.50:   29595.009 ms/op
                 executeQuery·p0.90:   29595.009 ms/op
                 executeQuery·p0.95:   29595.009 ms/op
                 executeQuery·p0.99:   29595.009 ms/op
                 executeQuery·p0.999:  29595.009 ms/op
                 executeQuery·p0.9999: 29595.009 ms/op
                 executeQuery·p1.00:   29595.009 ms/op

Iteration   4: 29561.455 ms/op
                 executeQuery·p0.00:   29561.455 ms/op
                 executeQuery·p0.50:   29561.455 ms/op
                 executeQuery·p0.90:   29561.455 ms/op
                 executeQuery·p0.95:   29561.455 ms/op
                 executeQuery·p0.99:   29561.455 ms/op
                 executeQuery·p0.999:  29561.455 ms/op
                 executeQuery·p0.9999: 29561.455 ms/op
                 executeQuery·p1.00:   29561.455 ms/op

Iteration   5: 29527.900 ms/op
                 executeQuery·p0.00:   29527.900 ms/op
                 executeQuery·p0.50:   29527.900 ms/op
                 executeQuery·p0.90:   29527.900 ms/op
                 executeQuery·p0.95:   29527.900 ms/op
                 executeQuery·p0.99:   29527.900 ms/op
                 executeQuery·p0.999:  29527.900 ms/op
                 executeQuery·p0.9999: 29527.900 ms/op
                 executeQuery·p1.00:   29527.900 ms/op


# Run progress: 70.57% complete, ETA 06:24:22
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 29360.128 ms/op
# Warmup Iteration   2: 30534.533 ms/op
# Warmup Iteration   3: 29964.108 ms/op
# Warmup Iteration   4: 29930.553 ms/op
# Warmup Iteration   5: 29930.553 ms/op
Iteration   1: 29964.108 ms/op
                 executeQuery·p0.00:   29964.108 ms/op
                 executeQuery·p0.50:   29964.108 ms/op
                 executeQuery·p0.90:   29964.108 ms/op
                 executeQuery·p0.95:   29964.108 ms/op
                 executeQuery·p0.99:   29964.108 ms/op
                 executeQuery·p0.999:  29964.108 ms/op
                 executeQuery·p0.9999: 29964.108 ms/op
                 executeQuery·p1.00:   29964.108 ms/op

Iteration   2: 29930.553 ms/op
                 executeQuery·p0.00:   29930.553 ms/op
                 executeQuery·p0.50:   29930.553 ms/op
                 executeQuery·p0.90:   29930.553 ms/op
                 executeQuery·p0.95:   29930.553 ms/op
                 executeQuery·p0.99:   29930.553 ms/op
                 executeQuery·p0.999:  29930.553 ms/op
                 executeQuery·p0.9999: 29930.553 ms/op
                 executeQuery·p1.00:   29930.553 ms/op

Iteration   3: 30064.771 ms/op
                 executeQuery·p0.00:   30064.771 ms/op
                 executeQuery·p0.50:   30064.771 ms/op
                 executeQuery·p0.90:   30064.771 ms/op
                 executeQuery·p0.95:   30064.771 ms/op
                 executeQuery·p0.99:   30064.771 ms/op
                 executeQuery·p0.999:  30064.771 ms/op
                 executeQuery·p0.9999: 30064.771 ms/op
                 executeQuery·p1.00:   30064.771 ms/op

Iteration   4: 29930.553 ms/op
                 executeQuery·p0.00:   29930.553 ms/op
                 executeQuery·p0.50:   29930.553 ms/op
                 executeQuery·p0.90:   29930.553 ms/op
                 executeQuery·p0.95:   29930.553 ms/op
                 executeQuery·p0.99:   29930.553 ms/op
                 executeQuery·p0.999:  29930.553 ms/op
                 executeQuery·p0.9999: 29930.553 ms/op
                 executeQuery·p1.00:   29930.553 ms/op

Iteration   5: 29930.553 ms/op
                 executeQuery·p0.00:   29930.553 ms/op
                 executeQuery·p0.50:   29930.553 ms/op
                 executeQuery·p0.90:   29930.553 ms/op
                 executeQuery·p0.95:   29930.553 ms/op
                 executeQuery·p0.99:   29930.553 ms/op
                 executeQuery·p0.999:  29930.553 ms/op
                 executeQuery·p0.9999: 29930.553 ms/op
                 executeQuery·p1.00:   29930.553 ms/op



Result "benchmarks.join_query_hard_coded.VectorisedSimd.executeQuery":
  N = 10
  mean =  29759.426 ±(99.9%) 332.613 ms/op

  Histogram, ms/op:
    [29500.000, 29550.000) = 2 
    [29550.000, 29600.000) = 3 
    [29600.000, 29650.000) = 0 
    [29650.000, 29700.000) = 0 
    [29700.000, 29750.000) = 0 
    [29750.000, 29800.000) = 0 
    [29800.000, 29850.000) = 0 
    [29850.000, 29900.000) = 0 
    [29900.000, 29950.000) = 3 
    [29950.000, 30000.000) = 1 
    [30000.000, 30050.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =  29527.900 ms/op
     p(50.0000) =  29762.781 ms/op
     p(90.0000) =  30054.705 ms/op
     p(95.0000) =  30064.771 ms/op
     p(99.0000) =  30064.771 ms/op
     p(99.9000) =  30064.771 ms/op
     p(99.9900) =  30064.771 ms/op
     p(99.9990) =  30064.771 ms/op
     p(99.9999) =  30064.771 ms/op
    p(100.0000) =  30064.771 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 70.89% complete, ETA 06:20:45
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 495.059 ±(99.9%) 577.968 ms/op
# Warmup Iteration   2: 356.875 ±(99.9%) 33.135 ms/op
# Warmup Iteration   3: 405.645 ±(99.9%) 51.966 ms/op
# Warmup Iteration   4: 442.827 ±(99.9%) 29.833 ms/op
# Warmup Iteration   5: 348.265 ±(99.9%) 15.480 ms/op
Iteration   1: 347.989 ±(99.9%) 14.264 ms/op
                 executeQuery·p0.00:   326.631 ms/op
                 executeQuery·p0.50:   347.603 ms/op
                 executeQuery·p0.90:   374.866 ms/op
                 executeQuery·p0.95:   385.876 ms/op
                 executeQuery·p0.99:   385.876 ms/op
                 executeQuery·p0.999:  385.876 ms/op
                 executeQuery·p0.9999: 385.876 ms/op
                 executeQuery·p1.00:   385.876 ms/op

Iteration   2: 333.447 ±(99.9%) 5.599 ms/op
                 executeQuery·p0.00:   327.156 ms/op
                 executeQuery·p0.50:   331.350 ms/op
                 executeQuery·p0.90:   344.982 ms/op
                 executeQuery·p0.95:   352.846 ms/op
                 executeQuery·p0.99:   352.846 ms/op
                 executeQuery·p0.999:  352.846 ms/op
                 executeQuery·p0.9999: 352.846 ms/op
                 executeQuery·p1.00:   352.846 ms/op

Iteration   3: 327.470 ±(99.9%) 1.967 ms/op
                 executeQuery·p0.00:   325.059 ms/op
                 executeQuery·p0.50:   326.631 ms/op
                 executeQuery·p0.90:   332.713 ms/op
                 executeQuery·p0.95:   332.923 ms/op
                 executeQuery·p0.99:   332.923 ms/op
                 executeQuery·p0.999:  332.923 ms/op
                 executeQuery·p0.9999: 332.923 ms/op
                 executeQuery·p1.00:   332.923 ms/op

Iteration   4: 330.964 ±(99.9%) 4.984 ms/op
                 executeQuery·p0.00:   325.059 ms/op
                 executeQuery·p0.50:   330.301 ms/op
                 executeQuery·p0.90:   340.263 ms/op
                 executeQuery·p0.95:   347.603 ms/op
                 executeQuery·p0.99:   347.603 ms/op
                 executeQuery·p0.999:  347.603 ms/op
                 executeQuery·p0.9999: 347.603 ms/op
                 executeQuery·p1.00:   347.603 ms/op

Iteration   5: 330.412 ±(99.9%) 6.588 ms/op
                 executeQuery·p0.00:   325.059 ms/op
                 executeQuery·p0.50:   327.156 ms/op
                 executeQuery·p0.90:   340.787 ms/op
                 executeQuery·p0.95:   354.943 ms/op
                 executeQuery·p0.99:   354.943 ms/op
                 executeQuery·p0.999:  354.943 ms/op
                 executeQuery·p0.9999: 354.943 ms/op
                 executeQuery·p1.00:   354.943 ms/op


# Run progress: 71.20% complete, ETA 06:15:38
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 420.591 ±(99.9%) 201.496 ms/op
# Warmup Iteration   2: 364.118 ±(99.9%) 39.323 ms/op
# Warmup Iteration   3: 425.558 ±(99.9%) 51.742 ms/op
# Warmup Iteration   4: 442.237 ±(99.9%) 40.305 ms/op
# Warmup Iteration   5: 357.344 ±(99.9%) 11.721 ms/op
Iteration   1: 347.106 ±(99.9%) 17.750 ms/op
                 executeQuery·p0.00:   325.059 ms/op
                 executeQuery·p0.50:   345.506 ms/op
                 executeQuery·p0.90:   382.730 ms/op
                 executeQuery·p0.95:   390.070 ms/op
                 executeQuery·p0.99:   390.070 ms/op
                 executeQuery·p0.999:  390.070 ms/op
                 executeQuery·p0.9999: 390.070 ms/op
                 executeQuery·p1.00:   390.070 ms/op

Iteration   2: 347.465 ±(99.9%) 11.718 ms/op
                 executeQuery·p0.00:   326.631 ms/op
                 executeQuery·p0.50:   346.554 ms/op
                 executeQuery·p0.90:   362.283 ms/op
                 executeQuery·p0.95:   370.147 ms/op
                 executeQuery·p0.99:   370.147 ms/op
                 executeQuery·p0.999:  370.147 ms/op
                 executeQuery·p0.9999: 370.147 ms/op
                 executeQuery·p1.00:   370.147 ms/op

Iteration   3: 336.179 ±(99.9%) 10.207 ms/op
                 executeQuery·p0.00:   324.534 ms/op
                 executeQuery·p0.50:   330.301 ms/op
                 executeQuery·p0.90:   350.224 ms/op
                 executeQuery·p0.95:   354.419 ms/op
                 executeQuery·p0.99:   354.419 ms/op
                 executeQuery·p0.999:  354.419 ms/op
                 executeQuery·p0.9999: 354.419 ms/op
                 executeQuery·p1.00:   354.419 ms/op

Iteration   4: 340.180 ±(99.9%) 15.021 ms/op
                 executeQuery·p0.00:   325.583 ms/op
                 executeQuery·p0.50:   342.360 ms/op
                 executeQuery·p0.90:   361.234 ms/op
                 executeQuery·p0.95:   390.595 ms/op
                 executeQuery·p0.99:   390.595 ms/op
                 executeQuery·p0.999:  390.595 ms/op
                 executeQuery·p0.9999: 390.595 ms/op
                 executeQuery·p1.00:   390.595 ms/op

Iteration   5: 337.697 ±(99.9%) 7.991 ms/op
                 executeQuery·p0.00:   324.534 ms/op
                 executeQuery·p0.50:   341.836 ms/op
                 executeQuery·p0.90:   348.127 ms/op
                 executeQuery·p0.95:   348.652 ms/op
                 executeQuery·p0.99:   348.652 ms/op
                 executeQuery·p0.999:  348.652 ms/op
                 executeQuery·p0.9999: 348.652 ms/op
                 executeQuery·p1.00:   348.652 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 191
  mean =    337.836 ±(99.9%) 3.311 ms/op

  Histogram, ms/op:
    [320.000, 325.000) = 4 
    [325.000, 330.000) = 75 
    [330.000, 335.000) = 32 
    [335.000, 340.000) = 7 
    [340.000, 345.000) = 16 
    [345.000, 350.000) = 24 
    [350.000, 355.000) = 13 
    [355.000, 360.000) = 8 
    [360.000, 365.000) = 5 
    [365.000, 370.000) = 0 
    [370.000, 375.000) = 3 
    [375.000, 380.000) = 0 
    [380.000, 385.000) = 1 
    [385.000, 390.000) = 1 
    [390.000, 395.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =    324.534 ms/op
     p(50.0000) =    331.874 ms/op
     p(90.0000) =    355.992 ms/op
     p(95.0000) =    361.968 ms/op
     p(99.0000) =    390.112 ms/op
     p(99.9000) =    390.595 ms/op
     p(99.9900) =    390.595 ms/op
     p(99.9990) =    390.595 ms/op
     p(99.9999) =    390.595 ms/op
    p(100.0000) =    390.595 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 71.52% complete, ETA 06:10:33
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 17683.186 ms/op
# Warmup Iteration   2: 4487.905 ms/op
# Warmup Iteration   3: 4697.620 ms/op
# Warmup Iteration   4: 4148.167 ms/op
# Warmup Iteration   5: 4273.996 ms/op
Iteration   1: 4089.446 ms/op
                 executeQuery·p0.00:   4089.446 ms/op
                 executeQuery·p0.50:   4089.446 ms/op
                 executeQuery·p0.90:   4089.446 ms/op
                 executeQuery·p0.95:   4089.446 ms/op
                 executeQuery·p0.99:   4089.446 ms/op
                 executeQuery·p0.999:  4089.446 ms/op
                 executeQuery·p0.9999: 4089.446 ms/op
                 executeQuery·p1.00:   4089.446 ms/op

Iteration   2: 4395.631 ms/op
                 executeQuery·p0.00:   4395.631 ms/op
                 executeQuery·p0.50:   4395.631 ms/op
                 executeQuery·p0.90:   4395.631 ms/op
                 executeQuery·p0.95:   4395.631 ms/op
                 executeQuery·p0.99:   4395.631 ms/op
                 executeQuery·p0.999:  4395.631 ms/op
                 executeQuery·p0.9999: 4395.631 ms/op
                 executeQuery·p1.00:   4395.631 ms/op

Iteration   3: 4240.441 ms/op
                 executeQuery·p0.00:   4240.441 ms/op
                 executeQuery·p0.50:   4240.441 ms/op
                 executeQuery·p0.90:   4240.441 ms/op
                 executeQuery·p0.95:   4240.441 ms/op
                 executeQuery·p0.99:   4240.441 ms/op
                 executeQuery·p0.999:  4240.441 ms/op
                 executeQuery·p0.9999: 4240.441 ms/op
                 executeQuery·p1.00:   4240.441 ms/op

Iteration   4: 4555.014 ms/op
                 executeQuery·p0.00:   4555.014 ms/op
                 executeQuery·p0.50:   4555.014 ms/op
                 executeQuery·p0.90:   4555.014 ms/op
                 executeQuery·p0.95:   4555.014 ms/op
                 executeQuery·p0.99:   4555.014 ms/op
                 executeQuery·p0.999:  4555.014 ms/op
                 executeQuery·p0.9999: 4555.014 ms/op
                 executeQuery·p1.00:   4555.014 ms/op

Iteration   5: 4815.061 ms/op
                 executeQuery·p0.00:   4815.061 ms/op
                 executeQuery·p0.50:   4815.061 ms/op
                 executeQuery·p0.90:   4815.061 ms/op
                 executeQuery·p0.95:   4815.061 ms/op
                 executeQuery·p0.99:   4815.061 ms/op
                 executeQuery·p0.999:  4815.061 ms/op
                 executeQuery·p0.9999: 4815.061 ms/op
                 executeQuery·p1.00:   4815.061 ms/op


# Run progress: 71.84% complete, ETA 06:07:40
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 7541.359 ms/op
# Warmup Iteration   2: 4504.682 ms/op
# Warmup Iteration   3: 4521.460 ms/op
# Warmup Iteration   4: 4123.001 ms/op
# Warmup Iteration   5: 4131.389 ms/op
Iteration   1: 4085.252 ms/op
                 executeQuery·p0.00:   4085.252 ms/op
                 executeQuery·p0.50:   4085.252 ms/op
                 executeQuery·p0.90:   4085.252 ms/op
                 executeQuery·p0.95:   4085.252 ms/op
                 executeQuery·p0.99:   4085.252 ms/op
                 executeQuery·p0.999:  4085.252 ms/op
                 executeQuery·p0.9999: 4085.252 ms/op
                 executeQuery·p1.00:   4085.252 ms/op

Iteration   2: 4185.915 ms/op
                 executeQuery·p0.00:   4185.915 ms/op
                 executeQuery·p0.50:   4185.915 ms/op
                 executeQuery·p0.90:   4185.915 ms/op
                 executeQuery·p0.95:   4185.915 ms/op
                 executeQuery·p0.99:   4185.915 ms/op
                 executeQuery·p0.999:  4185.915 ms/op
                 executeQuery·p0.9999: 4185.915 ms/op
                 executeQuery·p1.00:   4185.915 ms/op

Iteration   3: 4055.892 ms/op
                 executeQuery·p0.00:   4055.892 ms/op
                 executeQuery·p0.50:   4055.892 ms/op
                 executeQuery·p0.90:   4055.892 ms/op
                 executeQuery·p0.95:   4055.892 ms/op
                 executeQuery·p0.99:   4055.892 ms/op
                 executeQuery·p0.999:  4055.892 ms/op
                 executeQuery·p0.9999: 4055.892 ms/op
                 executeQuery·p1.00:   4055.892 ms/op

Iteration   4: 4378.853 ms/op
                 executeQuery·p0.00:   4378.853 ms/op
                 executeQuery·p0.50:   4378.853 ms/op
                 executeQuery·p0.90:   4378.853 ms/op
                 executeQuery·p0.95:   4378.853 ms/op
                 executeQuery·p0.99:   4378.853 ms/op
                 executeQuery·p0.999:  4378.853 ms/op
                 executeQuery·p0.9999: 4378.853 ms/op
                 executeQuery·p1.00:   4378.853 ms/op

Iteration   5: 4806.672 ms/op
                 executeQuery·p0.00:   4806.672 ms/op
                 executeQuery·p0.50:   4806.672 ms/op
                 executeQuery·p0.90:   4806.672 ms/op
                 executeQuery·p0.95:   4806.672 ms/op
                 executeQuery·p0.99:   4806.672 ms/op
                 executeQuery·p0.999:  4806.672 ms/op
                 executeQuery·p0.9999: 4806.672 ms/op
                 executeQuery·p1.00:   4806.672 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =   4360.818 ±(99.9%) 431.170 ms/op

  Histogram, ms/op:
    [4000.000, 4050.000) = 0 
    [4050.000, 4100.000) = 3 
    [4100.000, 4150.000) = 0 
    [4150.000, 4200.000) = 1 
    [4200.000, 4250.000) = 1 
    [4250.000, 4300.000) = 0 
    [4300.000, 4350.000) = 0 
    [4350.000, 4400.000) = 2 
    [4400.000, 4450.000) = 0 
    [4450.000, 4500.000) = 0 
    [4500.000, 4550.000) = 0 
    [4550.000, 4600.000) = 1 
    [4600.000, 4650.000) = 0 
    [4650.000, 4700.000) = 0 
    [4700.000, 4750.000) = 0 
    [4750.000, 4800.000) = 0 
    [4800.000, 4850.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =   4055.892 ms/op
     p(50.0000) =   4309.647 ms/op
     p(90.0000) =   4814.222 ms/op
     p(95.0000) =   4815.061 ms/op
     p(99.0000) =   4815.061 ms/op
     p(99.9000) =   4815.061 ms/op
     p(99.9900) =   4815.061 ms/op
     p(99.9990) =   4815.061 ms/op
     p(99.9999) =   4815.061 ms/op
    p(100.0000) =   4815.061 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 72.15% complete, ETA 06:04:39
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 403.581 ±(99.9%) 251.556 ms/op
# Warmup Iteration   2: 321.251 ±(99.9%) 18.028 ms/op
# Warmup Iteration   3: 319.540 ±(99.9%) 23.002 ms/op
# Warmup Iteration   4: 368.312 ±(99.9%) 11.754 ms/op
# Warmup Iteration   5: 356.661 ±(99.9%) 9.887 ms/op
Iteration   1: 331.598 ±(99.9%) 19.107 ms/op
                 executeQuery·p0.00:   301.466 ms/op
                 executeQuery·p0.50:   326.631 ms/op
                 executeQuery·p0.90:   365.953 ms/op
                 executeQuery·p0.95:   374.866 ms/op
                 executeQuery·p0.99:   374.866 ms/op
                 executeQuery·p0.999:  374.866 ms/op
                 executeQuery·p0.9999: 374.866 ms/op
                 executeQuery·p1.00:   374.866 ms/op

Iteration   2: 324.589 ±(99.9%) 7.508 ms/op
                 executeQuery·p0.00:   304.611 ms/op
                 executeQuery·p0.50:   325.059 ms/op
                 executeQuery·p0.90:   335.020 ms/op
                 executeQuery·p0.95:   335.544 ms/op
                 executeQuery·p0.99:   335.544 ms/op
                 executeQuery·p0.999:  335.544 ms/op
                 executeQuery·p0.9999: 335.544 ms/op
                 executeQuery·p1.00:   335.544 ms/op

Iteration   3: 323.817 ±(99.9%) 8.372 ms/op
                 executeQuery·p0.00:   307.757 ms/op
                 executeQuery·p0.50:   324.010 ms/op
                 executeQuery·p0.90:   341.311 ms/op
                 executeQuery·p0.95:   345.506 ms/op
                 executeQuery·p0.99:   345.506 ms/op
                 executeQuery·p0.999:  345.506 ms/op
                 executeQuery·p0.9999: 345.506 ms/op
                 executeQuery·p1.00:   345.506 ms/op

Iteration   4: 324.534 ±(99.9%) 6.228 ms/op
                 executeQuery·p0.00:   308.281 ms/op
                 executeQuery·p0.50:   324.010 ms/op
                 executeQuery·p0.90:   332.399 ms/op
                 executeQuery·p0.95:   339.739 ms/op
                 executeQuery·p0.99:   339.739 ms/op
                 executeQuery·p0.999:  339.739 ms/op
                 executeQuery·p0.9999: 339.739 ms/op
                 executeQuery·p1.00:   339.739 ms/op

Iteration   5: 332.454 ±(99.9%) 12.876 ms/op
                 executeQuery·p0.00:   310.378 ms/op
                 executeQuery·p0.50:   332.399 ms/op
                 executeQuery·p0.90:   343.409 ms/op
                 executeQuery·p0.95:   375.914 ms/op
                 executeQuery·p0.99:   375.914 ms/op
                 executeQuery·p0.999:  375.914 ms/op
                 executeQuery·p0.9999: 375.914 ms/op
                 executeQuery·p1.00:   375.914 ms/op


# Run progress: 72.47% complete, ETA 05:59:36
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 397.733 ±(99.9%) 212.229 ms/op
# Warmup Iteration   2: 324.692 ±(99.9%) 11.764 ms/op
# Warmup Iteration   3: 331.957 ±(99.9%) 19.339 ms/op
# Warmup Iteration   4: 372.477 ±(99.9%) 10.905 ms/op
# Warmup Iteration   5: 382.963 ±(99.9%) 8.059 ms/op
Iteration   1: 332.564 ±(99.9%) 26.630 ms/op
                 executeQuery·p0.00:   300.941 ms/op
                 executeQuery·p0.50:   319.816 ms/op
                 executeQuery·p0.90:   382.730 ms/op
                 executeQuery·p0.95:   395.837 ms/op
                 executeQuery·p0.99:   395.837 ms/op
                 executeQuery·p0.999:  395.837 ms/op
                 executeQuery·p0.9999: 395.837 ms/op
                 executeQuery·p1.00:   395.837 ms/op

Iteration   2: 324.456 ±(99.9%) 6.255 ms/op
                 executeQuery·p0.00:   313.000 ms/op
                 executeQuery·p0.50:   324.534 ms/op
                 executeQuery·p0.90:   335.702 ms/op
                 executeQuery·p0.95:   337.563 ms/op
                 executeQuery·p0.99:   337.641 ms/op
                 executeQuery·p0.999:  337.641 ms/op
                 executeQuery·p0.9999: 337.641 ms/op
                 executeQuery·p1.00:   337.641 ms/op

Iteration   3: 323.958 ±(99.9%) 10.419 ms/op
                 executeQuery·p0.00:   305.136 ms/op
                 executeQuery·p0.50:   322.175 ms/op
                 executeQuery·p0.90:   346.817 ms/op
                 executeQuery·p0.95:   352.112 ms/op
                 executeQuery·p0.99:   352.322 ms/op
                 executeQuery·p0.999:  352.322 ms/op
                 executeQuery·p0.9999: 352.322 ms/op
                 executeQuery·p1.00:   352.322 ms/op

Iteration   4: 321.546 ±(99.9%) 6.546 ms/op
                 executeQuery·p0.00:   309.330 ms/op
                 executeQuery·p0.50:   321.913 ms/op
                 executeQuery·p0.90:   330.773 ms/op
                 executeQuery·p0.95:   334.810 ms/op
                 executeQuery·p0.99:   335.020 ms/op
                 executeQuery·p0.999:  335.020 ms/op
                 executeQuery·p0.9999: 335.020 ms/op
                 executeQuery·p1.00:   335.020 ms/op

Iteration   5: 324.980 ±(99.9%) 10.552 ms/op
                 executeQuery·p0.00:   300.941 ms/op
                 executeQuery·p0.50:   325.059 ms/op
                 executeQuery·p0.90:   341.311 ms/op
                 executeQuery·p0.95:   350.277 ms/op
                 executeQuery·p0.99:   350.749 ms/op
                 executeQuery·p0.999:  350.749 ms/op
                 executeQuery·p0.9999: 350.749 ms/op
                 executeQuery·p1.00:   350.749 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery":
  N = 194
  mean =    326.394 ±(99.9%) 3.529 ms/op

  Histogram, ms/op:
    [300.000, 310.000) = 15 
    [310.000, 320.000) = 48 
    [320.000, 330.000) = 77 
    [330.000, 340.000) = 31 
    [340.000, 350.000) = 11 
    [350.000, 360.000) = 4 
    [360.000, 370.000) = 2 
    [370.000, 380.000) = 3 
    [380.000, 390.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =    300.941 ms/op
     p(50.0000) =    324.272 ms/op
     p(90.0000) =    341.311 ms/op
     p(95.0000) =    355.729 ms/op
     p(99.0000) =    383.386 ms/op
     p(99.9000) =    395.837 ms/op
     p(99.9900) =    395.837 ms/op
     p(99.9990) =    395.837 ms/op
     p(99.9999) =    395.837 ms/op
    p(100.0000) =    395.837 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 72.78% complete, ETA 05:54:35
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 7105.151 ms/op
# Warmup Iteration   2: 3636.462 ms/op
# Warmup Iteration   3: 3951.034 ms/op
# Warmup Iteration   4: 3615.490 ms/op
# Warmup Iteration   5: 3808.428 ms/op
Iteration   1: 3871.343 ms/op
                 executeQuery·p0.00:   3871.343 ms/op
                 executeQuery·p0.50:   3871.343 ms/op
                 executeQuery·p0.90:   3871.343 ms/op
                 executeQuery·p0.95:   3871.343 ms/op
                 executeQuery·p0.99:   3871.343 ms/op
                 executeQuery·p0.999:  3871.343 ms/op
                 executeQuery·p0.9999: 3871.343 ms/op
                 executeQuery·p1.00:   3871.343 ms/op

Iteration   2: 3577.741 ms/op
                 executeQuery·p0.00:   3577.741 ms/op
                 executeQuery·p0.50:   3577.741 ms/op
                 executeQuery·p0.90:   3577.741 ms/op
                 executeQuery·p0.95:   3577.741 ms/op
                 executeQuery·p0.99:   3577.741 ms/op
                 executeQuery·p0.999:  3577.741 ms/op
                 executeQuery·p0.9999: 3577.741 ms/op
                 executeQuery·p1.00:   3577.741 ms/op

Iteration   3: 3795.845 ms/op
                 executeQuery·p0.00:   3795.845 ms/op
                 executeQuery·p0.50:   3795.845 ms/op
                 executeQuery·p0.90:   3795.845 ms/op
                 executeQuery·p0.95:   3795.845 ms/op
                 executeQuery·p0.99:   3795.845 ms/op
                 executeQuery·p0.999:  3795.845 ms/op
                 executeQuery·p0.9999: 3795.845 ms/op
                 executeQuery·p1.00:   3795.845 ms/op

Iteration   4: 3808.428 ms/op
                 executeQuery·p0.00:   3808.428 ms/op
                 executeQuery·p0.50:   3808.428 ms/op
                 executeQuery·p0.90:   3808.428 ms/op
                 executeQuery·p0.95:   3808.428 ms/op
                 executeQuery·p0.99:   3808.428 ms/op
                 executeQuery·p0.999:  3808.428 ms/op
                 executeQuery·p0.9999: 3808.428 ms/op
                 executeQuery·p1.00:   3808.428 ms/op

Iteration   5: 3628.073 ms/op
                 executeQuery·p0.00:   3628.073 ms/op
                 executeQuery·p0.50:   3628.073 ms/op
                 executeQuery·p0.90:   3628.073 ms/op
                 executeQuery·p0.95:   3628.073 ms/op
                 executeQuery·p0.99:   3628.073 ms/op
                 executeQuery·p0.999:  3628.073 ms/op
                 executeQuery·p0.9999: 3628.073 ms/op
                 executeQuery·p1.00:   3628.073 ms/op


# Run progress: 73.10% complete, ETA 05:51:28
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 7180.648 ms/op
# Warmup Iteration   2: 3703.570 ms/op
# Warmup Iteration   3: 3594.519 ms/op
# Warmup Iteration   4: 3963.617 ms/op
# Warmup Iteration   5: 3523.215 ms/op
Iteration   1: 3867.148 ms/op
                 executeQuery·p0.00:   3867.148 ms/op
                 executeQuery·p0.50:   3867.148 ms/op
                 executeQuery·p0.90:   3867.148 ms/op
                 executeQuery·p0.95:   3867.148 ms/op
                 executeQuery·p0.99:   3867.148 ms/op
                 executeQuery·p0.999:  3867.148 ms/op
                 executeQuery·p0.9999: 3867.148 ms/op
                 executeQuery·p1.00:   3867.148 ms/op

Iteration   2: 3846.177 ms/op
                 executeQuery·p0.00:   3846.177 ms/op
                 executeQuery·p0.50:   3846.177 ms/op
                 executeQuery·p0.90:   3846.177 ms/op
                 executeQuery·p0.95:   3846.177 ms/op
                 executeQuery·p0.99:   3846.177 ms/op
                 executeQuery·p0.999:  3846.177 ms/op
                 executeQuery·p0.9999: 3846.177 ms/op
                 executeQuery·p1.00:   3846.177 ms/op

Iteration   3: 3586.130 ms/op
                 executeQuery·p0.00:   3586.130 ms/op
                 executeQuery·p0.50:   3586.130 ms/op
                 executeQuery·p0.90:   3586.130 ms/op
                 executeQuery·p0.95:   3586.130 ms/op
                 executeQuery·p0.99:   3586.130 ms/op
                 executeQuery·p0.999:  3586.130 ms/op
                 executeQuery·p0.9999: 3586.130 ms/op
                 executeQuery·p1.00:   3586.130 ms/op

Iteration   4: 3594.519 ms/op
                 executeQuery·p0.00:   3594.519 ms/op
                 executeQuery·p0.50:   3594.519 ms/op
                 executeQuery·p0.90:   3594.519 ms/op
                 executeQuery·p0.95:   3594.519 ms/op
                 executeQuery·p0.99:   3594.519 ms/op
                 executeQuery·p0.999:  3594.519 ms/op
                 executeQuery·p0.9999: 3594.519 ms/op
                 executeQuery·p1.00:   3594.519 ms/op

Iteration   5: 3598.713 ms/op
                 executeQuery·p0.00:   3598.713 ms/op
                 executeQuery·p0.50:   3598.713 ms/op
                 executeQuery·p0.90:   3598.713 ms/op
                 executeQuery·p0.95:   3598.713 ms/op
                 executeQuery·p0.99:   3598.713 ms/op
                 executeQuery·p0.999:  3598.713 ms/op
                 executeQuery·p0.9999: 3598.713 ms/op
                 executeQuery·p1.00:   3598.713 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery":
  N = 10
  mean =   3717.412 ±(99.9%) 195.861 ms/op

  Histogram, ms/op:
    [3500.000, 3525.000) = 0 
    [3525.000, 3550.000) = 0 
    [3550.000, 3575.000) = 0 
    [3575.000, 3600.000) = 4 
    [3600.000, 3625.000) = 0 
    [3625.000, 3650.000) = 1 
    [3650.000, 3675.000) = 0 
    [3675.000, 3700.000) = 0 
    [3700.000, 3725.000) = 0 
    [3725.000, 3750.000) = 0 
    [3750.000, 3775.000) = 0 
    [3775.000, 3800.000) = 1 
    [3800.000, 3825.000) = 1 
    [3825.000, 3850.000) = 1 
    [3850.000, 3875.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =   3577.741 ms/op
     p(50.0000) =   3711.959 ms/op
     p(90.0000) =   3870.923 ms/op
     p(95.0000) =   3871.343 ms/op
     p(99.0000) =   3871.343 ms/op
     p(99.9000) =   3871.343 ms/op
     p(99.9900) =   3871.343 ms/op
     p(99.9990) =   3871.343 ms/op
     p(99.9999) =   3871.343 ms/op
    p(100.0000) =   3871.343 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 73.42% complete, ETA 05:49:22
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 421.286 ±(99.9%) 236.092 ms/op
# Warmup Iteration   2: 320.285 ±(99.9%) 11.485 ms/op
# Warmup Iteration   3: 324.286 ±(99.9%) 18.526 ms/op
# Warmup Iteration   4: 383.625 ±(99.9%) 3.541 ms/op
# Warmup Iteration   5: 381.743 ±(99.9%) 3.979 ms/op
Iteration   1: 343.380 ±(99.9%) 29.584 ms/op
                 executeQuery·p0.00:   306.184 ms/op
                 executeQuery·p0.50:   328.729 ms/op
                 executeQuery·p0.90:   382.258 ms/op
                 executeQuery·p0.95:   382.730 ms/op
                 executeQuery·p0.99:   382.730 ms/op
                 executeQuery·p0.999:  382.730 ms/op
                 executeQuery·p0.9999: 382.730 ms/op
                 executeQuery·p1.00:   382.730 ms/op

Iteration   2: 314.821 ±(99.9%) 3.460 ms/op
                 executeQuery·p0.00:   310.378 ms/op
                 executeQuery·p0.50:   313.524 ms/op
                 executeQuery·p0.90:   321.389 ms/op
                 executeQuery·p0.95:   326.107 ms/op
                 executeQuery·p0.99:   326.107 ms/op
                 executeQuery·p0.999:  326.107 ms/op
                 executeQuery·p0.9999: 326.107 ms/op
                 executeQuery·p1.00:   326.107 ms/op

Iteration   3: 314.214 ±(99.9%) 6.765 ms/op
                 executeQuery·p0.00:   306.184 ms/op
                 executeQuery·p0.50:   313.000 ms/op
                 executeQuery·p0.90:   324.534 ms/op
                 executeQuery·p0.95:   340.787 ms/op
                 executeQuery·p0.99:   340.787 ms/op
                 executeQuery·p0.999:  340.787 ms/op
                 executeQuery·p0.9999: 340.787 ms/op
                 executeQuery·p1.00:   340.787 ms/op

Iteration   4: 310.562 ±(99.9%) 4.992 ms/op
                 executeQuery·p0.00:   306.184 ms/op
                 executeQuery·p0.50:   308.806 ms/op
                 executeQuery·p0.90:   318.610 ms/op
                 executeQuery·p0.95:   330.223 ms/op
                 executeQuery·p0.99:   330.826 ms/op
                 executeQuery·p0.999:  330.826 ms/op
                 executeQuery·p0.9999: 330.826 ms/op
                 executeQuery·p1.00:   330.826 ms/op

Iteration   5: 311.008 ±(99.9%) 3.811 ms/op
                 executeQuery·p0.00:   306.184 ms/op
                 executeQuery·p0.50:   309.330 ms/op
                 executeQuery·p0.90:   319.291 ms/op
                 executeQuery·p0.95:   319.789 ms/op
                 executeQuery·p0.99:   319.816 ms/op
                 executeQuery·p0.999:  319.816 ms/op
                 executeQuery·p0.9999: 319.816 ms/op
                 executeQuery·p1.00:   319.816 ms/op


# Run progress: 73.73% complete, ETA 05:44:20
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 412.240 ±(99.9%) 217.476 ms/op
# Warmup Iteration   2: 323.458 ±(99.9%) 11.928 ms/op
# Warmup Iteration   3: 326.631 ±(99.9%) 19.878 ms/op
# Warmup Iteration   4: 389.700 ±(99.9%) 3.182 ms/op
# Warmup Iteration   5: 390.194 ±(99.9%) 2.805 ms/op
Iteration   1: 341.341 ±(99.9%) 34.596 ms/op
                 executeQuery·p0.00:   311.427 ms/op
                 executeQuery·p0.50:   318.767 ms/op
                 executeQuery·p0.90:   395.995 ms/op
                 executeQuery·p0.95:   397.410 ms/op
                 executeQuery·p0.99:   397.410 ms/op
                 executeQuery·p0.999:  397.410 ms/op
                 executeQuery·p0.9999: 397.410 ms/op
                 executeQuery·p1.00:   397.410 ms/op

Iteration   2: 326.576 ±(99.9%) 5.200 ms/op
                 executeQuery·p0.00:   318.767 ms/op
                 executeQuery·p0.50:   324.534 ms/op
                 executeQuery·p0.90:   334.496 ms/op
                 executeQuery·p0.95:   341.311 ms/op
                 executeQuery·p0.99:   341.311 ms/op
                 executeQuery·p0.999:  341.311 ms/op
                 executeQuery·p0.9999: 341.311 ms/op
                 executeQuery·p1.00:   341.311 ms/op

Iteration   3: 323.982 ±(99.9%) 6.887 ms/op
                 executeQuery·p0.00:   310.378 ms/op
                 executeQuery·p0.50:   322.961 ms/op
                 executeQuery·p0.90:   335.020 ms/op
                 executeQuery·p0.95:   340.263 ms/op
                 executeQuery·p0.99:   340.263 ms/op
                 executeQuery·p0.999:  340.263 ms/op
                 executeQuery·p0.9999: 340.263 ms/op
                 executeQuery·p1.00:   340.263 ms/op

Iteration   4: 318.408 ±(99.9%) 5.676 ms/op
                 executeQuery·p0.00:   310.378 ms/op
                 executeQuery·p0.50:   317.194 ms/op
                 executeQuery·p0.90:   327.156 ms/op
                 executeQuery·p0.95:   336.593 ms/op
                 executeQuery·p0.99:   336.593 ms/op
                 executeQuery·p0.999:  336.593 ms/op
                 executeQuery·p0.9999: 336.593 ms/op
                 executeQuery·p1.00:   336.593 ms/op

Iteration   5: 317.525 ±(99.9%) 6.428 ms/op
                 executeQuery·p0.00:   309.330 ms/op
                 executeQuery·p0.50:   314.049 ms/op
                 executeQuery·p0.90:   330.301 ms/op
                 executeQuery·p0.95:   333.971 ms/op
                 executeQuery·p0.99:   333.971 ms/op
                 executeQuery·p0.999:  333.971 ms/op
                 executeQuery·p0.9999: 333.971 ms/op
                 executeQuery·p1.00:   333.971 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 190
  mean =    321.849 ±(99.9%) 4.638 ms/op

  Histogram, ms/op:
    [300.000, 310.000) = 36 
    [310.000, 320.000) = 86 
    [320.000, 330.000) = 40 
    [330.000, 340.000) = 12 
    [340.000, 350.000) = 3 
    [350.000, 360.000) = 0 
    [360.000, 370.000) = 0 
    [370.000, 380.000) = 2 
    [380.000, 390.000) = 7 

  Percentiles, ms/op:
      p(0.0000) =    306.184 ms/op
     p(50.0000) =    315.621 ms/op
     p(90.0000) =    334.968 ms/op
     p(95.0000) =    381.682 ms/op
     p(99.0000) =    395.979 ms/op
     p(99.9000) =    397.410 ms/op
     p(99.9900) =    397.410 ms/op
     p(99.9990) =    397.410 ms/op
     p(99.9999) =    397.410 ms/op
    p(100.0000) =    397.410 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 74.05% complete, ETA 05:39:20
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 7289.700 ms/op
# Warmup Iteration   2: 3623.879 ms/op
# Warmup Iteration   3: 3791.651 ms/op
# Warmup Iteration   4: 3741.319 ms/op
# Warmup Iteration   5: 3749.708 ms/op
Iteration   1: 3900.703 ms/op
                 executeQuery·p0.00:   3900.703 ms/op
                 executeQuery·p0.50:   3900.703 ms/op
                 executeQuery·p0.90:   3900.703 ms/op
                 executeQuery·p0.95:   3900.703 ms/op
                 executeQuery·p0.99:   3900.703 ms/op
                 executeQuery·p0.999:  3900.703 ms/op
                 executeQuery·p0.9999: 3900.703 ms/op
                 executeQuery·p1.00:   3900.703 ms/op

Iteration   2: 3825.205 ms/op
                 executeQuery·p0.00:   3825.205 ms/op
                 executeQuery·p0.50:   3825.205 ms/op
                 executeQuery·p0.90:   3825.205 ms/op
                 executeQuery·p0.95:   3825.205 ms/op
                 executeQuery·p0.99:   3825.205 ms/op
                 executeQuery·p0.999:  3825.205 ms/op
                 executeQuery·p0.9999: 3825.205 ms/op
                 executeQuery·p1.00:   3825.205 ms/op

Iteration   3: 3674.210 ms/op
                 executeQuery·p0.00:   3674.210 ms/op
                 executeQuery·p0.50:   3674.210 ms/op
                 executeQuery·p0.90:   3674.210 ms/op
                 executeQuery·p0.95:   3674.210 ms/op
                 executeQuery·p0.99:   3674.210 ms/op
                 executeQuery·p0.999:  3674.210 ms/op
                 executeQuery·p0.9999: 3674.210 ms/op
                 executeQuery·p1.00:   3674.210 ms/op

Iteration   4: 3690.988 ms/op
                 executeQuery·p0.00:   3690.988 ms/op
                 executeQuery·p0.50:   3690.988 ms/op
                 executeQuery·p0.90:   3690.988 ms/op
                 executeQuery·p0.95:   3690.988 ms/op
                 executeQuery·p0.99:   3690.988 ms/op
                 executeQuery·p0.999:  3690.988 ms/op
                 executeQuery·p0.9999: 3690.988 ms/op
                 executeQuery·p1.00:   3690.988 ms/op

Iteration   5: 3711.959 ms/op
                 executeQuery·p0.00:   3711.959 ms/op
                 executeQuery·p0.50:   3711.959 ms/op
                 executeQuery·p0.90:   3711.959 ms/op
                 executeQuery·p0.95:   3711.959 ms/op
                 executeQuery·p0.99:   3711.959 ms/op
                 executeQuery·p0.999:  3711.959 ms/op
                 executeQuery·p0.9999: 3711.959 ms/op
                 executeQuery·p1.00:   3711.959 ms/op


# Run progress: 74.37% complete, ETA 05:36:28
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 7398.752 ms/op
# Warmup Iteration   2: 3703.570 ms/op
# Warmup Iteration   3: 3825.205 ms/op
# Warmup Iteration   4: 3892.314 ms/op
# Warmup Iteration   5: 3854.565 ms/op
Iteration   1: 3724.542 ms/op
                 executeQuery·p0.00:   3724.542 ms/op
                 executeQuery·p0.50:   3724.542 ms/op
                 executeQuery·p0.90:   3724.542 ms/op
                 executeQuery·p0.95:   3724.542 ms/op
                 executeQuery·p0.99:   3724.542 ms/op
                 executeQuery·p0.999:  3724.542 ms/op
                 executeQuery·p0.9999: 3724.542 ms/op
                 executeQuery·p1.00:   3724.542 ms/op

Iteration   2: 3930.063 ms/op
                 executeQuery·p0.00:   3930.063 ms/op
                 executeQuery·p0.50:   3930.063 ms/op
                 executeQuery·p0.90:   3930.063 ms/op
                 executeQuery·p0.95:   3930.063 ms/op
                 executeQuery·p0.99:   3930.063 ms/op
                 executeQuery·p0.999:  3930.063 ms/op
                 executeQuery·p0.9999: 3930.063 ms/op
                 executeQuery·p1.00:   3930.063 ms/op

Iteration   3: 3779.068 ms/op
                 executeQuery·p0.00:   3779.068 ms/op
                 executeQuery·p0.50:   3779.068 ms/op
                 executeQuery·p0.90:   3779.068 ms/op
                 executeQuery·p0.95:   3779.068 ms/op
                 executeQuery·p0.99:   3779.068 ms/op
                 executeQuery·p0.999:  3779.068 ms/op
                 executeQuery·p0.9999: 3779.068 ms/op
                 executeQuery·p1.00:   3779.068 ms/op

Iteration   4: 3821.011 ms/op
                 executeQuery·p0.00:   3821.011 ms/op
                 executeQuery·p0.50:   3821.011 ms/op
                 executeQuery·p0.90:   3821.011 ms/op
                 executeQuery·p0.95:   3821.011 ms/op
                 executeQuery·p0.99:   3821.011 ms/op
                 executeQuery·p0.999:  3821.011 ms/op
                 executeQuery·p0.9999: 3821.011 ms/op
                 executeQuery·p1.00:   3821.011 ms/op

Iteration   5: 3930.063 ms/op
                 executeQuery·p0.00:   3930.063 ms/op
                 executeQuery·p0.50:   3930.063 ms/op
                 executeQuery·p0.90:   3930.063 ms/op
                 executeQuery·p0.95:   3930.063 ms/op
                 executeQuery·p0.99:   3930.063 ms/op
                 executeQuery·p0.999:  3930.063 ms/op
                 executeQuery·p0.9999: 3930.063 ms/op
                 executeQuery·p1.00:   3930.063 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 10
  mean =   3798.781 ±(99.9%) 148.324 ms/op

  Histogram, ms/op:
    [3600.000, 3625.000) = 0 
    [3625.000, 3650.000) = 0 
    [3650.000, 3675.000) = 1 
    [3675.000, 3700.000) = 1 
    [3700.000, 3725.000) = 2 
    [3725.000, 3750.000) = 0 
    [3750.000, 3775.000) = 0 
    [3775.000, 3800.000) = 1 
    [3800.000, 3825.000) = 1 
    [3825.000, 3850.000) = 1 
    [3850.000, 3875.000) = 0 
    [3875.000, 3900.000) = 0 
    [3900.000, 3925.000) = 1 
    [3925.000, 3950.000) = 2 
    [3950.000, 3975.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   3674.210 ms/op
     p(50.0000) =   3800.039 ms/op
     p(90.0000) =   3930.063 ms/op
     p(95.0000) =   3930.063 ms/op
     p(99.0000) =   3930.063 ms/op
     p(99.9000) =   3930.063 ms/op
     p(99.9900) =   3930.063 ms/op
     p(99.9990) =   3930.063 ms/op
     p(99.9999) =   3930.063 ms/op
    p(100.0000) =   3930.063 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 74.68% complete, ETA 05:33:14
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 566.946 ±(99.9%) 453.151 ms/op
# Warmup Iteration   2: 448.659 ±(99.9%) 18.040 ms/op
# Warmup Iteration   3: 467.350 ±(99.9%) 50.743 ms/op
# Warmup Iteration   4: 553.423 ±(99.9%) 9.844 ms/op
# Warmup Iteration   5: 552.749 ±(99.9%) 9.642 ms/op
Iteration   1: 451.248 ±(99.9%) 31.264 ms/op
                 executeQuery·p0.00:   421.528 ms/op
                 executeQuery·p0.50:   444.596 ms/op
                 executeQuery·p0.90:   513.645 ms/op
                 executeQuery·p0.95:   546.308 ms/op
                 executeQuery·p0.99:   546.308 ms/op
                 executeQuery·p0.999:  546.308 ms/op
                 executeQuery·p0.9999: 546.308 ms/op
                 executeQuery·p1.00:   546.308 ms/op

Iteration   2: 445.153 ±(99.9%) 12.372 ms/op
                 executeQuery·p0.00:   424.673 ms/op
                 executeQuery·p0.50:   444.858 ms/op
                 executeQuery·p0.90:   461.216 ms/op
                 executeQuery·p0.95:   464.519 ms/op
                 executeQuery·p0.99:   464.519 ms/op
                 executeQuery·p0.999:  464.519 ms/op
                 executeQuery·p0.9999: 464.519 ms/op
                 executeQuery·p1.00:   464.519 ms/op

Iteration   3: 434.307 ±(99.9%) 10.869 ms/op
                 executeQuery·p0.00:   423.100 ms/op
                 executeQuery·p0.50:   430.965 ms/op
                 executeQuery·p0.90:   452.828 ms/op
                 executeQuery·p0.95:   459.801 ms/op
                 executeQuery·p0.99:   459.801 ms/op
                 executeQuery·p0.999:  459.801 ms/op
                 executeQuery·p0.9999: 459.801 ms/op
                 executeQuery·p1.00:   459.801 ms/op

Iteration   4: 430.834 ±(99.9%) 5.814 ms/op
                 executeQuery·p0.00:   424.673 ms/op
                 executeQuery·p0.50:   429.130 ms/op
                 executeQuery·p0.90:   441.083 ms/op
                 executeQuery·p0.95:   441.450 ms/op
                 executeQuery·p0.99:   441.450 ms/op
                 executeQuery·p0.999:  441.450 ms/op
                 executeQuery·p0.9999: 441.450 ms/op
                 executeQuery·p1.00:   441.450 ms/op

Iteration   5: 433.750 ±(99.9%) 7.656 ms/op
                 executeQuery·p0.00:   422.052 ms/op
                 executeQuery·p0.50:   433.062 ms/op
                 executeQuery·p0.90:   445.121 ms/op
                 executeQuery·p0.95:   452.461 ms/op
                 executeQuery·p0.99:   452.461 ms/op
                 executeQuery·p0.999:  452.461 ms/op
                 executeQuery·p0.9999: 452.461 ms/op
                 executeQuery·p1.00:   452.461 ms/op


# Run progress: 75.00% complete, ETA 05:28:16
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 579.052 ±(99.9%) 430.369 ms/op
# Warmup Iteration   2: 421.036 ±(99.9%) 14.057 ms/op
# Warmup Iteration   3: 442.860 ±(99.9%) 42.271 ms/op
# Warmup Iteration   4: 520.880 ±(99.9%) 19.519 ms/op
# Warmup Iteration   5: 523.539 ±(99.9%) 4.995 ms/op
Iteration   1: 432.275 ±(99.9%) 41.435 ms/op
                 executeQuery·p0.00:   405.275 ms/op
                 executeQuery·p0.50:   419.693 ms/op
                 executeQuery·p0.90:   528.954 ms/op
                 executeQuery·p0.95:   548.405 ms/op
                 executeQuery·p0.99:   548.405 ms/op
                 executeQuery·p0.999:  548.405 ms/op
                 executeQuery·p0.9999: 548.405 ms/op
                 executeQuery·p1.00:   548.405 ms/op

Iteration   2: 436.306 ±(99.9%) 15.687 ms/op
                 executeQuery·p0.00:   414.188 ms/op
                 executeQuery·p0.50:   429.392 ms/op
                 executeQuery·p0.90:   458.385 ms/op
                 executeQuery·p0.95:   458.752 ms/op
                 executeQuery·p0.99:   458.752 ms/op
                 executeQuery·p0.999:  458.752 ms/op
                 executeQuery·p0.9999: 458.752 ms/op
                 executeQuery·p1.00:   458.752 ms/op

Iteration   3: 432.669 ±(99.9%) 16.392 ms/op
                 executeQuery·p0.00:   410.518 ms/op
                 executeQuery·p0.50:   434.897 ms/op
                 executeQuery·p0.90:   458.647 ms/op
                 executeQuery·p0.95:   460.849 ms/op
                 executeQuery·p0.99:   460.849 ms/op
                 executeQuery·p0.999:  460.849 ms/op
                 executeQuery·p0.9999: 460.849 ms/op
                 executeQuery·p1.00:   460.849 ms/op

Iteration   4: 425.558 ±(99.9%) 12.742 ms/op
                 executeQuery·p0.00:   409.469 ms/op
                 executeQuery·p0.50:   424.673 ms/op
                 executeQuery·p0.90:   439.511 ms/op
                 executeQuery·p0.95:   439.878 ms/op
                 executeQuery·p0.99:   439.878 ms/op
                 executeQuery·p0.999:  439.878 ms/op
                 executeQuery·p0.9999: 439.878 ms/op
                 executeQuery·p1.00:   439.878 ms/op

Iteration   5: 429.228 ±(99.9%) 15.634 ms/op
                 executeQuery·p0.00:   414.712 ms/op
                 executeQuery·p0.50:   425.722 ms/op
                 executeQuery·p0.90:   451.517 ms/op
                 executeQuery·p0.95:   467.665 ms/op
                 executeQuery·p0.99:   467.665 ms/op
                 executeQuery·p0.999:  467.665 ms/op
                 executeQuery·p0.9999: 467.665 ms/op
                 executeQuery·p1.00:   467.665 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery":
  N = 160
  mean =    435.133 ±(99.9%) 5.398 ms/op

  Histogram, ms/op:
    [400.000, 412.500) = 6 
    [412.500, 425.000) = 44 
    [425.000, 437.500) = 51 
    [437.500, 450.000) = 37 
    [450.000, 462.500) = 16 
    [462.500, 475.000) = 2 
    [475.000, 487.500) = 0 
    [487.500, 500.000) = 1 
    [500.000, 512.500) = 0 
    [512.500, 525.000) = 1 
    [525.000, 537.500) = 0 
    [537.500, 550.000) = 2 
    [550.000, 562.500) = 0 
    [562.500, 575.000) = 0 
    [575.000, 587.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =    405.275 ms/op
     p(50.0000) =    432.538 ms/op
     p(90.0000) =    454.558 ms/op
     p(95.0000) =    459.801 ms/op
     p(99.0000) =    547.126 ms/op
     p(99.9000) =    548.405 ms/op
     p(99.9900) =    548.405 ms/op
     p(99.9990) =    548.405 ms/op
     p(99.9999) =    548.405 ms/op
    p(100.0000) =    548.405 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 75.32% complete, ETA 05:23:19
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 8791.261 ms/op
# Warmup Iteration   2: 4840.227 ms/op
# Warmup Iteration   3: 4605.346 ms/op
# Warmup Iteration   4: 5477.761 ms/op
# Warmup Iteration   5: 4798.284 ms/op
Iteration   1: 4815.061 ms/op
                 executeQuery·p0.00:   4815.061 ms/op
                 executeQuery·p0.50:   4815.061 ms/op
                 executeQuery·p0.90:   4815.061 ms/op
                 executeQuery·p0.95:   4815.061 ms/op
                 executeQuery·p0.99:   4815.061 ms/op
                 executeQuery·p0.999:  4815.061 ms/op
                 executeQuery·p0.9999: 4815.061 ms/op
                 executeQuery·p1.00:   4815.061 ms/op

Iteration   2: 4798.284 ms/op
                 executeQuery·p0.00:   4798.284 ms/op
                 executeQuery·p0.50:   4798.284 ms/op
                 executeQuery·p0.90:   4798.284 ms/op
                 executeQuery·p0.95:   4798.284 ms/op
                 executeQuery·p0.99:   4798.284 ms/op
                 executeQuery·p0.999:  4798.284 ms/op
                 executeQuery·p0.9999: 4798.284 ms/op
                 executeQuery·p1.00:   4798.284 ms/op

Iteration   3: 4789.895 ms/op
                 executeQuery·p0.00:   4789.895 ms/op
                 executeQuery·p0.50:   4789.895 ms/op
                 executeQuery·p0.90:   4789.895 ms/op
                 executeQuery·p0.95:   4789.895 ms/op
                 executeQuery·p0.99:   4789.895 ms/op
                 executeQuery·p0.999:  4789.895 ms/op
                 executeQuery·p0.9999: 4789.895 ms/op
                 executeQuery·p1.00:   4789.895 ms/op

Iteration   4: 4798.284 ms/op
                 executeQuery·p0.00:   4798.284 ms/op
                 executeQuery·p0.50:   4798.284 ms/op
                 executeQuery·p0.90:   4798.284 ms/op
                 executeQuery·p0.95:   4798.284 ms/op
                 executeQuery·p0.99:   4798.284 ms/op
                 executeQuery·p0.999:  4798.284 ms/op
                 executeQuery·p0.9999: 4798.284 ms/op
                 executeQuery·p1.00:   4798.284 ms/op

Iteration   5: 4563.403 ms/op
                 executeQuery·p0.00:   4563.403 ms/op
                 executeQuery·p0.50:   4563.403 ms/op
                 executeQuery·p0.90:   4563.403 ms/op
                 executeQuery·p0.95:   4563.403 ms/op
                 executeQuery·p0.99:   4563.403 ms/op
                 executeQuery·p0.999:  4563.403 ms/op
                 executeQuery·p0.9999: 4563.403 ms/op
                 executeQuery·p1.00:   4563.403 ms/op


# Run progress: 75.63% complete, ETA 05:20:07
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 8925.479 ms/op
# Warmup Iteration   2: 4697.620 ms/op
# Warmup Iteration   3: 4580.180 ms/op
# Warmup Iteration   4: 4882.170 ms/op
# Warmup Iteration   5: 4882.170 ms/op
Iteration   1: 4798.284 ms/op
                 executeQuery·p0.00:   4798.284 ms/op
                 executeQuery·p0.50:   4798.284 ms/op
                 executeQuery·p0.90:   4798.284 ms/op
                 executeQuery·p0.95:   4798.284 ms/op
                 executeQuery·p0.99:   4798.284 ms/op
                 executeQuery·p0.999:  4798.284 ms/op
                 executeQuery·p0.9999: 4798.284 ms/op
                 executeQuery·p1.00:   4798.284 ms/op

Iteration   2: 4815.061 ms/op
                 executeQuery·p0.00:   4815.061 ms/op
                 executeQuery·p0.50:   4815.061 ms/op
                 executeQuery·p0.90:   4815.061 ms/op
                 executeQuery·p0.95:   4815.061 ms/op
                 executeQuery·p0.99:   4815.061 ms/op
                 executeQuery·p0.999:  4815.061 ms/op
                 executeQuery·p0.9999: 4815.061 ms/op
                 executeQuery·p1.00:   4815.061 ms/op

Iteration   3: 4756.341 ms/op
                 executeQuery·p0.00:   4756.341 ms/op
                 executeQuery·p0.50:   4756.341 ms/op
                 executeQuery·p0.90:   4756.341 ms/op
                 executeQuery·p0.95:   4756.341 ms/op
                 executeQuery·p0.99:   4756.341 ms/op
                 executeQuery·p0.999:  4756.341 ms/op
                 executeQuery·p0.9999: 4756.341 ms/op
                 executeQuery·p1.00:   4756.341 ms/op

Iteration   4: 4815.061 ms/op
                 executeQuery·p0.00:   4815.061 ms/op
                 executeQuery·p0.50:   4815.061 ms/op
                 executeQuery·p0.90:   4815.061 ms/op
                 executeQuery·p0.95:   4815.061 ms/op
                 executeQuery·p0.99:   4815.061 ms/op
                 executeQuery·p0.999:  4815.061 ms/op
                 executeQuery·p0.9999: 4815.061 ms/op
                 executeQuery·p1.00:   4815.061 ms/op

Iteration   5: 4924.113 ms/op
                 executeQuery·p0.00:   4924.113 ms/op
                 executeQuery·p0.50:   4924.113 ms/op
                 executeQuery·p0.90:   4924.113 ms/op
                 executeQuery·p0.95:   4924.113 ms/op
                 executeQuery·p0.99:   4924.113 ms/op
                 executeQuery·p0.999:  4924.113 ms/op
                 executeQuery·p0.9999: 4924.113 ms/op
                 executeQuery·p1.00:   4924.113 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery":
  N = 10
  mean =   4787.379 ±(99.9%) 135.681 ms/op

  Histogram, ms/op:
    [4500.000, 4550.000) = 0 
    [4550.000, 4600.000) = 1 
    [4600.000, 4650.000) = 0 
    [4650.000, 4700.000) = 0 
    [4700.000, 4750.000) = 0 
    [4750.000, 4800.000) = 5 
    [4800.000, 4850.000) = 3 
    [4850.000, 4900.000) = 0 
    [4900.000, 4950.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4563.403 ms/op
     p(50.0000) =   4798.284 ms/op
     p(90.0000) =   4913.208 ms/op
     p(95.0000) =   4924.113 ms/op
     p(99.0000) =   4924.113 ms/op
     p(99.9000) =   4924.113 ms/op
     p(99.9900) =   4924.113 ms/op
     p(99.9990) =   4924.113 ms/op
     p(99.9999) =   4924.113 ms/op
    p(100.0000) =   4924.113 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 75.95% complete, ETA 05:16:52
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 625.213 ±(99.9%) 425.042 ms/op
# Warmup Iteration   2: 463.700 ±(99.9%) 14.804 ms/op
# Warmup Iteration   3: 469.098 ±(99.9%) 35.515 ms/op
# Warmup Iteration   4: 557.618 ±(99.9%) 16.768 ms/op
# Warmup Iteration   5: 558.666 ±(99.9%) 10.303 ms/op
Iteration   1: 480.912 ±(99.9%) 46.552 ms/op
                 executeQuery·p0.00:   444.072 ms/op
                 executeQuery·p0.50:   465.568 ms/op
                 executeQuery·p0.90:   569.796 ms/op
                 executeQuery·p0.95:   570.425 ms/op
                 executeQuery·p0.99:   570.425 ms/op
                 executeQuery·p0.999:  570.425 ms/op
                 executeQuery·p0.9999: 570.425 ms/op
                 executeQuery·p1.00:   570.425 ms/op

Iteration   2: 466.977 ±(99.9%) 12.118 ms/op
                 executeQuery·p0.00:   452.985 ms/op
                 executeQuery·p0.50:   467.141 ms/op
                 executeQuery·p0.90:   487.535 ms/op
                 executeQuery·p0.95:   488.636 ms/op
                 executeQuery·p0.99:   488.636 ms/op
                 executeQuery·p0.999:  488.636 ms/op
                 executeQuery·p0.9999: 488.636 ms/op
                 executeQuery·p1.00:   488.636 ms/op

Iteration   3: 460.456 ±(99.9%) 14.359 ms/op
                 executeQuery·p0.00:   440.926 ms/op
                 executeQuery·p0.50:   459.014 ms/op
                 executeQuery·p0.90:   480.353 ms/op
                 executeQuery·p0.95:   481.821 ms/op
                 executeQuery·p0.99:   481.821 ms/op
                 executeQuery·p0.999:  481.821 ms/op
                 executeQuery·p0.9999: 481.821 ms/op
                 executeQuery·p1.00:   481.821 ms/op

Iteration   4: 449.642 ±(99.9%) 8.579 ms/op
                 executeQuery·p0.00:   441.450 ms/op
                 executeQuery·p0.50:   445.645 ms/op
                 executeQuery·p0.90:   461.531 ms/op
                 executeQuery·p0.95:   461.898 ms/op
                 executeQuery·p0.99:   461.898 ms/op
                 executeQuery·p0.999:  461.898 ms/op
                 executeQuery·p0.9999: 461.898 ms/op
                 executeQuery·p1.00:   461.898 ms/op

Iteration   5: 450.888 ±(99.9%) 11.272 ms/op
                 executeQuery·p0.00:   435.159 ms/op
                 executeQuery·p0.50:   449.577 ms/op
                 executeQuery·p0.90:   465.673 ms/op
                 executeQuery·p0.95:   478.151 ms/op
                 executeQuery·p0.99:   478.151 ms/op
                 executeQuery·p0.999:  478.151 ms/op
                 executeQuery·p0.9999: 478.151 ms/op
                 executeQuery·p1.00:   478.151 ms/op


# Run progress: 76.27% complete, ETA 05:11:57
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 588.585 ±(99.9%) 372.181 ms/op
# Warmup Iteration   2: 464.100 ±(99.9%) 21.399 ms/op
# Warmup Iteration   3: 475.914 ±(99.9%) 35.996 ms/op
# Warmup Iteration   4: 559.859 ±(99.9%) 7.999 ms/op
# Warmup Iteration   5: 560.908 ±(99.9%) 9.333 ms/op
Iteration   1: 479.793 ±(99.9%) 49.835 ms/op
                 executeQuery·p0.00:   437.780 ms/op
                 executeQuery·p0.50:   458.752 ms/op
                 executeQuery·p0.90:   557.213 ms/op
                 executeQuery·p0.95:   557.842 ms/op
                 executeQuery·p0.99:   557.842 ms/op
                 executeQuery·p0.999:  557.842 ms/op
                 executeQuery·p0.9999: 557.842 ms/op
                 executeQuery·p1.00:   557.842 ms/op

Iteration   2: 461.688 ±(99.9%) 11.238 ms/op
                 executeQuery·p0.00:   449.315 ms/op
                 executeQuery·p0.50:   459.801 ms/op
                 executeQuery·p0.90:   484.757 ms/op
                 executeQuery·p0.95:   486.015 ms/op
                 executeQuery·p0.99:   486.015 ms/op
                 executeQuery·p0.999:  486.015 ms/op
                 executeQuery·p0.9999: 486.015 ms/op
                 executeQuery·p1.00:   486.015 ms/op

Iteration   3: 451.641 ±(99.9%) 12.645 ms/op
                 executeQuery·p0.00:   438.305 ms/op
                 executeQuery·p0.50:   449.053 ms/op
                 executeQuery·p0.90:   477.259 ms/op
                 executeQuery·p0.95:   484.966 ms/op
                 executeQuery·p0.99:   484.966 ms/op
                 executeQuery·p0.999:  484.966 ms/op
                 executeQuery·p0.9999: 484.966 ms/op
                 executeQuery·p1.00:   484.966 ms/op

Iteration   4: 444.760 ±(99.9%) 5.982 ms/op
                 executeQuery·p0.00:   435.683 ms/op
                 executeQuery·p0.50:   444.072 ms/op
                 executeQuery·p0.90:   454.872 ms/op
                 executeQuery·p0.95:   455.606 ms/op
                 executeQuery·p0.99:   455.606 ms/op
                 executeQuery·p0.999:  455.606 ms/op
                 executeQuery·p0.9999: 455.606 ms/op
                 executeQuery·p1.00:   455.606 ms/op

Iteration   5: 446.595 ±(99.9%) 5.868 ms/op
                 executeQuery·p0.00:   437.256 ms/op
                 executeQuery·p0.50:   445.907 ms/op
                 executeQuery·p0.90:   454.663 ms/op
                 executeQuery·p0.95:   456.131 ms/op
                 executeQuery·p0.99:   456.131 ms/op
                 executeQuery·p0.999:  456.131 ms/op
                 executeQuery·p0.9999: 456.131 ms/op
                 executeQuery·p1.00:   456.131 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 157
  mean =    459.053 ±(99.9%) 6.561 ms/op

  Histogram, ms/op:
    [400.000, 412.500) = 0 
    [412.500, 425.000) = 0 
    [425.000, 437.500) = 5 
    [437.500, 450.000) = 59 
    [450.000, 462.500) = 53 
    [462.500, 475.000) = 22 
    [475.000, 487.500) = 10 
    [487.500, 500.000) = 1 
    [500.000, 512.500) = 0 
    [512.500, 525.000) = 0 
    [525.000, 537.500) = 0 
    [537.500, 550.000) = 2 
    [550.000, 562.500) = 3 
    [562.500, 575.000) = 2 
    [575.000, 587.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =    435.159 ms/op
     p(50.0000) =    453.509 ms/op
     p(90.0000) =    479.724 ms/op
     p(95.0000) =    494.508 ms/op
     p(99.0000) =    569.817 ms/op
     p(99.9000) =    570.425 ms/op
     p(99.9900) =    570.425 ms/op
     p(99.9990) =    570.425 ms/op
     p(99.9999) =    570.425 ms/op
    p(100.0000) =    570.425 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 76.58% complete, ETA 05:07:03
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 8547.992 ms/op
# Warmup Iteration   2: 5033.165 ms/op
# Warmup Iteration   3: 4957.667 ms/op
# Warmup Iteration   4: 5142.217 ms/op
# Warmup Iteration   5: 5452.595 ms/op
Iteration   1: 5200.937 ms/op
                 executeQuery·p0.00:   5200.937 ms/op
                 executeQuery·p0.50:   5200.937 ms/op
                 executeQuery·p0.90:   5200.937 ms/op
                 executeQuery·p0.95:   5200.937 ms/op
                 executeQuery·p0.99:   5200.937 ms/op
                 executeQuery·p0.999:  5200.937 ms/op
                 executeQuery·p0.9999: 5200.937 ms/op
                 executeQuery·p1.00:   5200.937 ms/op

Iteration   2: 5209.326 ms/op
                 executeQuery·p0.00:   5209.326 ms/op
                 executeQuery·p0.50:   5209.326 ms/op
                 executeQuery·p0.90:   5209.326 ms/op
                 executeQuery·p0.95:   5209.326 ms/op
                 executeQuery·p0.99:   5209.326 ms/op
                 executeQuery·p0.999:  5209.326 ms/op
                 executeQuery·p0.9999: 5209.326 ms/op
                 executeQuery·p1.00:   5209.326 ms/op

Iteration   3: 5251.269 ms/op
                 executeQuery·p0.00:   5251.269 ms/op
                 executeQuery·p0.50:   5251.269 ms/op
                 executeQuery·p0.90:   5251.269 ms/op
                 executeQuery·p0.95:   5251.269 ms/op
                 executeQuery·p0.99:   5251.269 ms/op
                 executeQuery·p0.999:  5251.269 ms/op
                 executeQuery·p0.9999: 5251.269 ms/op
                 executeQuery·p1.00:   5251.269 ms/op

Iteration   4: 5343.543 ms/op
                 executeQuery·p0.00:   5343.543 ms/op
                 executeQuery·p0.50:   5343.543 ms/op
                 executeQuery·p0.90:   5343.543 ms/op
                 executeQuery·p0.95:   5343.543 ms/op
                 executeQuery·p0.99:   5343.543 ms/op
                 executeQuery·p0.999:  5343.543 ms/op
                 executeQuery·p0.9999: 5343.543 ms/op
                 executeQuery·p1.00:   5343.543 ms/op

Iteration   5: 4907.336 ms/op
                 executeQuery·p0.00:   4907.336 ms/op
                 executeQuery·p0.50:   4907.336 ms/op
                 executeQuery·p0.90:   4907.336 ms/op
                 executeQuery·p0.95:   4907.336 ms/op
                 executeQuery·p0.99:   4907.336 ms/op
                 executeQuery·p0.999:  4907.336 ms/op
                 executeQuery·p0.9999: 4907.336 ms/op
                 executeQuery·p1.00:   4907.336 ms/op


# Run progress: 76.90% complete, ETA 05:03:48
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 8623.489 ms/op
# Warmup Iteration   2: 5091.885 ms/op
# Warmup Iteration   3: 4999.610 ms/op
# Warmup Iteration   4: 5226.103 ms/op
# Warmup Iteration   5: 5469.372 ms/op
Iteration   1: 5209.326 ms/op
                 executeQuery·p0.00:   5209.326 ms/op
                 executeQuery·p0.50:   5209.326 ms/op
                 executeQuery·p0.90:   5209.326 ms/op
                 executeQuery·p0.95:   5209.326 ms/op
                 executeQuery·p0.99:   5209.326 ms/op
                 executeQuery·p0.999:  5209.326 ms/op
                 executeQuery·p0.9999: 5209.326 ms/op
                 executeQuery·p1.00:   5209.326 ms/op

Iteration   2: 5200.937 ms/op
                 executeQuery·p0.00:   5200.937 ms/op
                 executeQuery·p0.50:   5200.937 ms/op
                 executeQuery·p0.90:   5200.937 ms/op
                 executeQuery·p0.95:   5200.937 ms/op
                 executeQuery·p0.99:   5200.937 ms/op
                 executeQuery·p0.999:  5200.937 ms/op
                 executeQuery·p0.9999: 5200.937 ms/op
                 executeQuery·p1.00:   5200.937 ms/op

Iteration   3: 5200.937 ms/op
                 executeQuery·p0.00:   5200.937 ms/op
                 executeQuery·p0.50:   5200.937 ms/op
                 executeQuery·p0.90:   5200.937 ms/op
                 executeQuery·p0.95:   5200.937 ms/op
                 executeQuery·p0.99:   5200.937 ms/op
                 executeQuery·p0.999:  5200.937 ms/op
                 executeQuery·p0.9999: 5200.937 ms/op
                 executeQuery·p1.00:   5200.937 ms/op

Iteration   4: 5226.103 ms/op
                 executeQuery·p0.00:   5226.103 ms/op
                 executeQuery·p0.50:   5226.103 ms/op
                 executeQuery·p0.90:   5226.103 ms/op
                 executeQuery·p0.95:   5226.103 ms/op
                 executeQuery·p0.99:   5226.103 ms/op
                 executeQuery·p0.999:  5226.103 ms/op
                 executeQuery·p0.9999: 5226.103 ms/op
                 executeQuery·p1.00:   5226.103 ms/op

Iteration   5: 5016.388 ms/op
                 executeQuery·p0.00:   5016.388 ms/op
                 executeQuery·p0.50:   5016.388 ms/op
                 executeQuery·p0.90:   5016.388 ms/op
                 executeQuery·p0.95:   5016.388 ms/op
                 executeQuery·p0.99:   5016.388 ms/op
                 executeQuery·p0.999:  5016.388 ms/op
                 executeQuery·p0.9999: 5016.388 ms/op
                 executeQuery·p1.00:   5016.388 ms/op



Result "benchmarks.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 10
  mean =   5176.610 ±(99.9%) 187.201 ms/op

  Histogram, ms/op:
    [4900.000, 4950.000) = 1 
    [4950.000, 5000.000) = 0 
    [5000.000, 5050.000) = 1 
    [5050.000, 5100.000) = 0 
    [5100.000, 5150.000) = 0 
    [5150.000, 5200.000) = 0 
    [5200.000, 5250.000) = 6 
    [5250.000, 5300.000) = 1 
    [5300.000, 5350.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   4907.336 ms/op
     p(50.0000) =   5205.131 ms/op
     p(90.0000) =   5334.316 ms/op
     p(95.0000) =   5343.543 ms/op
     p(99.0000) =   5343.543 ms/op
     p(99.9000) =   5343.543 ms/op
     p(99.9900) =   5343.543 ms/op
     p(99.9990) =   5343.543 ms/op
     p(99.9999) =   5343.543 ms/op
    p(100.0000) =   5343.543 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 77.22% complete, ETA 05:00:30
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 333.674 ±(99.9%) 40.007 ms/op
# Warmup Iteration   2: 334.950 ±(99.9%) 33.858 ms/op
# Warmup Iteration   3: 271.872 ±(99.9%) 4.294 ms/op
# Warmup Iteration   4: 263.420 ±(99.9%) 1.621 ms/op
# Warmup Iteration   5: 271.872 ±(99.9%) 4.367 ms/op
Iteration   1: 277.305 ±(99.9%) 1.529 ms/op
                 executeQuery·p0.00:   274.203 ms/op
                 executeQuery·p0.50:   277.086 ms/op
                 executeQuery·p0.90:   280.180 ms/op
                 executeQuery·p0.95:   283.509 ms/op
                 executeQuery·p0.99:   285.737 ms/op
                 executeQuery·p0.999:  285.737 ms/op
                 executeQuery·p0.9999: 285.737 ms/op
                 executeQuery·p1.00:   285.737 ms/op

Iteration   2: 277.625 ±(99.9%) 1.644 ms/op
                 executeQuery·p0.00:   274.727 ms/op
                 executeQuery·p0.50:   276.824 ms/op
                 executeQuery·p0.90:   283.116 ms/op
                 executeQuery·p0.95:   284.557 ms/op
                 executeQuery·p0.99:   286.786 ms/op
                 executeQuery·p0.999:  286.786 ms/op
                 executeQuery·p0.9999: 286.786 ms/op
                 executeQuery·p1.00:   286.786 ms/op

Iteration   3: 279.038 ±(99.9%) 2.373 ms/op
                 executeQuery·p0.00:   274.727 ms/op
                 executeQuery·p0.50:   277.873 ms/op
                 executeQuery·p0.90:   284.269 ms/op
                 executeQuery·p0.95:   287.520 ms/op
                 executeQuery·p0.99:   294.650 ms/op
                 executeQuery·p0.999:  294.650 ms/op
                 executeQuery·p0.9999: 294.650 ms/op
                 executeQuery·p1.00:   294.650 ms/op

Iteration   4: 278.106 ±(99.9%) 1.124 ms/op
                 executeQuery·p0.00:   275.251 ms/op
                 executeQuery·p0.50:   278.135 ms/op
                 executeQuery·p0.90:   280.651 ms/op
                 executeQuery·p0.95:   281.779 ms/op
                 executeQuery·p0.99:   283.116 ms/op
                 executeQuery·p0.999:  283.116 ms/op
                 executeQuery·p0.9999: 283.116 ms/op
                 executeQuery·p1.00:   283.116 ms/op

Iteration   5: 277.844 ±(99.9%) 1.160 ms/op
                 executeQuery·p0.00:   274.727 ms/op
                 executeQuery·p0.50:   277.348 ms/op
                 executeQuery·p0.90:   280.494 ms/op
                 executeQuery·p0.95:   281.857 ms/op
                 executeQuery·p0.99:   283.640 ms/op
                 executeQuery·p0.999:  283.640 ms/op
                 executeQuery·p0.9999: 283.640 ms/op
                 executeQuery·p1.00:   283.640 ms/op


# Run progress: 77.53% complete, ETA 04:55:37
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 343.688 ±(99.9%) 42.517 ms/op
# Warmup Iteration   2: 337.624 ±(99.9%) 33.648 ms/op
# Warmup Iteration   3: 279.446 ±(99.9%) 1.647 ms/op
# Warmup Iteration   4: 280.159 ±(99.9%) 2.088 ms/op
# Warmup Iteration   5: 278.848 ±(99.9%) 1.359 ms/op
Iteration   1: 279.810 ±(99.9%) 2.350 ms/op
                 executeQuery·p0.00:   275.775 ms/op
                 executeQuery·p0.50:   279.183 ms/op
                 executeQuery·p0.90:   282.329 ms/op
                 executeQuery·p0.95:   288.673 ms/op
                 executeQuery·p0.99:   299.368 ms/op
                 executeQuery·p0.999:  299.368 ms/op
                 executeQuery·p0.9999: 299.368 ms/op
                 executeQuery·p1.00:   299.368 ms/op

Iteration   2: 282.708 ±(99.9%) 2.737 ms/op
                 executeQuery·p0.00:   276.300 ms/op
                 executeQuery·p0.50:   282.329 ms/op
                 executeQuery·p0.90:   289.355 ms/op
                 executeQuery·p0.95:   293.759 ms/op
                 executeQuery·p0.99:   294.650 ms/op
                 executeQuery·p0.999:  294.650 ms/op
                 executeQuery·p0.9999: 294.650 ms/op
                 executeQuery·p1.00:   294.650 ms/op

Iteration   3: 283.909 ±(99.9%) 1.995 ms/op
                 executeQuery·p0.00:   279.446 ms/op
                 executeQuery·p0.50:   283.640 ms/op
                 executeQuery·p0.90:   288.358 ms/op
                 executeQuery·p0.95:   291.609 ms/op
                 executeQuery·p0.99:   296.223 ms/op
                 executeQuery·p0.999:  296.223 ms/op
                 executeQuery·p0.9999: 296.223 ms/op
                 executeQuery·p1.00:   296.223 ms/op

Iteration   4: 280.480 ±(99.9%) 1.507 ms/op
                 executeQuery·p0.00:   275.775 ms/op
                 executeQuery·p0.50:   280.494 ms/op
                 executeQuery·p0.90:   283.273 ms/op
                 executeQuery·p0.95:   286.209 ms/op
                 executeQuery·p0.99:   288.883 ms/op
                 executeQuery·p0.999:  288.883 ms/op
                 executeQuery·p0.9999: 288.883 ms/op
                 executeQuery·p1.00:   288.883 ms/op

Iteration   5: 279.620 ±(99.9%) 1.597 ms/op
                 executeQuery·p0.00:   276.300 ms/op
                 executeQuery·p0.50:   279.446 ms/op
                 executeQuery·p0.90:   284.321 ms/op
                 executeQuery·p0.95:   286.864 ms/op
                 executeQuery·p0.99:   287.310 ms/op
                 executeQuery·p0.999:  287.310 ms/op
                 executeQuery·p0.9999: 287.310 ms/op
                 executeQuery·p1.00:   287.310 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 359
  mean =    279.632 ±(99.9%) 0.652 ms/op

  Histogram, ms/op:
    [270.000, 272.500) = 0 
    [272.500, 275.000) = 11 
    [275.000, 277.500) = 106 
    [277.500, 280.000) = 128 
    [280.000, 282.500) = 43 
    [282.500, 285.000) = 43 
    [285.000, 287.500) = 18 
    [287.500, 290.000) = 3 
    [290.000, 292.500) = 2 
    [292.500, 295.000) = 3 
    [295.000, 297.500) = 1 

  Percentiles, ms/op:
      p(0.0000) =    274.203 ms/op
     p(50.0000) =    278.921 ms/op
     p(90.0000) =    284.164 ms/op
     p(95.0000) =    286.261 ms/op
     p(99.0000) =    294.650 ms/op
     p(99.9000) =    299.368 ms/op
     p(99.9900) =    299.368 ms/op
     p(99.9990) =    299.368 ms/op
     p(99.9999) =    299.368 ms/op
    p(100.0000) =    299.368 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 77.85% complete, ETA 04:50:45
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3238.003 ±(99.9%) 1913.313 ms/op
# Warmup Iteration   2: 2446.118 ±(99.9%) 1157.088 ms/op
# Warmup Iteration   3: 2481.350 ±(99.9%) 87.423 ms/op
# Warmup Iteration   4: 2536.505 ±(99.9%) 25.950 ms/op
# Warmup Iteration   5: 2538.602 ±(99.9%) 25.950 ms/op
Iteration   1: 2544.894 ±(99.9%) 64.043 ms/op
                 executeQuery·p0.00:   2537.554 ms/op
                 executeQuery·p0.50:   2541.748 ms/op
                 executeQuery·p0.90:   2558.525 ms/op
                 executeQuery·p0.95:   2558.525 ms/op
                 executeQuery·p0.99:   2558.525 ms/op
                 executeQuery·p0.999:  2558.525 ms/op
                 executeQuery·p0.9999: 2558.525 ms/op
                 executeQuery·p1.00:   2558.525 ms/op

Iteration   2: 2539.651 ±(99.9%) 34.991 ms/op
                 executeQuery·p0.00:   2533.360 ms/op
                 executeQuery·p0.50:   2539.651 ms/op
                 executeQuery·p0.90:   2545.943 ms/op
                 executeQuery·p0.95:   2545.943 ms/op
                 executeQuery·p0.99:   2545.943 ms/op
                 executeQuery·p0.999:  2545.943 ms/op
                 executeQuery·p0.9999: 2545.943 ms/op
                 executeQuery·p1.00:   2545.943 ms/op

Iteration   3: 2538.602 ±(99.9%) 25.950 ms/op
                 executeQuery·p0.00:   2533.360 ms/op
                 executeQuery·p0.50:   2539.651 ms/op
                 executeQuery·p0.90:   2541.748 ms/op
                 executeQuery·p0.95:   2541.748 ms/op
                 executeQuery·p0.99:   2541.748 ms/op
                 executeQuery·p0.999:  2541.748 ms/op
                 executeQuery·p0.9999: 2541.748 ms/op
                 executeQuery·p1.00:   2541.748 ms/op

Iteration   4: 2536.505 ±(99.9%) 25.950 ms/op
                 executeQuery·p0.00:   2533.360 ms/op
                 executeQuery·p0.50:   2535.457 ms/op
                 executeQuery·p0.90:   2541.748 ms/op
                 executeQuery·p0.95:   2541.748 ms/op
                 executeQuery·p0.99:   2541.748 ms/op
                 executeQuery·p0.999:  2541.748 ms/op
                 executeQuery·p0.9999: 2541.748 ms/op
                 executeQuery·p1.00:   2541.748 ms/op

Iteration   5: 2534.408 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2533.360 ms/op
                 executeQuery·p0.50:   2533.360 ms/op
                 executeQuery·p0.90:   2537.554 ms/op
                 executeQuery·p0.95:   2537.554 ms/op
                 executeQuery·p0.99:   2537.554 ms/op
                 executeQuery·p0.999:  2537.554 ms/op
                 executeQuery·p0.9999: 2537.554 ms/op
                 executeQuery·p1.00:   2537.554 ms/op


# Run progress: 78.16% complete, ETA 04:45:57
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3266.314 ±(99.9%) 2078.493 ms/op
# Warmup Iteration   2: 2583.691 ±(99.9%) 2319.215 ms/op
# Warmup Iteration   3: 2523.922 ±(99.9%) 390.501 ms/op
# Warmup Iteration   4: 2520.777 ±(99.9%) 22.130 ms/op
# Warmup Iteration   5: 2514.485 ±(99.9%) 27.104 ms/op
Iteration   1: 2521.825 ±(99.9%) 71.281 ms/op
                 executeQuery·p0.00:   2512.388 ms/op
                 executeQuery·p0.50:   2518.680 ms/op
                 executeQuery·p0.90:   2537.554 ms/op
                 executeQuery·p0.95:   2537.554 ms/op
                 executeQuery·p0.99:   2537.554 ms/op
                 executeQuery·p0.999:  2537.554 ms/op
                 executeQuery·p0.9999: 2537.554 ms/op
                 executeQuery·p1.00:   2537.554 ms/op

Iteration   2: 2521.825 ±(99.9%) 161.677 ms/op
                 executeQuery·p0.00:   2503.999 ms/op
                 executeQuery·p0.50:   2512.388 ms/op
                 executeQuery·p0.90:   2558.525 ms/op
                 executeQuery·p0.95:   2558.525 ms/op
                 executeQuery·p0.99:   2558.525 ms/op
                 executeQuery·p0.999:  2558.525 ms/op
                 executeQuery·p0.9999: 2558.525 ms/op
                 executeQuery·p1.00:   2558.525 ms/op

Iteration   3: 2555.380 ±(99.9%) 25.950 ms/op
                 executeQuery·p0.00:   2550.137 ms/op
                 executeQuery·p0.50:   2556.428 ms/op
                 executeQuery·p0.90:   2558.525 ms/op
                 executeQuery·p0.95:   2558.525 ms/op
                 executeQuery·p0.99:   2558.525 ms/op
                 executeQuery·p0.999:  2558.525 ms/op
                 executeQuery·p0.9999: 2558.525 ms/op
                 executeQuery·p1.00:   2558.525 ms/op

Iteration   4: 2555.380 ±(99.9%) 71.281 ms/op
                 executeQuery·p0.00:   2545.943 ms/op
                 executeQuery·p0.50:   2552.234 ms/op
                 executeQuery·p0.90:   2571.108 ms/op
                 executeQuery·p0.95:   2571.108 ms/op
                 executeQuery·p0.99:   2571.108 ms/op
                 executeQuery·p0.999:  2571.108 ms/op
                 executeQuery·p0.9999: 2571.108 ms/op
                 executeQuery·p1.00:   2571.108 ms/op

Iteration   5: 2515.534 ±(99.9%) 169.081 ms/op
                 executeQuery·p0.00:   2491.417 ms/op
                 executeQuery·p0.50:   2510.291 ms/op
                 executeQuery·p0.90:   2550.137 ms/op
                 executeQuery·p0.95:   2550.137 ms/op
                 executeQuery·p0.99:   2550.137 ms/op
                 executeQuery·p0.999:  2550.137 ms/op
                 executeQuery·p0.9999: 2550.137 ms/op
                 executeQuery·p1.00:   2550.137 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 40
  mean =   2536.400 ±(99.9%) 9.824 ms/op

  Histogram, ms/op:
    [2490.000, 2495.000) = 1 
    [2495.000, 2500.000) = 1 
    [2500.000, 2505.000) = 1 
    [2505.000, 2510.000) = 1 
    [2510.000, 2515.000) = 1 
    [2515.000, 2520.000) = 2 
    [2520.000, 2525.000) = 2 
    [2525.000, 2530.000) = 0 
    [2530.000, 2535.000) = 7 
    [2535.000, 2540.000) = 7 
    [2540.000, 2545.000) = 4 
    [2545.000, 2550.000) = 3 
    [2550.000, 2555.000) = 5 
    [2555.000, 2560.000) = 4 
    [2560.000, 2565.000) = 0 
    [2565.000, 2570.000) = 0 
    [2570.000, 2575.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2491.417 ms/op
     p(50.0000) =   2537.554 ms/op
     p(90.0000) =   2558.525 ms/op
     p(95.0000) =   2558.525 ms/op
     p(99.0000) =   2571.108 ms/op
     p(99.9000) =   2571.108 ms/op
     p(99.9900) =   2571.108 ms/op
     p(99.9990) =   2571.108 ms/op
     p(99.9999) =   2571.108 ms/op
    p(100.0000) =   2571.108 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 78.48% complete, ETA 04:41:09
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 407.854 ±(99.9%) 54.828 ms/op
# Warmup Iteration   2: 407.561 ±(99.9%) 38.627 ms/op
# Warmup Iteration   3: 320.611 ±(99.9%) 1.593 ms/op
# Warmup Iteration   4: 316.686 ±(99.9%) 4.442 ms/op
# Warmup Iteration   5: 311.886 ±(99.9%) 5.787 ms/op
Iteration   1: 320.577 ±(99.9%) 1.781 ms/op
                 executeQuery·p0.00:   317.194 ms/op
                 executeQuery·p0.50:   319.816 ms/op
                 executeQuery·p0.90:   325.897 ms/op
                 executeQuery·p0.95:   327.575 ms/op
                 executeQuery·p0.99:   328.204 ms/op
                 executeQuery·p0.999:  328.204 ms/op
                 executeQuery·p0.9999: 328.204 ms/op
                 executeQuery·p1.00:   328.204 ms/op

Iteration   2: 320.209 ±(99.9%) 1.672 ms/op
                 executeQuery·p0.00:   315.621 ms/op
                 executeQuery·p0.50:   320.078 ms/op
                 executeQuery·p0.90:   323.538 ms/op
                 executeQuery·p0.95:   327.339 ms/op
                 executeQuery·p0.99:   327.680 ms/op
                 executeQuery·p0.999:  327.680 ms/op
                 executeQuery·p0.9999: 327.680 ms/op
                 executeQuery·p1.00:   327.680 ms/op

Iteration   3: 320.422 ±(99.9%) 1.882 ms/op
                 executeQuery·p0.00:   315.621 ms/op
                 executeQuery·p0.50:   320.078 ms/op
                 executeQuery·p0.90:   323.695 ms/op
                 executeQuery·p0.95:   327.418 ms/op
                 executeQuery·p0.99:   330.826 ms/op
                 executeQuery·p0.999:  330.826 ms/op
                 executeQuery·p0.9999: 330.826 ms/op
                 executeQuery·p1.00:   330.826 ms/op

Iteration   4: 333.360 ±(99.9%) 1.591 ms/op
                 executeQuery·p0.00:   329.777 ms/op
                 executeQuery·p0.50:   333.447 ms/op
                 executeQuery·p0.90:   336.540 ms/op
                 executeQuery·p0.95:   338.690 ms/op
                 executeQuery·p0.99:   338.690 ms/op
                 executeQuery·p0.999:  338.690 ms/op
                 executeQuery·p0.9999: 338.690 ms/op
                 executeQuery·p1.00:   338.690 ms/op

Iteration   5: 321.152 ±(99.9%) 3.071 ms/op
                 executeQuery·p0.00:   314.573 ms/op
                 executeQuery·p0.50:   320.340 ms/op
                 executeQuery·p0.90:   329.882 ms/op
                 executeQuery·p0.95:   334.076 ms/op
                 executeQuery·p0.99:   336.593 ms/op
                 executeQuery·p0.999:  336.593 ms/op
                 executeQuery·p0.9999: 336.593 ms/op
                 executeQuery·p1.00:   336.593 ms/op


# Run progress: 78.80% complete, ETA 04:36:22
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 399.870 ±(99.9%) 55.867 ms/op
# Warmup Iteration   2: 405.086 ±(99.9%) 40.659 ms/op
# Warmup Iteration   3: 316.113 ±(99.9%) 5.326 ms/op
# Warmup Iteration   4: 318.079 ±(99.9%) 4.645 ms/op
# Warmup Iteration   5: 316.178 ±(99.9%) 5.184 ms/op
Iteration   1: 306.264 ±(99.9%) 1.526 ms/op
                 executeQuery·p0.00:   301.466 ms/op
                 executeQuery·p0.50:   306.184 ms/op
                 executeQuery·p0.90:   309.749 ms/op
                 executeQuery·p0.95:   312.109 ms/op
                 executeQuery·p0.99:   312.476 ms/op
                 executeQuery·p0.999:  312.476 ms/op
                 executeQuery·p0.9999: 312.476 ms/op
                 executeQuery·p1.00:   312.476 ms/op

Iteration   2: 302.975 ±(99.9%) 1.129 ms/op
                 executeQuery·p0.00:   301.466 ms/op
                 executeQuery·p0.50:   302.514 ms/op
                 executeQuery·p0.90:   305.136 ms/op
                 executeQuery·p0.95:   306.866 ms/op
                 executeQuery·p0.99:   310.903 ms/op
                 executeQuery·p0.999:  310.903 ms/op
                 executeQuery·p0.9999: 310.903 ms/op
                 executeQuery·p1.00:   310.903 ms/op

Iteration   3: 303.086 ±(99.9%) 1.268 ms/op
                 executeQuery·p0.00:   300.941 ms/op
                 executeQuery·p0.50:   302.514 ms/op
                 executeQuery·p0.90:   304.611 ms/op
                 executeQuery·p0.95:   308.648 ms/op
                 executeQuery·p0.99:   311.951 ms/op
                 executeQuery·p0.999:  311.951 ms/op
                 executeQuery·p0.9999: 311.951 ms/op
                 executeQuery·p1.00:   311.951 ms/op

Iteration   4: 303.166 ±(99.9%) 1.217 ms/op
                 executeQuery·p0.00:   300.941 ms/op
                 executeQuery·p0.50:   303.038 ms/op
                 executeQuery·p0.90:   304.611 ms/op
                 executeQuery·p0.95:   307.338 ms/op
                 executeQuery·p0.99:   312.476 ms/op
                 executeQuery·p0.999:  312.476 ms/op
                 executeQuery·p0.9999: 312.476 ms/op
                 executeQuery·p1.00:   312.476 ms/op

Iteration   5: 303.356 ±(99.9%) 1.253 ms/op
                 executeQuery·p0.00:   300.941 ms/op
                 executeQuery·p0.50:   303.038 ms/op
                 executeQuery·p0.90:   305.974 ms/op
                 executeQuery·p0.95:   307.757 ms/op
                 executeQuery·p0.99:   311.427 ms/op
                 executeQuery·p0.999:  311.427 ms/op
                 executeQuery·p0.9999: 311.427 ms/op
                 executeQuery·p1.00:   311.427 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery":
  N = 321
  mean =    313.135 ±(99.9%) 1.972 ms/op

  Histogram, ms/op:
    [300.000, 302.500) = 45 
    [302.500, 305.000) = 80 
    [305.000, 307.500) = 29 
    [307.500, 310.000) = 4 
    [310.000, 312.500) = 7 
    [312.500, 315.000) = 1 
    [315.000, 317.500) = 7 
    [317.500, 320.000) = 56 
    [320.000, 322.500) = 44 
    [322.500, 325.000) = 6 
    [325.000, 327.500) = 5 
    [327.500, 330.000) = 4 
    [330.000, 332.500) = 14 
    [332.500, 335.000) = 9 
    [335.000, 337.500) = 8 

  Percentiles, ms/op:
      p(0.0000) =    300.941 ms/op
     p(50.0000) =    311.427 ms/op
     p(90.0000) =    330.301 ms/op
     p(95.0000) =    333.447 ms/op
     p(99.0000) =    336.593 ms/op
     p(99.9000) =    338.690 ms/op
     p(99.9900) =    338.690 ms/op
     p(99.9990) =    338.690 ms/op
     p(99.9999) =    338.690 ms/op
    p(100.0000) =    338.690 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 79.11% complete, ETA 04:31:36
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3498.050 ±(99.9%) 9226.578 ms/op
# Warmup Iteration   2: 3440.727 ±(99.9%) 11024.506 ms/op
# Warmup Iteration   3: 2909.798 ±(99.9%) 433.868 ms/op
# Warmup Iteration   4: 2985.296 ±(99.9%) 92.245 ms/op
# Warmup Iteration   5: 2962.227 ±(99.9%) 89.551 ms/op
Iteration   1: 2960.130 ±(99.9%) 46.288 ms/op
                 executeQuery·p0.00:   2952.790 ms/op
                 executeQuery·p0.50:   2959.081 ms/op
                 executeQuery·p0.90:   2969.567 ms/op
                 executeQuery·p0.95:   2969.567 ms/op
                 executeQuery·p0.99:   2969.567 ms/op
                 executeQuery·p0.999:  2969.567 ms/op
                 executeQuery·p0.9999: 2969.567 ms/op
                 executeQuery·p1.00:   2969.567 ms/op

Iteration   2: 2958.033 ±(99.9%) 25.950 ms/op
                 executeQuery·p0.00:   2952.790 ms/op
                 executeQuery·p0.50:   2959.081 ms/op
                 executeQuery·p0.90:   2961.179 ms/op
                 executeQuery·p0.95:   2961.179 ms/op
                 executeQuery·p0.99:   2961.179 ms/op
                 executeQuery·p0.999:  2961.179 ms/op
                 executeQuery·p0.9999: 2961.179 ms/op
                 executeQuery·p1.00:   2961.179 ms/op

Iteration   3: 2970.616 ±(99.9%) 60.098 ms/op
                 executeQuery·p0.00:   2961.179 ms/op
                 executeQuery·p0.50:   2969.567 ms/op
                 executeQuery·p0.90:   2982.150 ms/op
                 executeQuery·p0.95:   2982.150 ms/op
                 executeQuery·p0.99:   2982.150 ms/op
                 executeQuery·p0.999:  2982.150 ms/op
                 executeQuery·p0.9999: 2982.150 ms/op
                 executeQuery·p1.00:   2982.150 ms/op

Iteration   4: 2968.519 ±(99.9%) 46.288 ms/op
                 executeQuery·p0.00:   2961.179 ms/op
                 executeQuery·p0.50:   2967.470 ms/op
                 executeQuery·p0.90:   2977.956 ms/op
                 executeQuery·p0.95:   2977.956 ms/op
                 executeQuery·p0.99:   2977.956 ms/op
                 executeQuery·p0.999:  2977.956 ms/op
                 executeQuery·p0.9999: 2977.956 ms/op
                 executeQuery·p1.00:   2977.956 ms/op

Iteration   5: 2959.081 ±(99.9%) 27.104 ms/op
                 executeQuery·p0.00:   2952.790 ms/op
                 executeQuery·p0.50:   2961.179 ms/op
                 executeQuery·p0.90:   2961.179 ms/op
                 executeQuery·p0.95:   2961.179 ms/op
                 executeQuery·p0.99:   2961.179 ms/op
                 executeQuery·p0.999:  2961.179 ms/op
                 executeQuery·p0.9999: 2961.179 ms/op
                 executeQuery·p1.00:   2961.179 ms/op


# Run progress: 79.43% complete, ETA 04:26:56
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3647.646 ±(99.9%) 10135.999 ms/op
# Warmup Iteration   2: 3573.547 ±(99.9%) 11539.772 ms/op
# Warmup Iteration   3: 2980.053 ±(99.9%) 64.519 ms/op
# Warmup Iteration   4: 2995.782 ±(99.9%) 144.057 ms/op
# Warmup Iteration   5: 2961.179 ±(99.9%) 96.462 ms/op
Iteration   1: 2955.936 ±(99.9%) 46.288 ms/op
                 executeQuery·p0.00:   2948.596 ms/op
                 executeQuery·p0.50:   2954.887 ms/op
                 executeQuery·p0.90:   2965.373 ms/op
                 executeQuery·p0.95:   2965.373 ms/op
                 executeQuery·p0.99:   2965.373 ms/op
                 executeQuery·p0.999:  2965.373 ms/op
                 executeQuery·p0.9999: 2965.373 ms/op
                 executeQuery·p1.00:   2965.373 ms/op

Iteration   2: 2954.887 ±(99.9%) 15.648 ms/op
                 executeQuery·p0.00:   2952.790 ms/op
                 executeQuery·p0.50:   2954.887 ms/op
                 executeQuery·p0.90:   2956.984 ms/op
                 executeQuery·p0.95:   2956.984 ms/op
                 executeQuery·p0.99:   2956.984 ms/op
                 executeQuery·p0.999:  2956.984 ms/op
                 executeQuery·p0.9999: 2956.984 ms/op
                 executeQuery·p1.00:   2956.984 ms/op

Iteration   3: 3027.239 ±(99.9%) 223.912 ms/op
                 executeQuery·p0.00:   2977.956 ms/op
                 executeQuery·p0.50:   3038.773 ms/op
                 executeQuery·p0.90:   3053.453 ms/op
                 executeQuery·p0.95:   3053.453 ms/op
                 executeQuery·p0.99:   3053.453 ms/op
                 executeQuery·p0.999:  3053.453 ms/op
                 executeQuery·p0.9999: 3053.453 ms/op
                 executeQuery·p1.00:   3053.453 ms/op

Iteration   4: 2993.684 ±(99.9%) 186.962 ms/op
                 executeQuery·p0.00:   2973.762 ms/op
                 executeQuery·p0.50:   2982.150 ms/op
                 executeQuery·p0.90:   3036.676 ms/op
                 executeQuery·p0.95:   3036.676 ms/op
                 executeQuery·p0.99:   3036.676 ms/op
                 executeQuery·p0.999:  3036.676 ms/op
                 executeQuery·p0.9999: 3036.676 ms/op
                 executeQuery·p1.00:   3036.676 ms/op

Iteration   5: 2980.053 ±(99.9%) 84.268 ms/op
                 executeQuery·p0.00:   2969.567 ms/op
                 executeQuery·p0.50:   2975.859 ms/op
                 executeQuery·p0.90:   2998.927 ms/op
                 executeQuery·p0.95:   2998.927 ms/op
                 executeQuery·p0.99:   2998.927 ms/op
                 executeQuery·p0.999:  2998.927 ms/op
                 executeQuery·p0.9999: 2998.927 ms/op
                 executeQuery·p1.00:   2998.927 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery":
  N = 40
  mean =   2972.818 ±(99.9%) 14.541 ms/op

  Histogram, ms/op:
    [2900.000, 2912.500) = 0 
    [2912.500, 2925.000) = 0 
    [2925.000, 2937.500) = 0 
    [2937.500, 2950.000) = 1 
    [2950.000, 2962.500) = 19 
    [2962.500, 2975.000) = 9 
    [2975.000, 2987.500) = 6 
    [2987.500, 3000.000) = 1 
    [3000.000, 3012.500) = 0 
    [3012.500, 3025.000) = 0 
    [3025.000, 3037.500) = 2 
    [3037.500, 3050.000) = 1 
    [3050.000, 3062.500) = 1 
    [3062.500, 3075.000) = 0 
    [3075.000, 3087.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   2948.596 ms/op
     p(50.0000) =   2963.276 ms/op
     p(90.0000) =   3025.351 ms/op
     p(95.0000) =   3048.630 ms/op
     p(99.0000) =   3053.453 ms/op
     p(99.9000) =   3053.453 ms/op
     p(99.9900) =   3053.453 ms/op
     p(99.9990) =   3053.453 ms/op
     p(99.9999) =   3053.453 ms/op
    p(100.0000) =   3053.453 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 79.75% complete, ETA 04:22:17
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 610.148 ±(99.9%) 88.741 ms/op
# Warmup Iteration   2: 530.331 ±(99.9%) 79.222 ms/op
# Warmup Iteration   3: 467.093 ±(99.9%) 2.984 ms/op
# Warmup Iteration   4: 467.284 ±(99.9%) 2.016 ms/op
# Warmup Iteration   5: 466.140 ±(99.9%) 2.278 ms/op
Iteration   1: 467.427 ±(99.9%) 1.931 ms/op
                 executeQuery·p0.00:   462.946 ms/op
                 executeQuery·p0.50:   467.141 ms/op
                 executeQuery·p0.90:   470.653 ms/op
                 executeQuery·p0.95:   472.148 ms/op
                 executeQuery·p0.99:   472.383 ms/op
                 executeQuery·p0.999:  472.383 ms/op
                 executeQuery·p0.9999: 472.383 ms/op
                 executeQuery·p1.00:   472.383 ms/op

Iteration   2: 467.808 ±(99.9%) 1.652 ms/op
                 executeQuery·p0.00:   464.519 ms/op
                 executeQuery·p0.50:   467.665 ms/op
                 executeQuery·p0.90:   469.080 ms/op
                 executeQuery·p0.95:   474.585 ms/op
                 executeQuery·p0.99:   475.529 ms/op
                 executeQuery·p0.999:  475.529 ms/op
                 executeQuery·p0.9999: 475.529 ms/op
                 executeQuery·p1.00:   475.529 ms/op

Iteration   3: 467.212 ±(99.9%) 2.170 ms/op
                 executeQuery·p0.00:   463.995 ms/op
                 executeQuery·p0.50:   466.616 ms/op
                 executeQuery·p0.90:   472.226 ms/op
                 executeQuery·p0.95:   472.829 ms/op
                 executeQuery·p0.99:   472.908 ms/op
                 executeQuery·p0.999:  472.908 ms/op
                 executeQuery·p0.9999: 472.908 ms/op
                 executeQuery·p1.00:   472.908 ms/op

Iteration   4: 468.070 ±(99.9%) 1.858 ms/op
                 executeQuery·p0.00:   465.043 ms/op
                 executeQuery·p0.50:   467.665 ms/op
                 executeQuery·p0.90:   472.383 ms/op
                 executeQuery·p0.95:   472.829 ms/op
                 executeQuery·p0.99:   472.908 ms/op
                 executeQuery·p0.999:  472.908 ms/op
                 executeQuery·p0.9999: 472.908 ms/op
                 executeQuery·p1.00:   472.908 ms/op

Iteration   5: 467.379 ±(99.9%) 1.766 ms/op
                 executeQuery·p0.00:   464.519 ms/op
                 executeQuery·p0.50:   466.616 ms/op
                 executeQuery·p0.90:   471.073 ms/op
                 executeQuery·p0.95:   473.642 ms/op
                 executeQuery·p0.99:   473.956 ms/op
                 executeQuery·p0.999:  473.956 ms/op
                 executeQuery·p0.9999: 473.956 ms/op
                 executeQuery·p1.00:   473.956 ms/op


# Run progress: 80.06% complete, ETA 04:17:36
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 590.071 ±(99.9%) 101.983 ms/op
# Warmup Iteration   2: 541.755 ±(99.9%) 82.300 ms/op
# Warmup Iteration   3: 465.496 ±(99.9%) 2.860 ms/op
# Warmup Iteration   4: 466.807 ±(99.9%) 3.218 ms/op
# Warmup Iteration   5: 462.970 ±(99.9%) 4.184 ms/op
Iteration   1: 447.423 ±(99.9%) 1.402 ms/op
                 executeQuery·p0.00:   445.121 ms/op
                 executeQuery·p0.50:   447.218 ms/op
                 executeQuery·p0.90:   449.105 ms/op
                 executeQuery·p0.95:   453.090 ms/op
                 executeQuery·p0.99:   454.033 ms/op
                 executeQuery·p0.999:  454.033 ms/op
                 executeQuery·p0.9999: 454.033 ms/op
                 executeQuery·p1.00:   454.033 ms/op

Iteration   2: 453.828 ±(99.9%) 7.835 ms/op
                 executeQuery·p0.00:   446.169 ms/op
                 executeQuery·p0.50:   448.266 ms/op
                 executeQuery·p0.90:   470.391 ms/op
                 executeQuery·p0.95:   475.005 ms/op
                 executeQuery·p0.99:   476.054 ms/op
                 executeQuery·p0.999:  476.054 ms/op
                 executeQuery·p0.9999: 476.054 ms/op
                 executeQuery·p1.00:   476.054 ms/op

Iteration   3: 466.140 ±(99.9%) 2.220 ms/op
                 executeQuery·p0.00:   462.422 ms/op
                 executeQuery·p0.50:   465.568 ms/op
                 executeQuery·p0.90:   470.653 ms/op
                 executeQuery·p0.95:   471.256 ms/op
                 executeQuery·p0.99:   471.335 ms/op
                 executeQuery·p0.999:  471.335 ms/op
                 executeQuery·p0.9999: 471.335 ms/op
                 executeQuery·p1.00:   471.335 ms/op

Iteration   4: 465.663 ±(99.9%) 2.163 ms/op
                 executeQuery·p0.00:   461.898 ms/op
                 executeQuery·p0.50:   464.519 ms/op
                 executeQuery·p0.90:   470.181 ms/op
                 executeQuery·p0.95:   470.811 ms/op
                 executeQuery·p0.99:   470.811 ms/op
                 executeQuery·p0.999:  470.811 ms/op
                 executeQuery·p0.9999: 470.811 ms/op
                 executeQuery·p1.00:   470.811 ms/op

Iteration   5: 462.994 ±(99.9%) 3.471 ms/op
                 executeQuery·p0.00:   454.558 ms/op
                 executeQuery·p0.50:   463.733 ms/op
                 executeQuery·p0.90:   468.189 ms/op
                 executeQuery·p0.95:   469.972 ms/op
                 executeQuery·p0.99:   470.286 ms/op
                 executeQuery·p0.999:  470.286 ms/op
                 executeQuery·p0.9999: 470.286 ms/op
                 executeQuery·p1.00:   470.286 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery":
  N = 222
  mean =    463.279 ±(99.9%) 1.760 ms/op

  Histogram, ms/op:
    [440.000, 442.500) = 0 
    [442.500, 445.000) = 0 
    [445.000, 447.500) = 25 
    [447.500, 450.000) = 12 
    [450.000, 452.500) = 1 
    [452.500, 455.000) = 2 
    [455.000, 457.500) = 3 
    [457.500, 460.000) = 1 
    [460.000, 462.500) = 3 
    [462.500, 465.000) = 39 
    [465.000, 467.500) = 66 
    [467.500, 470.000) = 46 
    [470.000, 472.500) = 19 
    [472.500, 475.000) = 3 
    [475.000, 477.500) = 2 

  Percentiles, ms/op:
      p(0.0000) =    445.121 ms/op
     p(50.0000) =    466.092 ms/op
     p(90.0000) =    470.286 ms/op
     p(95.0000) =    471.781 ms/op
     p(99.0000) =    475.167 ms/op
     p(99.9000) =    476.054 ms/op
     p(99.9900) =    476.054 ms/op
     p(99.9990) =    476.054 ms/op
     p(99.9999) =    476.054 ms/op
    p(100.0000) =    476.054 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 80.38% complete, ETA 04:12:56
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 5918.163 ms/op
# Warmup Iteration   2: 4694.824 ±(99.9%) 8134.638 ms/op
# Warmup Iteration   3: 4440.370 ±(99.9%) 88.357 ms/op
# Warmup Iteration   4: 4437.574 ±(99.9%) 153.039 ms/op
# Warmup Iteration   5: 4440.370 ±(99.9%) 385.141 ms/op
Iteration   1: 4434.777 ±(99.9%) 176.715 ms/op
                 executeQuery·p0.00:   4429.185 ms/op
                 executeQuery·p0.50:   4429.185 ms/op
                 executeQuery·p0.90:   4445.962 ms/op
                 executeQuery·p0.95:   4445.962 ms/op
                 executeQuery·p0.99:   4445.962 ms/op
                 executeQuery·p0.999:  4445.962 ms/op
                 executeQuery·p0.9999: 4445.962 ms/op
                 executeQuery·p1.00:   4445.962 ms/op

Iteration   2: 4437.574 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   4437.574 ms/op
                 executeQuery·p0.50:   4437.574 ms/op
                 executeQuery·p0.90:   4437.574 ms/op
                 executeQuery·p0.95:   4437.574 ms/op
                 executeQuery·p0.99:   4437.574 ms/op
                 executeQuery·p0.999:  4437.574 ms/op
                 executeQuery·p0.9999: 4437.574 ms/op
                 executeQuery·p1.00:   4437.574 ms/op

Iteration   3: 4431.981 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4429.185 ms/op
                 executeQuery·p0.50:   4429.185 ms/op
                 executeQuery·p0.90:   4437.574 ms/op
                 executeQuery·p0.95:   4437.574 ms/op
                 executeQuery·p0.99:   4437.574 ms/op
                 executeQuery·p0.999:  4437.574 ms/op
                 executeQuery·p0.9999: 4437.574 ms/op
                 executeQuery·p1.00:   4437.574 ms/op

Iteration   4: 4431.981 ±(99.9%) 233.772 ms/op
                 executeQuery·p0.00:   4420.796 ms/op
                 executeQuery·p0.50:   4429.185 ms/op
                 executeQuery·p0.90:   4445.962 ms/op
                 executeQuery·p0.95:   4445.962 ms/op
                 executeQuery·p0.99:   4445.962 ms/op
                 executeQuery·p0.999:  4445.962 ms/op
                 executeQuery·p0.9999: 4445.962 ms/op
                 executeQuery·p1.00:   4445.962 ms/op

Iteration   5: 4429.185 ±(99.9%) 153.039 ms/op
                 executeQuery·p0.00:   4420.796 ms/op
                 executeQuery·p0.50:   4429.185 ms/op
                 executeQuery·p0.90:   4437.574 ms/op
                 executeQuery·p0.95:   4437.574 ms/op
                 executeQuery·p0.99:   4437.574 ms/op
                 executeQuery·p0.999:  4437.574 ms/op
                 executeQuery·p0.9999: 4437.574 ms/op
                 executeQuery·p1.00:   4437.574 ms/op


# Run progress: 80.70% complete, ETA 04:08:25
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 5658.116 ms/op
# Warmup Iteration   2: 4792.691 ±(99.9%) 10718.589 ms/op
# Warmup Iteration   3: 4420.796 ±(99.9%) 153.039 ms/op
# Warmup Iteration   4: 4420.796 ±(99.9%) 0.001 ms/op
# Warmup Iteration   5: 4426.389 ±(99.9%) 88.357 ms/op
Iteration   1: 4418.000 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4412.408 ms/op
                 executeQuery·p0.50:   4420.796 ms/op
                 executeQuery·p0.90:   4420.796 ms/op
                 executeQuery·p0.95:   4420.796 ms/op
                 executeQuery·p0.99:   4420.796 ms/op
                 executeQuery·p0.999:  4420.796 ms/op
                 executeQuery·p0.9999: 4420.796 ms/op
                 executeQuery·p1.00:   4420.796 ms/op

Iteration   2: 4420.796 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   4420.796 ms/op
                 executeQuery·p0.50:   4420.796 ms/op
                 executeQuery·p0.90:   4420.796 ms/op
                 executeQuery·p0.95:   4420.796 ms/op
                 executeQuery·p0.99:   4420.796 ms/op
                 executeQuery·p0.999:  4420.796 ms/op
                 executeQuery·p0.9999: 4420.796 ms/op
                 executeQuery·p1.00:   4420.796 ms/op

Iteration   3: 4423.593 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4420.796 ms/op
                 executeQuery·p0.50:   4420.796 ms/op
                 executeQuery·p0.90:   4429.185 ms/op
                 executeQuery·p0.95:   4429.185 ms/op
                 executeQuery·p0.99:   4429.185 ms/op
                 executeQuery·p0.999:  4429.185 ms/op
                 executeQuery·p0.9999: 4429.185 ms/op
                 executeQuery·p1.00:   4429.185 ms/op

Iteration   4: 4423.593 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4420.796 ms/op
                 executeQuery·p0.50:   4420.796 ms/op
                 executeQuery·p0.90:   4429.185 ms/op
                 executeQuery·p0.95:   4429.185 ms/op
                 executeQuery·p0.99:   4429.185 ms/op
                 executeQuery·p0.999:  4429.185 ms/op
                 executeQuery·p0.9999: 4429.185 ms/op
                 executeQuery·p1.00:   4429.185 ms/op

Iteration   5: 4423.593 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4420.796 ms/op
                 executeQuery·p0.50:   4420.796 ms/op
                 executeQuery·p0.90:   4429.185 ms/op
                 executeQuery·p0.95:   4429.185 ms/op
                 executeQuery·p0.99:   4429.185 ms/op
                 executeQuery·p0.999:  4429.185 ms/op
                 executeQuery·p0.9999: 4429.185 ms/op
                 executeQuery·p1.00:   4429.185 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery":
  N = 30
  mean =   4427.507 ±(99.9%) 5.585 ms/op

  Histogram, ms/op:
    [4410.000, 4412.500) = 1 
    [4412.500, 4415.000) = 0 
    [4415.000, 4417.500) = 0 
    [4417.500, 4420.000) = 0 
    [4420.000, 4422.500) = 13 
    [4422.500, 4425.000) = 0 
    [4425.000, 4427.500) = 0 
    [4427.500, 4430.000) = 9 
    [4430.000, 4432.500) = 0 
    [4432.500, 4435.000) = 0 
    [4435.000, 4437.500) = 0 
    [4437.500, 4440.000) = 5 
    [4440.000, 4442.500) = 0 
    [4442.500, 4445.000) = 0 
    [4445.000, 4447.500) = 2 

  Percentiles, ms/op:
      p(0.0000) =   4412.408 ms/op
     p(50.0000) =   4429.185 ms/op
     p(90.0000) =   4437.574 ms/op
     p(95.0000) =   4445.962 ms/op
     p(99.0000) =   4445.962 ms/op
     p(99.9000) =   4445.962 ms/op
     p(99.9900) =   4445.962 ms/op
     p(99.9990) =   4445.962 ms/op
     p(99.9999) =   4445.962 ms/op
    p(100.0000) =   4445.962 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 81.01% complete, ETA 04:03:54
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 585.018 ±(99.9%) 87.165 ms/op
# Warmup Iteration   2: 477.027 ±(99.9%) 66.989 ms/op
# Warmup Iteration   3: 442.066 ±(99.9%) 24.259 ms/op
# Warmup Iteration   4: 435.045 ±(99.9%) 3.323 ms/op
# Warmup Iteration   5: 434.224 ±(99.9%) 3.506 ms/op
Iteration   1: 438.738 ±(99.9%) 4.177 ms/op
                 executeQuery·p0.00:   431.489 ms/op
                 executeQuery·p0.50:   437.780 ms/op
                 executeQuery·p0.90:   448.057 ms/op
                 executeQuery·p0.95:   448.266 ms/op
                 executeQuery·p0.99:   448.266 ms/op
                 executeQuery·p0.999:  448.266 ms/op
                 executeQuery·p0.9999: 448.266 ms/op
                 executeQuery·p1.00:   448.266 ms/op

Iteration   2: 420.457 ±(99.9%) 3.696 ms/op
                 executeQuery·p0.00:   415.236 ms/op
                 executeQuery·p0.50:   419.430 ms/op
                 executeQuery·p0.90:   428.081 ms/op
                 executeQuery·p0.95:   434.897 ms/op
                 executeQuery·p0.99:   435.683 ms/op
                 executeQuery·p0.999:  435.683 ms/op
                 executeQuery·p0.9999: 435.683 ms/op
                 executeQuery·p1.00:   435.683 ms/op

Iteration   3: 420.195 ±(99.9%) 1.681 ms/op
                 executeQuery·p0.00:   417.333 ms/op
                 executeQuery·p0.50:   419.693 ms/op
                 executeQuery·p0.90:   423.100 ms/op
                 executeQuery·p0.95:   425.722 ms/op
                 executeQuery·p0.99:   426.246 ms/op
                 executeQuery·p0.999:  426.246 ms/op
                 executeQuery·p0.9999: 426.246 ms/op
                 executeQuery·p1.00:   426.246 ms/op

Iteration   4: 417.792 ±(99.9%) 3.285 ms/op
                 executeQuery·p0.00:   413.663 ms/op
                 executeQuery·p0.50:   416.547 ms/op
                 executeQuery·p0.90:   423.887 ms/op
                 executeQuery·p0.95:   430.572 ms/op
                 executeQuery·p0.99:   432.538 ms/op
                 executeQuery·p0.999:  432.538 ms/op
                 executeQuery·p0.9999: 432.538 ms/op
                 executeQuery·p1.00:   432.538 ms/op

Iteration   5: 416.940 ±(99.9%) 2.827 ms/op
                 executeQuery·p0.00:   405.275 ms/op
                 executeQuery·p0.50:   416.547 ms/op
                 executeQuery·p0.90:   421.265 ms/op
                 executeQuery·p0.95:   423.625 ms/op
                 executeQuery·p0.99:   424.149 ms/op
                 executeQuery·p0.999:  424.149 ms/op
                 executeQuery·p0.9999: 424.149 ms/op
                 executeQuery·p1.00:   424.149 ms/op


# Run progress: 81.33% complete, ETA 03:59:18
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 566.581 ±(99.9%) 92.932 ms/op
# Warmup Iteration   2: 502.032 ±(99.9%) 79.140 ms/op
# Warmup Iteration   3: 438.328 ±(99.9%) 3.930 ms/op
# Warmup Iteration   4: 437.256 ±(99.9%) 2.583 ms/op
# Warmup Iteration   5: 434.407 ±(99.9%) 7.054 ms/op
Iteration   1: 431.991 ±(99.9%) 5.718 ms/op
                 executeQuery·p0.00:   417.858 ms/op
                 executeQuery·p0.50:   434.373 ms/op
                 executeQuery·p0.90:   440.664 ms/op
                 executeQuery·p0.95:   441.319 ms/op
                 executeQuery·p0.99:   441.450 ms/op
                 executeQuery·p0.999:  441.450 ms/op
                 executeQuery·p0.9999: 441.450 ms/op
                 executeQuery·p1.00:   441.450 ms/op

Iteration   2: 437.416 ±(99.9%) 3.292 ms/op
                 executeQuery·p0.00:   429.916 ms/op
                 executeQuery·p0.50:   437.256 ms/op
                 executeQuery·p0.90:   443.653 ms/op
                 executeQuery·p0.95:   444.491 ms/op
                 executeQuery·p0.99:   444.596 ms/op
                 executeQuery·p0.999:  444.596 ms/op
                 executeQuery·p0.9999: 444.596 ms/op
                 executeQuery·p1.00:   444.596 ms/op

Iteration   3: 438.464 ±(99.9%) 3.001 ms/op
                 executeQuery·p0.00:   433.062 ms/op
                 executeQuery·p0.50:   437.780 ms/op
                 executeQuery·p0.90:   444.596 ms/op
                 executeQuery·p0.95:   446.064 ms/op
                 executeQuery·p0.99:   446.169 ms/op
                 executeQuery·p0.999:  446.169 ms/op
                 executeQuery·p0.9999: 446.169 ms/op
                 executeQuery·p1.00:   446.169 ms/op

Iteration   4: 439.148 ±(99.9%) 3.563 ms/op
                 executeQuery·p0.00:   433.062 ms/op
                 executeQuery·p0.50:   437.780 ms/op
                 executeQuery·p0.90:   447.637 ms/op
                 executeQuery·p0.95:   450.363 ms/op
                 executeQuery·p0.99:   450.888 ms/op
                 executeQuery·p0.999:  450.888 ms/op
                 executeQuery·p0.9999: 450.888 ms/op
                 executeQuery·p1.00:   450.888 ms/op

Iteration   5: 437.370 ±(99.9%) 3.459 ms/op
                 executeQuery·p0.00:   428.868 ms/op
                 executeQuery·p0.50:   438.305 ms/op
                 executeQuery·p0.90:   441.975 ms/op
                 executeQuery·p0.95:   441.975 ms/op
                 executeQuery·p0.99:   441.975 ms/op
                 executeQuery·p0.999:  441.975 ms/op
                 executeQuery·p0.9999: 441.975 ms/op
                 executeQuery·p1.00:   441.975 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 235
  mean =    429.673 ±(99.9%) 2.242 ms/op

  Histogram, ms/op:
    [400.000, 405.000) = 0 
    [405.000, 410.000) = 1 
    [410.000, 415.000) = 9 
    [415.000, 420.000) = 61 
    [420.000, 425.000) = 27 
    [425.000, 430.000) = 7 
    [430.000, 435.000) = 32 
    [435.000, 440.000) = 57 
    [440.000, 445.000) = 32 
    [445.000, 450.000) = 8 
    [450.000, 455.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    405.275 ms/op
     p(50.0000) =    433.062 ms/op
     p(90.0000) =    441.450 ms/op
     p(95.0000) =    444.596 ms/op
     p(99.0000) =    448.266 ms/op
     p(99.9000) =    450.888 ms/op
     p(99.9900) =    450.888 ms/op
     p(99.9990) =    450.888 ms/op
     p(99.9999) =    450.888 ms/op
    p(100.0000) =    450.888 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 81.65% complete, ETA 03:54:43
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 5385.486 ms/op
# Warmup Iteration   2: 4450.157 ±(99.9%) 9593.083 ms/op
# Warmup Iteration   3: 4083.854 ±(99.9%) 785.337 ms/op
# Warmup Iteration   4: 4054.494 ±(99.9%) 1158.796 ms/op
# Warmup Iteration   5: 4043.309 ±(99.9%) 477.865 ms/op
Iteration   1: 4064.281 ±(99.9%) 1178.006 ms/op
                 executeQuery·p0.00:   4009.755 ms/op
                 executeQuery·p0.50:   4047.503 ms/op
                 executeQuery·p0.90:   4135.584 ms/op
                 executeQuery·p0.95:   4135.584 ms/op
                 executeQuery·p0.99:   4135.584 ms/op
                 executeQuery·p0.999:  4135.584 ms/op
                 executeQuery·p0.9999: 4135.584 ms/op
                 executeQuery·p1.00:   4135.584 ms/op

Iteration   2: 4082.456 ±(99.9%) 896.729 ms/op
                 executeQuery·p0.00:   4026.532 ms/op
                 executeQuery·p0.50:   4102.029 ms/op
                 executeQuery·p0.90:   4118.807 ms/op
                 executeQuery·p0.95:   4118.807 ms/op
                 executeQuery·p0.99:   4118.807 ms/op
                 executeQuery·p0.999:  4118.807 ms/op
                 executeQuery·p0.9999: 4118.807 ms/op
                 executeQuery·p1.00:   4118.807 ms/op

Iteration   3: 4090.845 ±(99.9%) 392.669 ms/op
                 executeQuery·p0.00:   4072.669 ms/op
                 executeQuery·p0.50:   4085.252 ms/op
                 executeQuery·p0.90:   4114.612 ms/op
                 executeQuery·p0.95:   4114.612 ms/op
                 executeQuery·p0.99:   4114.612 ms/op
                 executeQuery·p0.999:  4114.612 ms/op
                 executeQuery·p0.9999: 4114.612 ms/op
                 executeQuery·p1.00:   4114.612 ms/op

Iteration   4: 4104.826 ±(99.9%) 116.886 ms/op
                 executeQuery·p0.00:   4097.835 ms/op
                 executeQuery·p0.50:   4106.224 ms/op
                 executeQuery·p0.90:   4110.418 ms/op
                 executeQuery·p0.95:   4110.418 ms/op
                 executeQuery·p0.99:   4110.418 ms/op
                 executeQuery·p0.999:  4110.418 ms/op
                 executeQuery·p0.9999: 4110.418 ms/op
                 executeQuery·p1.00:   4110.418 ms/op

Iteration   5: 4104.826 ±(99.9%) 421.438 ms/op
                 executeQuery·p0.00:   4089.446 ms/op
                 executeQuery·p0.50:   4093.641 ms/op
                 executeQuery·p0.90:   4131.389 ms/op
                 executeQuery·p0.95:   4131.389 ms/op
                 executeQuery·p0.99:   4131.389 ms/op
                 executeQuery·p0.999:  4131.389 ms/op
                 executeQuery·p0.9999: 4131.389 ms/op
                 executeQuery·p1.00:   4131.389 ms/op


# Run progress: 81.96% complete, ETA 03:50:14
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 5410.652 ms/op
# Warmup Iteration   2: 4483.711 ±(99.9%) 9843.720 ms/op
# Warmup Iteration   3: 4171.934 ±(99.9%) 345.047 ms/op
# Warmup Iteration   4: 4118.807 ±(99.9%) 662.680 ms/op
# Warmup Iteration   5: 4135.584 ±(99.9%) 1457.896 ms/op
Iteration   1: 4134.186 ±(99.9%) 520.859 ms/op
                 executeQuery·p0.00:   4102.029 ms/op
                 executeQuery·p0.50:   4143.972 ms/op
                 executeQuery·p0.90:   4156.555 ms/op
                 executeQuery·p0.95:   4156.555 ms/op
                 executeQuery·p0.99:   4156.555 ms/op
                 executeQuery·p0.999:  4156.555 ms/op
                 executeQuery·p0.9999: 4156.555 ms/op
                 executeQuery·p1.00:   4156.555 ms/op

Iteration   2: 4099.233 ±(99.9%) 345.047 ms/op
                 executeQuery·p0.00:   4081.058 ms/op
                 executeQuery·p0.50:   4097.835 ms/op
                 executeQuery·p0.90:   4118.807 ms/op
                 executeQuery·p0.95:   4118.807 ms/op
                 executeQuery·p0.99:   4118.807 ms/op
                 executeQuery·p0.999:  4118.807 ms/op
                 executeQuery·p0.9999: 4118.807 ms/op
                 executeQuery·p1.00:   4118.807 ms/op

Iteration   3: 4102.029 ±(99.9%) 76.520 ms/op
                 executeQuery·p0.00:   4097.835 ms/op
                 executeQuery·p0.50:   4102.029 ms/op
                 executeQuery·p0.90:   4106.224 ms/op
                 executeQuery·p0.95:   4106.224 ms/op
                 executeQuery·p0.99:   4106.224 ms/op
                 executeQuery·p0.999:  4106.224 ms/op
                 executeQuery·p0.9999: 4106.224 ms/op
                 executeQuery·p1.00:   4106.224 ms/op

Iteration   4: 4117.408 ±(99.9%) 159.288 ms/op
                 executeQuery·p0.00:   4110.418 ms/op
                 executeQuery·p0.50:   4114.612 ms/op
                 executeQuery·p0.90:   4127.195 ms/op
                 executeQuery·p0.95:   4127.195 ms/op
                 executeQuery·p0.99:   4127.195 ms/op
                 executeQuery·p0.999:  4127.195 ms/op
                 executeQuery·p0.9999: 4127.195 ms/op
                 executeQuery·p1.00:   4127.195 ms/op

Iteration   5: 4110.418 ±(99.9%) 76.520 ms/op
                 executeQuery·p0.00:   4106.224 ms/op
                 executeQuery·p0.50:   4110.418 ms/op
                 executeQuery·p0.90:   4114.612 ms/op
                 executeQuery·p0.95:   4114.612 ms/op
                 executeQuery·p0.99:   4114.612 ms/op
                 executeQuery·p0.999:  4114.612 ms/op
                 executeQuery·p0.9999: 4114.612 ms/op
                 executeQuery·p1.00:   4114.612 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 30
  mean =   4101.051 ±(99.9%) 20.641 ms/op

  Histogram, ms/op:
    [4000.000, 4012.500) = 1 
    [4012.500, 4025.000) = 0 
    [4025.000, 4037.500) = 1 
    [4037.500, 4050.000) = 1 
    [4050.000, 4062.500) = 0 
    [4062.500, 4075.000) = 1 
    [4075.000, 4087.500) = 2 
    [4087.500, 4100.000) = 5 
    [4100.000, 4112.500) = 9 
    [4112.500, 4125.000) = 5 
    [4125.000, 4137.500) = 3 
    [4137.500, 4150.000) = 1 
    [4150.000, 4162.500) = 1 
    [4162.500, 4175.000) = 0 
    [4175.000, 4187.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   4009.755 ms/op
     p(50.0000) =   4106.224 ms/op
     p(90.0000) =   4135.164 ms/op
     p(95.0000) =   4149.635 ms/op
     p(99.0000) =   4156.555 ms/op
     p(99.9000) =   4156.555 ms/op
     p(99.9900) =   4156.555 ms/op
     p(99.9990) =   4156.555 ms/op
     p(99.9999) =   4156.555 ms/op
    p(100.0000) =   4156.555 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 82.28% complete, ETA 03:45:46
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 673.326 ±(99.9%) 164.621 ms/op
# Warmup Iteration   2: 591.212 ±(99.9%) 101.362 ms/op
# Warmup Iteration   3: 518.364 ±(99.9%) 3.116 ms/op
# Warmup Iteration   4: 508.009 ±(99.9%) 8.854 ms/op
# Warmup Iteration   5: 518.599 ±(99.9%) 1.916 ms/op
Iteration   1: 512.596 ±(99.9%) 7.153 ms/op
                 executeQuery·p0.00:   495.452 ms/op
                 executeQuery·p0.50:   516.424 ms/op
                 executeQuery·p0.90:   518.416 ms/op
                 executeQuery·p0.95:   523.003 ms/op
                 executeQuery·p0.99:   523.239 ms/op
                 executeQuery·p0.999:  523.239 ms/op
                 executeQuery·p0.9999: 523.239 ms/op
                 executeQuery·p1.00:   523.239 ms/op

Iteration   2: 515.165 ±(99.9%) 7.819 ms/op
                 executeQuery·p0.00:   497.549 ms/op
                 executeQuery·p0.50:   517.734 ms/op
                 executeQuery·p0.90:   522.191 ms/op
                 executeQuery·p0.95:   529.662 ms/op
                 executeQuery·p0.99:   530.055 ms/op
                 executeQuery·p0.999:  530.055 ms/op
                 executeQuery·p0.9999: 530.055 ms/op
                 executeQuery·p1.00:   530.055 ms/op

Iteration   3: 508.455 ±(99.9%) 8.406 ms/op
                 executeQuery·p0.00:   495.976 ms/op
                 executeQuery·p0.50:   510.657 ms/op
                 executeQuery·p0.90:   519.569 ms/op
                 executeQuery·p0.95:   521.064 ms/op
                 executeQuery·p0.99:   521.142 ms/op
                 executeQuery·p0.999:  521.142 ms/op
                 executeQuery·p0.9999: 521.142 ms/op
                 executeQuery·p1.00:   521.142 ms/op

Iteration   4: 520.749 ±(99.9%) 3.371 ms/op
                 executeQuery·p0.00:   513.278 ms/op
                 executeQuery·p0.50:   520.618 ms/op
                 executeQuery·p0.90:   525.651 ms/op
                 executeQuery·p0.95:   529.845 ms/op
                 executeQuery·p0.99:   530.055 ms/op
                 executeQuery·p0.999:  530.055 ms/op
                 executeQuery·p0.9999: 530.055 ms/op
                 executeQuery·p1.00:   530.055 ms/op

Iteration   5: 518.023 ±(99.9%) 2.033 ms/op
                 executeQuery·p0.00:   514.851 ms/op
                 executeQuery·p0.50:   517.734 ms/op
                 executeQuery·p0.90:   521.667 ms/op
                 executeQuery·p0.95:   521.667 ms/op
                 executeQuery·p0.99:   521.667 ms/op
                 executeQuery·p0.999:  521.667 ms/op
                 executeQuery·p0.9999: 521.667 ms/op
                 executeQuery·p1.00:   521.667 ms/op


# Run progress: 82.59% complete, ETA 03:41:15
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 688.879 ±(99.9%) 159.069 ms/op
# Warmup Iteration   2: 591.243 ±(99.9%) 104.692 ms/op
# Warmup Iteration   3: 517.420 ±(99.9%) 2.783 ms/op
# Warmup Iteration   4: 516.319 ±(99.9%) 2.809 ms/op
# Warmup Iteration   5: 513.514 ±(99.9%) 2.324 ms/op
Iteration   1: 515.087 ±(99.9%) 7.993 ms/op
                 executeQuery·p0.00:   499.646 ms/op
                 executeQuery·p0.50:   516.686 ms/op
                 executeQuery·p0.90:   524.288 ms/op
                 executeQuery·p0.95:   525.782 ms/op
                 executeQuery·p0.99:   525.861 ms/op
                 executeQuery·p0.999:  525.861 ms/op
                 executeQuery·p0.9999: 525.861 ms/op
                 executeQuery·p1.00:   525.861 ms/op

Iteration   2: 512.046 ±(99.9%) 6.672 ms/op
                 executeQuery·p0.00:   492.306 ms/op
                 executeQuery·p0.50:   512.492 ms/op
                 executeQuery·p0.90:   517.997 ms/op
                 executeQuery·p0.95:   524.970 ms/op
                 executeQuery·p0.99:   525.337 ms/op
                 executeQuery·p0.999:  525.337 ms/op
                 executeQuery·p0.9999: 525.337 ms/op
                 executeQuery·p1.00:   525.337 ms/op

Iteration   3: 493.705 ±(99.9%) 2.238 ms/op
                 executeQuery·p0.00:   490.734 ms/op
                 executeQuery·p0.50:   493.355 ms/op
                 executeQuery·p0.90:   495.872 ms/op
                 executeQuery·p0.95:   502.582 ms/op
                 executeQuery·p0.99:   503.316 ms/op
                 executeQuery·p0.999:  503.316 ms/op
                 executeQuery·p0.9999: 503.316 ms/op
                 executeQuery·p1.00:   503.316 ms/op

Iteration   4: 494.404 ±(99.9%) 2.657 ms/op
                 executeQuery·p0.00:   490.734 ms/op
                 executeQuery·p0.50:   493.879 ms/op
                 executeQuery·p0.90:   500.590 ms/op
                 executeQuery·p0.95:   503.159 ms/op
                 executeQuery·p0.99:   503.316 ms/op
                 executeQuery·p0.999:  503.316 ms/op
                 executeQuery·p0.9999: 503.316 ms/op
                 executeQuery·p1.00:   503.316 ms/op

Iteration   5: 493.055 ±(99.9%) 1.383 ms/op
                 executeQuery·p0.00:   490.734 ms/op
                 executeQuery·p0.50:   492.831 ms/op
                 executeQuery·p0.90:   495.452 ms/op
                 executeQuery·p0.95:   496.396 ms/op
                 executeQuery·p0.99:   496.501 ms/op
                 executeQuery·p0.999:  496.501 ms/op
                 executeQuery·p0.9999: 496.501 ms/op
                 executeQuery·p1.00:   496.501 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery":
  N = 203
  mean =    508.113 ±(99.9%) 2.810 ms/op

  Histogram, ms/op:
    [490.000, 495.000) = 54 
    [495.000, 500.000) = 24 
    [500.000, 505.000) = 9 
    [505.000, 510.000) = 4 
    [510.000, 515.000) = 19 
    [515.000, 520.000) = 58 
    [520.000, 525.000) = 30 
    [525.000, 530.000) = 3 
    [530.000, 535.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =    490.734 ms/op
     p(50.0000) =    513.278 ms/op
     p(90.0000) =    521.667 ms/op
     p(95.0000) =    523.764 ms/op
     p(99.0000) =    529.887 ms/op
     p(99.9000) =    530.055 ms/op
     p(99.9900) =    530.055 ms/op
     p(99.9990) =    530.055 ms/op
     p(99.9999) =    530.055 ms/op
    p(100.0000) =    530.055 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 82.91% complete, ETA 03:36:46
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 6513.754 ms/op
# Warmup Iteration   2: 4952.075 ±(99.9%) 4745.045 ms/op
# Warmup Iteration   3: 4977.241 ±(99.9%) 995.737 ms/op
# Warmup Iteration   4: 4926.909 ±(99.9%) 88.357 ms/op
# Warmup Iteration   5: 4915.724 ±(99.9%) 306.079 ms/op
Iteration   1: 4912.928 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4907.336 ms/op
                 executeQuery·p0.50:   4915.724 ms/op
                 executeQuery·p0.90:   4915.724 ms/op
                 executeQuery·p0.95:   4915.724 ms/op
                 executeQuery·p0.99:   4915.724 ms/op
                 executeQuery·p0.999:  4915.724 ms/op
                 executeQuery·p0.9999: 4915.724 ms/op
                 executeQuery·p1.00:   4915.724 ms/op

Iteration   2: 4901.743 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4898.947 ms/op
                 executeQuery·p0.50:   4898.947 ms/op
                 executeQuery·p0.90:   4907.336 ms/op
                 executeQuery·p0.95:   4907.336 ms/op
                 executeQuery·p0.99:   4907.336 ms/op
                 executeQuery·p0.999:  4907.336 ms/op
                 executeQuery·p0.9999: 4907.336 ms/op
                 executeQuery·p1.00:   4907.336 ms/op

Iteration   3: 4910.132 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4907.336 ms/op
                 executeQuery·p0.50:   4907.336 ms/op
                 executeQuery·p0.90:   4915.724 ms/op
                 executeQuery·p0.95:   4915.724 ms/op
                 executeQuery·p0.99:   4915.724 ms/op
                 executeQuery·p0.999:  4915.724 ms/op
                 executeQuery·p0.9999: 4915.724 ms/op
                 executeQuery·p1.00:   4915.724 ms/op

Iteration   4: 4918.520 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   4915.724 ms/op
                 executeQuery·p0.50:   4915.724 ms/op
                 executeQuery·p0.90:   4924.113 ms/op
                 executeQuery·p0.95:   4924.113 ms/op
                 executeQuery·p0.99:   4924.113 ms/op
                 executeQuery·p0.999:  4924.113 ms/op
                 executeQuery·p0.9999: 4924.113 ms/op
                 executeQuery·p1.00:   4924.113 ms/op

Iteration   5: 4915.724 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   4915.724 ms/op
                 executeQuery·p0.50:   4915.724 ms/op
                 executeQuery·p0.90:   4915.724 ms/op
                 executeQuery·p0.95:   4915.724 ms/op
                 executeQuery·p0.99:   4915.724 ms/op
                 executeQuery·p0.999:  4915.724 ms/op
                 executeQuery·p0.9999: 4915.724 ms/op
                 executeQuery·p1.00:   4915.724 ms/op


# Run progress: 83.23% complete, ETA 03:32:26
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 6496.977 ms/op
# Warmup Iteration   2: 4954.871 ±(99.9%) 4525.243 ms/op
# Warmup Iteration   3: 4985.629 ±(99.9%) 579.398 ms/op
# Warmup Iteration   4: 5012.193 ms/op
# Warmup Iteration   5: 5007.999 ms/op
Iteration   1: 5007.999 ms/op
                 executeQuery·p0.00:   5007.999 ms/op
                 executeQuery·p0.50:   5007.999 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   2: 5007.999 ms/op
                 executeQuery·p0.00:   5007.999 ms/op
                 executeQuery·p0.50:   5007.999 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   3: 4999.610 ms/op
                 executeQuery·p0.00:   4999.610 ms/op
                 executeQuery·p0.50:   4999.610 ms/op
                 executeQuery·p0.90:   4999.610 ms/op
                 executeQuery·p0.95:   4999.610 ms/op
                 executeQuery·p0.99:   4999.610 ms/op
                 executeQuery·p0.999:  4999.610 ms/op
                 executeQuery·p0.9999: 4999.610 ms/op
                 executeQuery·p1.00:   4999.610 ms/op

Iteration   4: 5003.805 ms/op
                 executeQuery·p0.00:   4999.610 ms/op
                 executeQuery·p0.50:   5003.805 ms/op
                 executeQuery·p0.90:   5007.999 ms/op
                 executeQuery·p0.95:   5007.999 ms/op
                 executeQuery·p0.99:   5007.999 ms/op
                 executeQuery·p0.999:  5007.999 ms/op
                 executeQuery·p0.9999: 5007.999 ms/op
                 executeQuery·p1.00:   5007.999 ms/op

Iteration   5: 4977.241 ±(99.9%) 579.398 ms/op
                 executeQuery·p0.00:   4940.890 ms/op
                 executeQuery·p0.50:   4991.222 ms/op
                 executeQuery·p0.90:   4999.610 ms/op
                 executeQuery·p0.95:   4999.610 ms/op
                 executeQuery·p0.99:   4999.610 ms/op
                 executeQuery·p0.999:  4999.610 ms/op
                 executeQuery·p0.9999: 4999.610 ms/op
                 executeQuery·p1.00:   4999.610 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery":
  N = 26
  mean =   4947.988 ±(99.9%) 32.966 ms/op

  Histogram, ms/op:
    [4800.000, 4825.000) = 0 
    [4825.000, 4850.000) = 0 
    [4850.000, 4875.000) = 0 
    [4875.000, 4900.000) = 2 
    [4900.000, 4925.000) = 13 
    [4925.000, 4950.000) = 1 
    [4950.000, 4975.000) = 0 
    [4975.000, 5000.000) = 5 
    [5000.000, 5025.000) = 5 
    [5025.000, 5050.000) = 0 
    [5050.000, 5075.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   4898.947 ms/op
     p(50.0000) =   4915.724 ms/op
     p(90.0000) =   5007.999 ms/op
     p(95.0000) =   5007.999 ms/op
     p(99.0000) =   5007.999 ms/op
     p(99.9000) =   5007.999 ms/op
     p(99.9900) =   5007.999 ms/op
     p(99.9990) =   5007.999 ms/op
     p(99.9999) =   5007.999 ms/op
    p(100.0000) =   5007.999 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 83.54% complete, ETA 03:28:02
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 772.155 ±(99.9%) 183.659 ms/op
# Warmup Iteration   2: 691.641 ±(99.9%) 101.229 ms/op
# Warmup Iteration   3: 615.761 ±(99.9%) 67.647 ms/op
# Warmup Iteration   4: 584.465 ±(99.9%) 2.914 ms/op
# Warmup Iteration   5: 584.290 ±(99.9%) 2.060 ms/op
Iteration   1: 583.067 ±(99.9%) 2.267 ms/op
                 executeQuery·p0.00:   580.911 ms/op
                 executeQuery·p0.50:   583.008 ms/op
                 executeQuery·p0.90:   585.735 ms/op
                 executeQuery·p0.95:   591.397 ms/op
                 executeQuery·p0.99:   591.397 ms/op
                 executeQuery·p0.999:  591.397 ms/op
                 executeQuery·p0.9999: 591.397 ms/op
                 executeQuery·p1.00:   591.397 ms/op

Iteration   2: 584.057 ±(99.9%) 4.472 ms/op
                 executeQuery·p0.00:   579.863 ms/op
                 executeQuery·p0.50:   583.008 ms/op
                 executeQuery·p0.90:   591.397 ms/op
                 executeQuery·p0.95:   600.834 ms/op
                 executeQuery·p0.99:   600.834 ms/op
                 executeQuery·p0.999:  600.834 ms/op
                 executeQuery·p0.9999: 600.834 ms/op
                 executeQuery·p1.00:   600.834 ms/op

Iteration   3: 583.824 ±(99.9%) 3.234 ms/op
                 executeQuery·p0.00:   579.863 ms/op
                 executeQuery·p0.50:   583.008 ms/op
                 executeQuery·p0.90:   590.768 ms/op
                 executeQuery·p0.95:   594.543 ms/op
                 executeQuery·p0.99:   594.543 ms/op
                 executeQuery·p0.999:  594.543 ms/op
                 executeQuery·p0.9999: 594.543 ms/op
                 executeQuery·p1.00:   594.543 ms/op

Iteration   4: 587.079 ±(99.9%) 2.524 ms/op
                 executeQuery·p0.00:   580.911 ms/op
                 executeQuery·p0.50:   587.203 ms/op
                 executeQuery·p0.90:   590.977 ms/op
                 executeQuery·p0.95:   593.494 ms/op
                 executeQuery·p0.99:   593.494 ms/op
                 executeQuery·p0.999:  593.494 ms/op
                 executeQuery·p0.9999: 593.494 ms/op
                 executeQuery·p1.00:   593.494 ms/op

Iteration   5: 582.775 ±(99.9%) 3.054 ms/op
                 executeQuery·p0.00:   579.863 ms/op
                 executeQuery·p0.50:   581.960 ms/op
                 executeQuery·p0.90:   586.049 ms/op
                 executeQuery·p0.95:   594.543 ms/op
                 executeQuery·p0.99:   594.543 ms/op
                 executeQuery·p0.999:  594.543 ms/op
                 executeQuery·p0.9999: 594.543 ms/op
                 executeQuery·p1.00:   594.543 ms/op


# Run progress: 83.86% complete, ETA 03:23:36
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 766.135 ±(99.9%) 159.578 ms/op
# Warmup Iteration   2: 654.377 ±(99.9%) 107.943 ms/op
# Warmup Iteration   3: 612.615 ±(99.9%) 58.288 ms/op
# Warmup Iteration   4: 589.731 ±(99.9%) 3.464 ms/op
# Warmup Iteration   5: 588.621 ±(99.9%) 3.518 ms/op
Iteration   1: 588.374 ±(99.9%) 2.575 ms/op
                 executeQuery·p0.00:   580.911 ms/op
                 executeQuery·p0.50:   588.251 ms/op
                 executeQuery·p0.90:   591.187 ms/op
                 executeQuery·p0.95:   594.543 ms/op
                 executeQuery·p0.99:   594.543 ms/op
                 executeQuery·p0.999:  594.543 ms/op
                 executeQuery·p0.9999: 594.543 ms/op
                 executeQuery·p1.00:   594.543 ms/op

Iteration   2: 602.314 ±(99.9%) 2.654 ms/op
                 executeQuery·p0.00:   596.640 ms/op
                 executeQuery·p0.50:   601.883 ms/op
                 executeQuery·p0.90:   605.657 ms/op
                 executeQuery·p0.95:   608.174 ms/op
                 executeQuery·p0.99:   608.174 ms/op
                 executeQuery·p0.999:  608.174 ms/op
                 executeQuery·p0.9999: 608.174 ms/op
                 executeQuery·p1.00:   608.174 ms/op

Iteration   3: 601.513 ±(99.9%) 3.698 ms/op
                 executeQuery·p0.00:   597.688 ms/op
                 executeQuery·p0.50:   600.834 ms/op
                 executeQuery·p0.90:   605.867 ms/op
                 executeQuery·p0.95:   613.417 ms/op
                 executeQuery·p0.99:   613.417 ms/op
                 executeQuery·p0.999:  613.417 ms/op
                 executeQuery·p0.9999: 613.417 ms/op
                 executeQuery·p1.00:   613.417 ms/op

Iteration   4: 601.451 ±(99.9%) 4.226 ms/op
                 executeQuery·p0.00:   594.543 ms/op
                 executeQuery·p0.50:   601.883 ms/op
                 executeQuery·p0.90:   606.496 ms/op
                 executeQuery·p0.95:   612.368 ms/op
                 executeQuery·p0.99:   612.368 ms/op
                 executeQuery·p0.999:  612.368 ms/op
                 executeQuery·p0.9999: 612.368 ms/op
                 executeQuery·p1.00:   612.368 ms/op

Iteration   5: 602.129 ±(99.9%) 3.980 ms/op
                 executeQuery·p0.00:   592.445 ms/op
                 executeQuery·p0.50:   602.931 ms/op
                 executeQuery·p0.90:   609.432 ms/op
                 executeQuery·p0.95:   610.271 ms/op
                 executeQuery·p0.99:   610.271 ms/op
                 executeQuery·p0.999:  610.271 ms/op
                 executeQuery·p0.9999: 610.271 ms/op
                 executeQuery·p1.00:   610.271 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 174
  mean =    591.469 ±(99.9%) 2.325 ms/op

  Histogram, ms/op:
    [570.000, 575.000) = 0 
    [575.000, 580.000) = 4 
    [580.000, 585.000) = 58 
    [585.000, 590.000) = 33 
    [590.000, 595.000) = 12 
    [595.000, 600.000) = 19 
    [600.000, 605.000) = 37 
    [605.000, 610.000) = 8 
    [610.000, 615.000) = 3 

  Percentiles, ms/op:
      p(0.0000) =    579.863 ms/op
     p(50.0000) =    588.251 ms/op
     p(90.0000) =    603.980 ms/op
     p(95.0000) =    605.028 ms/op
     p(99.0000) =    612.631 ms/op
     p(99.9000) =    613.417 ms/op
     p(99.9900) =    613.417 ms/op
     p(99.9990) =    613.417 ms/op
     p(99.9999) =    613.417 ms/op
    p(100.0000) =    613.417 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 84.18% complete, ETA 03:19:11
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 7348.421 ms/op
# Warmup Iteration   2: 5721.031 ms/op
# Warmup Iteration   3: 5792.334 ms/op
# Warmup Iteration   4: 5804.917 ms/op
# Warmup Iteration   5: 5809.111 ms/op
Iteration   1: 5783.945 ms/op
                 executeQuery·p0.00:   5779.751 ms/op
                 executeQuery·p0.50:   5783.945 ms/op
                 executeQuery·p0.90:   5788.140 ms/op
                 executeQuery·p0.95:   5788.140 ms/op
                 executeQuery·p0.99:   5788.140 ms/op
                 executeQuery·p0.999:  5788.140 ms/op
                 executeQuery·p0.9999: 5788.140 ms/op
                 executeQuery·p1.00:   5788.140 ms/op

Iteration   2: 5809.111 ms/op
                 executeQuery·p0.00:   5804.917 ms/op
                 executeQuery·p0.50:   5809.111 ms/op
                 executeQuery·p0.90:   5813.305 ms/op
                 executeQuery·p0.95:   5813.305 ms/op
                 executeQuery·p0.99:   5813.305 ms/op
                 executeQuery·p0.999:  5813.305 ms/op
                 executeQuery·p0.9999: 5813.305 ms/op
                 executeQuery·p1.00:   5813.305 ms/op

Iteration   3: 5800.722 ms/op
                 executeQuery·p0.00:   5796.528 ms/op
                 executeQuery·p0.50:   5800.722 ms/op
                 executeQuery·p0.90:   5804.917 ms/op
                 executeQuery·p0.95:   5804.917 ms/op
                 executeQuery·p0.99:   5804.917 ms/op
                 executeQuery·p0.999:  5804.917 ms/op
                 executeQuery·p0.9999: 5804.917 ms/op
                 executeQuery·p1.00:   5804.917 ms/op

Iteration   4: 5796.528 ms/op
                 executeQuery·p0.00:   5788.140 ms/op
                 executeQuery·p0.50:   5796.528 ms/op
                 executeQuery·p0.90:   5804.917 ms/op
                 executeQuery·p0.95:   5804.917 ms/op
                 executeQuery·p0.99:   5804.917 ms/op
                 executeQuery·p0.999:  5804.917 ms/op
                 executeQuery·p0.9999: 5804.917 ms/op
                 executeQuery·p1.00:   5804.917 ms/op

Iteration   5: 5804.917 ms/op
                 executeQuery·p0.00:   5804.917 ms/op
                 executeQuery·p0.50:   5804.917 ms/op
                 executeQuery·p0.90:   5804.917 ms/op
                 executeQuery·p0.95:   5804.917 ms/op
                 executeQuery·p0.99:   5804.917 ms/op
                 executeQuery·p0.999:  5804.917 ms/op
                 executeQuery·p0.9999: 5804.917 ms/op
                 executeQuery·p1.00:   5804.917 ms/op


# Run progress: 84.49% complete, ETA 03:14:50
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 7319.060 ms/op
# Warmup Iteration   2: 5704.253 ms/op
# Warmup Iteration   3: 5800.722 ms/op
# Warmup Iteration   4: 5817.500 ms/op
# Warmup Iteration   5: 5813.305 ms/op
Iteration   1: 5804.917 ms/op
                 executeQuery·p0.00:   5796.528 ms/op
                 executeQuery·p0.50:   5804.917 ms/op
                 executeQuery·p0.90:   5813.305 ms/op
                 executeQuery·p0.95:   5813.305 ms/op
                 executeQuery·p0.99:   5813.305 ms/op
                 executeQuery·p0.999:  5813.305 ms/op
                 executeQuery·p0.9999: 5813.305 ms/op
                 executeQuery·p1.00:   5813.305 ms/op

Iteration   2: 5800.722 ms/op
                 executeQuery·p0.00:   5796.528 ms/op
                 executeQuery·p0.50:   5800.722 ms/op
                 executeQuery·p0.90:   5804.917 ms/op
                 executeQuery·p0.95:   5804.917 ms/op
                 executeQuery·p0.99:   5804.917 ms/op
                 executeQuery·p0.999:  5804.917 ms/op
                 executeQuery·p0.9999: 5804.917 ms/op
                 executeQuery·p1.00:   5804.917 ms/op

Iteration   3: 5804.917 ms/op
                 executeQuery·p0.00:   5796.528 ms/op
                 executeQuery·p0.50:   5804.917 ms/op
                 executeQuery·p0.90:   5813.305 ms/op
                 executeQuery·p0.95:   5813.305 ms/op
                 executeQuery·p0.99:   5813.305 ms/op
                 executeQuery·p0.999:  5813.305 ms/op
                 executeQuery·p0.9999: 5813.305 ms/op
                 executeQuery·p1.00:   5813.305 ms/op

Iteration   4: 5750.391 ms/op
                 executeQuery·p0.00:   5687.476 ms/op
                 executeQuery·p0.50:   5750.391 ms/op
                 executeQuery·p0.90:   5813.305 ms/op
                 executeQuery·p0.95:   5813.305 ms/op
                 executeQuery·p0.99:   5813.305 ms/op
                 executeQuery·p0.999:  5813.305 ms/op
                 executeQuery·p0.9999: 5813.305 ms/op
                 executeQuery·p1.00:   5813.305 ms/op

Iteration   5: 5804.917 ms/op
                 executeQuery·p0.00:   5796.528 ms/op
                 executeQuery·p0.50:   5804.917 ms/op
                 executeQuery·p0.90:   5813.305 ms/op
                 executeQuery·p0.95:   5813.305 ms/op
                 executeQuery·p0.99:   5813.305 ms/op
                 executeQuery·p0.999:  5813.305 ms/op
                 executeQuery·p0.9999: 5813.305 ms/op
                 executeQuery·p1.00:   5813.305 ms/op



Result "benchmarks.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 20
  mean =   5796.109 ±(99.9%) 23.689 ms/op

  Histogram, ms/op:
    [5600.000, 5625.000) = 0 
    [5625.000, 5650.000) = 0 
    [5650.000, 5675.000) = 0 
    [5675.000, 5700.000) = 1 
    [5700.000, 5725.000) = 0 
    [5725.000, 5750.000) = 0 
    [5750.000, 5775.000) = 0 
    [5775.000, 5800.000) = 8 
    [5800.000, 5825.000) = 11 
    [5825.000, 5850.000) = 0 
    [5850.000, 5875.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   5687.476 ms/op
     p(50.0000) =   5804.917 ms/op
     p(90.0000) =   5813.305 ms/op
     p(95.0000) =   5813.305 ms/op
     p(99.0000) =   5813.305 ms/op
     p(99.9000) =   5813.305 ms/op
     p(99.9900) =   5813.305 ms/op
     p(99.9990) =   5813.305 ms/op
     p(99.9999) =   5813.305 ms/op
    p(100.0000) =   5813.305 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 84.81% complete, ETA 03:10:30
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 286.464 ±(99.9%) 34.126 ms/op
# Warmup Iteration   2: 268.495 ±(99.9%) 3.881 ms/op
# Warmup Iteration   3: 262.960 ±(99.9%) 2.738 ms/op
# Warmup Iteration   4: 263.193 ±(99.9%) 4.283 ms/op
# Warmup Iteration   5: 262.654 ±(99.9%) 4.798 ms/op
Iteration   1: 260.862 ±(99.9%) 2.966 ms/op
                 executeQuery·p0.00:   249.561 ms/op
                 executeQuery·p0.50:   261.226 ms/op
                 executeQuery·p0.90:   266.076 ms/op
                 executeQuery·p0.95:   272.263 ms/op
                 executeQuery·p0.99:   273.154 ms/op
                 executeQuery·p0.999:  273.154 ms/op
                 executeQuery·p0.9999: 273.154 ms/op
                 executeQuery·p1.00:   273.154 ms/op

Iteration   2: 260.455 ±(99.9%) 4.312 ms/op
                 executeQuery·p0.00:   246.678 ms/op
                 executeQuery·p0.50:   259.785 ms/op
                 executeQuery·p0.90:   271.896 ms/op
                 executeQuery·p0.95:   272.866 ms/op
                 executeQuery·p0.99:   274.203 ms/op
                 executeQuery·p0.999:  274.203 ms/op
                 executeQuery·p0.9999: 274.203 ms/op
                 executeQuery·p1.00:   274.203 ms/op

Iteration   3: 262.035 ±(99.9%) 4.945 ms/op
                 executeQuery·p0.00:   246.678 ms/op
                 executeQuery·p0.50:   261.226 ms/op
                 executeQuery·p0.90:   275.723 ms/op
                 executeQuery·p0.95:   280.782 ms/op
                 executeQuery·p0.99:   288.358 ms/op
                 executeQuery·p0.999:  288.358 ms/op
                 executeQuery·p0.9999: 288.358 ms/op
                 executeQuery·p1.00:   288.358 ms/op

Iteration   4: 265.544 ±(99.9%) 3.447 ms/op
                 executeQuery·p0.00:   256.901 ms/op
                 executeQuery·p0.50:   263.717 ms/op
                 executeQuery·p0.90:   275.775 ms/op
                 executeQuery·p0.95:   277.453 ms/op
                 executeQuery·p0.99:   279.970 ms/op
                 executeQuery·p0.999:  279.970 ms/op
                 executeQuery·p0.9999: 279.970 ms/op
                 executeQuery·p1.00:   279.970 ms/op

Iteration   5: 262.712 ±(99.9%) 3.007 ms/op
                 executeQuery·p0.00:   253.493 ms/op
                 executeQuery·p0.50:   262.406 ms/op
                 executeQuery·p0.90:   268.750 ms/op
                 executeQuery·p0.95:   275.041 ms/op
                 executeQuery·p0.99:   276.824 ms/op
                 executeQuery·p0.999:  276.824 ms/op
                 executeQuery·p0.9999: 276.824 ms/op
                 executeQuery·p1.00:   276.824 ms/op


# Run progress: 85.13% complete, ETA 03:06:08
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 283.034 ±(99.9%) 29.362 ms/op
# Warmup Iteration   2: 269.050 ±(99.9%) 5.672 ms/op
# Warmup Iteration   3: 261.525 ±(99.9%) 3.950 ms/op
# Warmup Iteration   4: 263.768 ±(99.9%) 4.553 ms/op
# Warmup Iteration   5: 262.719 ±(99.9%) 3.296 ms/op
Iteration   1: 261.445 ±(99.9%) 2.277 ms/op
                 executeQuery·p0.00:   250.085 ms/op
                 executeQuery·p0.50:   261.489 ms/op
                 executeQuery·p0.90:   268.173 ms/op
                 executeQuery·p0.95:   268.435 ms/op
                 executeQuery·p0.99:   268.435 ms/op
                 executeQuery·p0.999:  268.435 ms/op
                 executeQuery·p0.9999: 268.435 ms/op
                 executeQuery·p1.00:   268.435 ms/op

Iteration   2: 305.440 ±(99.9%) 53.317 ms/op
                 executeQuery·p0.00:   249.823 ms/op
                 executeQuery·p0.50:   265.290 ms/op
                 executeQuery·p0.90:   455.082 ms/op
                 executeQuery·p0.95:   464.834 ms/op
                 executeQuery·p0.99:   467.665 ms/op
                 executeQuery·p0.999:  467.665 ms/op
                 executeQuery·p0.9999: 467.665 ms/op
                 executeQuery·p1.00:   467.665 ms/op

Iteration   3: 287.580 ±(99.9%) 38.059 ms/op
                 executeQuery·p0.00:   255.590 ms/op
                 executeQuery·p0.50:   267.649 ms/op
                 executeQuery·p0.90:   444.072 ms/op
                 executeQuery·p0.95:   459.538 ms/op
                 executeQuery·p0.99:   465.043 ms/op
                 executeQuery·p0.999:  465.043 ms/op
                 executeQuery·p0.9999: 465.043 ms/op
                 executeQuery·p1.00:   465.043 ms/op

Iteration   4: 304.603 ±(99.9%) 51.241 ms/op
                 executeQuery·p0.00:   255.853 ms/op
                 executeQuery·p0.50:   267.387 ms/op
                 executeQuery·p0.90:   467.036 ms/op
                 executeQuery·p0.95:   469.238 ms/op
                 executeQuery·p0.99:   470.811 ms/op
                 executeQuery·p0.999:  470.811 ms/op
                 executeQuery·p0.9999: 470.811 ms/op
                 executeQuery·p1.00:   470.811 ms/op

Iteration   5: 296.813 ±(99.9%) 44.853 ms/op
                 executeQuery·p0.00:   256.377 ms/op
                 executeQuery·p0.50:   267.256 ms/op
                 executeQuery·p0.90:   455.134 ms/op
                 executeQuery·p0.95:   460.456 ms/op
                 executeQuery·p0.99:   465.568 ms/op
                 executeQuery·p0.999:  465.568 ms/op
                 executeQuery·p0.9999: 465.568 ms/op
                 executeQuery·p1.00:   465.568 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 343
  mean =    275.660 ±(99.9%) 8.550 ms/op

  Histogram, ms/op:
    [200.000, 225.000) = 0 
    [225.000, 250.000) = 10 
    [250.000, 275.000) = 298 
    [275.000, 300.000) = 13 
    [300.000, 325.000) = 0 
    [325.000, 350.000) = 0 
    [350.000, 375.000) = 0 
    [375.000, 400.000) = 0 
    [400.000, 425.000) = 0 
    [425.000, 450.000) = 5 
    [450.000, 475.000) = 17 

  Percentiles, ms/op:
      p(0.0000) =    246.678 ms/op
     p(50.0000) =    263.455 ms/op
     p(90.0000) =    275.566 ms/op
     p(95.0000) =    450.259 ms/op
     p(99.0000) =    467.958 ms/op
     p(99.9000) =    470.811 ms/op
     p(99.9900) =    470.811 ms/op
     p(99.9990) =    470.811 ms/op
     p(99.9999) =    470.811 ms/op
    p(100.0000) =    470.811 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 85.44% complete, ETA 03:01:48
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 4471.128 ms/op
# Warmup Iteration   2: 3292.529 ms/op
# Warmup Iteration   3: 3200.254 ms/op
# Warmup Iteration   4: 3263.169 ms/op
# Warmup Iteration   5: 2646.606 ms/op
Iteration   1: 3204.448 ms/op
                 executeQuery·p0.00:   3204.448 ms/op
                 executeQuery·p0.50:   3204.448 ms/op
                 executeQuery·p0.90:   3204.448 ms/op
                 executeQuery·p0.95:   3204.448 ms/op
                 executeQuery·p0.99:   3204.448 ms/op
                 executeQuery·p0.999:  3204.448 ms/op
                 executeQuery·p0.9999: 3204.448 ms/op
                 executeQuery·p1.00:   3204.448 ms/op

Iteration   2: 2684.355 ms/op
                 executeQuery·p0.00:   2684.355 ms/op
                 executeQuery·p0.50:   2684.355 ms/op
                 executeQuery·p0.90:   2684.355 ms/op
                 executeQuery·p0.95:   2684.355 ms/op
                 executeQuery·p0.99:   2684.355 ms/op
                 executeQuery·p0.999:  2684.355 ms/op
                 executeQuery·p0.9999: 2684.355 ms/op
                 executeQuery·p1.00:   2684.355 ms/op

Iteration   3: 2654.994 ms/op
                 executeQuery·p0.00:   2654.994 ms/op
                 executeQuery·p0.50:   2654.994 ms/op
                 executeQuery·p0.90:   2654.994 ms/op
                 executeQuery·p0.95:   2654.994 ms/op
                 executeQuery·p0.99:   2654.994 ms/op
                 executeQuery·p0.999:  2654.994 ms/op
                 executeQuery·p0.9999: 2654.994 ms/op
                 executeQuery·p1.00:   2654.994 ms/op

Iteration   4: 2654.994 ms/op
                 executeQuery·p0.00:   2654.994 ms/op
                 executeQuery·p0.50:   2654.994 ms/op
                 executeQuery·p0.90:   2654.994 ms/op
                 executeQuery·p0.95:   2654.994 ms/op
                 executeQuery·p0.99:   2654.994 ms/op
                 executeQuery·p0.999:  2654.994 ms/op
                 executeQuery·p0.9999: 2654.994 ms/op
                 executeQuery·p1.00:   2654.994 ms/op

Iteration   5: 2663.383 ms/op
                 executeQuery·p0.00:   2663.383 ms/op
                 executeQuery·p0.50:   2663.383 ms/op
                 executeQuery·p0.90:   2663.383 ms/op
                 executeQuery·p0.95:   2663.383 ms/op
                 executeQuery·p0.99:   2663.383 ms/op
                 executeQuery·p0.999:  2663.383 ms/op
                 executeQuery·p0.9999: 2663.383 ms/op
                 executeQuery·p1.00:   2663.383 ms/op


# Run progress: 85.76% complete, ETA 02:57:29
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3871.343 ms/op
# Warmup Iteration   2: 3078.619 ms/op
# Warmup Iteration   3: 3254.780 ms/op
# Warmup Iteration   4: 2625.634 ms/op
# Warmup Iteration   5: 3133.145 ms/op
Iteration   1: 2646.606 ms/op
                 executeQuery·p0.00:   2646.606 ms/op
                 executeQuery·p0.50:   2646.606 ms/op
                 executeQuery·p0.90:   2646.606 ms/op
                 executeQuery·p0.95:   2646.606 ms/op
                 executeQuery·p0.99:   2646.606 ms/op
                 executeQuery·p0.999:  2646.606 ms/op
                 executeQuery·p0.9999: 2646.606 ms/op
                 executeQuery·p1.00:   2646.606 ms/op

Iteration   2: 2621.440 ms/op
                 executeQuery·p0.00:   2621.440 ms/op
                 executeQuery·p0.50:   2621.440 ms/op
                 executeQuery·p0.90:   2621.440 ms/op
                 executeQuery·p0.95:   2621.440 ms/op
                 executeQuery·p0.99:   2621.440 ms/op
                 executeQuery·p0.999:  2621.440 ms/op
                 executeQuery·p0.9999: 2621.440 ms/op
                 executeQuery·p1.00:   2621.440 ms/op

Iteration   3: 2638.217 ms/op
                 executeQuery·p0.00:   2638.217 ms/op
                 executeQuery·p0.50:   2638.217 ms/op
                 executeQuery·p0.90:   2638.217 ms/op
                 executeQuery·p0.95:   2638.217 ms/op
                 executeQuery·p0.99:   2638.217 ms/op
                 executeQuery·p0.999:  2638.217 ms/op
                 executeQuery·p0.9999: 2638.217 ms/op
                 executeQuery·p1.00:   2638.217 ms/op

Iteration   4: 2621.440 ms/op
                 executeQuery·p0.00:   2621.440 ms/op
                 executeQuery·p0.50:   2621.440 ms/op
                 executeQuery·p0.90:   2621.440 ms/op
                 executeQuery·p0.95:   2621.440 ms/op
                 executeQuery·p0.99:   2621.440 ms/op
                 executeQuery·p0.999:  2621.440 ms/op
                 executeQuery·p0.9999: 2621.440 ms/op
                 executeQuery·p1.00:   2621.440 ms/op

Iteration   5: 2625.634 ms/op
                 executeQuery·p0.00:   2625.634 ms/op
                 executeQuery·p0.50:   2625.634 ms/op
                 executeQuery·p0.90:   2625.634 ms/op
                 executeQuery·p0.95:   2625.634 ms/op
                 executeQuery·p0.99:   2625.634 ms/op
                 executeQuery·p0.999:  2625.634 ms/op
                 executeQuery·p0.9999: 2625.634 ms/op
                 executeQuery·p1.00:   2625.634 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 10
  mean =   2701.551 ±(99.9%) 268.859 ms/op

  Histogram, ms/op:
    [2600.000, 2650.000) = 5 
    [2650.000, 2700.000) = 4 
    [2700.000, 2750.000) = 0 
    [2750.000, 2800.000) = 0 
    [2800.000, 2850.000) = 0 
    [2850.000, 2900.000) = 0 
    [2900.000, 2950.000) = 0 
    [2950.000, 3000.000) = 0 
    [3000.000, 3050.000) = 0 
    [3050.000, 3100.000) = 0 
    [3100.000, 3150.000) = 0 
    [3150.000, 3200.000) = 0 
    [3200.000, 3250.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2621.440 ms/op
     p(50.0000) =   2650.800 ms/op
     p(90.0000) =   3152.439 ms/op
     p(95.0000) =   3204.448 ms/op
     p(99.0000) =   3204.448 ms/op
     p(99.9000) =   3204.448 ms/op
     p(99.9900) =   3204.448 ms/op
     p(99.9990) =   3204.448 ms/op
     p(99.9999) =   3204.448 ms/op
    p(100.0000) =   3204.448 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 86.08% complete, ETA 02:53:12
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 666.295 ±(99.9%) 235.714 ms/op
# Warmup Iteration   2: 518.410 ±(99.9%) 81.177 ms/op
# Warmup Iteration   3: 470.411 ±(99.9%) 4.058 ms/op
# Warmup Iteration   4: 469.787 ±(99.9%) 3.759 ms/op
# Warmup Iteration   5: 469.587 ±(99.9%) 3.332 ms/op
Iteration   1: 470.811 ±(99.9%) 3.434 ms/op
                 executeQuery·p0.00:   465.043 ms/op
                 executeQuery·p0.50:   469.762 ms/op
                 executeQuery·p0.90:   475.529 ms/op
                 executeQuery·p0.95:   479.776 ms/op
                 executeQuery·p0.99:   480.248 ms/op
                 executeQuery·p0.999:  480.248 ms/op
                 executeQuery·p0.9999: 480.248 ms/op
                 executeQuery·p1.00:   480.248 ms/op

Iteration   2: 468.014 ±(99.9%) 3.554 ms/op
                 executeQuery·p0.00:   459.276 ms/op
                 executeQuery·p0.50:   467.665 ms/op
                 executeQuery·p0.90:   475.110 ms/op
                 executeQuery·p0.95:   476.001 ms/op
                 executeQuery·p0.99:   476.054 ms/op
                 executeQuery·p0.999:  476.054 ms/op
                 executeQuery·p0.9999: 476.054 ms/op
                 executeQuery·p1.00:   476.054 ms/op

Iteration   3: 469.662 ±(99.9%) 3.946 ms/op
                 executeQuery·p0.00:   459.801 ms/op
                 executeQuery·p0.50:   469.238 ms/op
                 executeQuery·p0.90:   477.312 ms/op
                 executeQuery·p0.95:   479.042 ms/op
                 executeQuery·p0.99:   479.199 ms/op
                 executeQuery·p0.999:  479.199 ms/op
                 executeQuery·p0.9999: 479.199 ms/op
                 executeQuery·p1.00:   479.199 ms/op

Iteration   4: 470.636 ±(99.9%) 4.703 ms/op
                 executeQuery·p0.00:   461.898 ms/op
                 executeQuery·p0.50:   469.238 ms/op
                 executeQuery·p0.90:   481.087 ms/op
                 executeQuery·p0.95:   481.821 ms/op
                 executeQuery·p0.99:   481.821 ms/op
                 executeQuery·p0.999:  481.821 ms/op
                 executeQuery·p0.9999: 481.821 ms/op
                 executeQuery·p1.00:   481.821 ms/op

Iteration   5: 461.598 ±(99.9%) 11.122 ms/op
                 executeQuery·p0.00:   437.780 ms/op
                 executeQuery·p0.50:   466.616 ms/op
                 executeQuery·p0.90:   475.529 ms/op
                 executeQuery·p0.95:   476.001 ms/op
                 executeQuery·p0.99:   476.054 ms/op
                 executeQuery·p0.999:  476.054 ms/op
                 executeQuery·p0.9999: 476.054 ms/op
                 executeQuery·p1.00:   476.054 ms/op


# Run progress: 86.39% complete, ETA 02:48:55
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 666.969 ±(99.9%) 255.422 ms/op
# Warmup Iteration   2: 506.986 ±(99.9%) 81.878 ms/op
# Warmup Iteration   3: 456.780 ±(99.9%) 4.846 ms/op
# Warmup Iteration   4: 451.436 ±(99.9%) 6.591 ms/op
# Warmup Iteration   5: 451.102 ±(99.9%) 3.927 ms/op
Iteration   1: 453.390 ±(99.9%) 2.907 ms/op
                 executeQuery·p0.00:   446.693 ms/op
                 executeQuery·p0.50:   453.247 ms/op
                 executeQuery·p0.90:   457.546 ms/op
                 executeQuery·p0.95:   463.497 ms/op
                 executeQuery·p0.99:   464.519 ms/op
                 executeQuery·p0.999:  464.519 ms/op
                 executeQuery·p0.9999: 464.519 ms/op
                 executeQuery·p1.00:   464.519 ms/op

Iteration   2: 455.582 ±(99.9%) 3.707 ms/op
                 executeQuery·p0.00:   450.888 ms/op
                 executeQuery·p0.50:   454.296 ms/op
                 executeQuery·p0.90:   463.156 ms/op
                 executeQuery·p0.95:   464.808 ms/op
                 executeQuery·p0.99:   465.043 ms/op
                 executeQuery·p0.999:  465.043 ms/op
                 executeQuery·p0.9999: 465.043 ms/op
                 executeQuery·p1.00:   465.043 ms/op

Iteration   3: 451.531 ±(99.9%) 3.142 ms/op
                 executeQuery·p0.00:   443.548 ms/op
                 executeQuery·p0.50:   451.674 ms/op
                 executeQuery·p0.90:   457.546 ms/op
                 executeQuery·p0.95:   458.595 ms/op
                 executeQuery·p0.99:   458.752 ms/op
                 executeQuery·p0.999:  458.752 ms/op
                 executeQuery·p0.9999: 458.752 ms/op
                 executeQuery·p1.00:   458.752 ms/op

Iteration   4: 453.747 ±(99.9%) 4.648 ms/op
                 executeQuery·p0.00:   445.645 ms/op
                 executeQuery·p0.50:   452.985 ms/op
                 executeQuery·p0.90:   464.362 ms/op
                 executeQuery·p0.95:   466.747 ms/op
                 executeQuery·p0.99:   467.141 ms/op
                 executeQuery·p0.999:  467.141 ms/op
                 executeQuery·p0.9999: 467.141 ms/op
                 executeQuery·p1.00:   467.141 ms/op

Iteration   5: 454.200 ±(99.9%) 8.196 ms/op
                 executeQuery·p0.00:   436.208 ms/op
                 executeQuery·p0.50:   457.441 ms/op
                 executeQuery·p0.90:   465.463 ms/op
                 executeQuery·p0.95:   466.538 ms/op
                 executeQuery·p0.99:   466.616 ms/op
                 executeQuery·p0.999:  466.616 ms/op
                 executeQuery·p0.9999: 466.616 ms/op
                 executeQuery·p1.00:   466.616 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery":
  N = 215
  mean =    460.749 ±(99.9%) 2.293 ms/op

  Histogram, ms/op:
    [430.000, 435.000) = 0 
    [435.000, 440.000) = 6 
    [440.000, 445.000) = 4 
    [445.000, 450.000) = 20 
    [450.000, 455.000) = 48 
    [455.000, 460.000) = 23 
    [460.000, 465.000) = 22 
    [465.000, 470.000) = 51 
    [470.000, 475.000) = 24 
    [475.000, 480.000) = 14 
    [480.000, 485.000) = 3 

  Percentiles, ms/op:
      p(0.0000) =    436.208 ms/op
     p(50.0000) =    461.898 ms/op
     p(90.0000) =    473.851 ms/op
     p(95.0000) =    475.634 ms/op
     p(99.0000) =    481.569 ms/op
     p(99.9000) =    481.821 ms/op
     p(99.9900) =    481.821 ms/op
     p(99.9990) =    481.821 ms/op
     p(99.9999) =    481.821 ms/op
    p(100.0000) =    481.821 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 86.71% complete, ETA 02:44:39
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 6501.171 ms/op
# Warmup Iteration   2: 5972.689 ms/op
# Warmup Iteration   3: 4588.569 ms/op
# Warmup Iteration   4: 5167.383 ms/op
# Warmup Iteration   5: 4961.862 ms/op
Iteration   1: 4928.307 ms/op
                 executeQuery·p0.00:   4924.113 ms/op
                 executeQuery·p0.50:   4928.307 ms/op
                 executeQuery·p0.90:   4932.502 ms/op
                 executeQuery·p0.95:   4932.502 ms/op
                 executeQuery·p0.99:   4932.502 ms/op
                 executeQuery·p0.999:  4932.502 ms/op
                 executeQuery·p0.9999: 4932.502 ms/op
                 executeQuery·p1.00:   4932.502 ms/op

Iteration   2: 4898.947 ms/op
                 executeQuery·p0.00:   4857.004 ms/op
                 executeQuery·p0.50:   4898.947 ms/op
                 executeQuery·p0.90:   4940.890 ms/op
                 executeQuery·p0.95:   4940.890 ms/op
                 executeQuery·p0.99:   4940.890 ms/op
                 executeQuery·p0.999:  4940.890 ms/op
                 executeQuery·p0.9999: 4940.890 ms/op
                 executeQuery·p1.00:   4940.890 ms/op

Iteration   3: 4882.170 ms/op
                 executeQuery·p0.00:   4865.393 ms/op
                 executeQuery·p0.50:   4882.170 ms/op
                 executeQuery·p0.90:   4898.947 ms/op
                 executeQuery·p0.95:   4898.947 ms/op
                 executeQuery·p0.99:   4898.947 ms/op
                 executeQuery·p0.999:  4898.947 ms/op
                 executeQuery·p0.9999: 4898.947 ms/op
                 executeQuery·p1.00:   4898.947 ms/op

Iteration   4: 4873.781 ms/op
                 executeQuery·p0.00:   4873.781 ms/op
                 executeQuery·p0.50:   4873.781 ms/op
                 executeQuery·p0.90:   4873.781 ms/op
                 executeQuery·p0.95:   4873.781 ms/op
                 executeQuery·p0.99:   4873.781 ms/op
                 executeQuery·p0.999:  4873.781 ms/op
                 executeQuery·p0.9999: 4873.781 ms/op
                 executeQuery·p1.00:   4873.781 ms/op

Iteration   5: 4869.587 ms/op
                 executeQuery·p0.00:   4865.393 ms/op
                 executeQuery·p0.50:   4869.587 ms/op
                 executeQuery·p0.90:   4873.781 ms/op
                 executeQuery·p0.95:   4873.781 ms/op
                 executeQuery·p0.99:   4873.781 ms/op
                 executeQuery·p0.999:  4873.781 ms/op
                 executeQuery·p0.9999: 4873.781 ms/op
                 executeQuery·p1.00:   4873.781 ms/op


# Run progress: 87.03% complete, ETA 02:40:31
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 6148.850 ms/op
# Warmup Iteration   2: 7038.042 ms/op
# Warmup Iteration   3: 4970.250 ms/op
# Warmup Iteration   4: 4861.198 ms/op
# Warmup Iteration   5: 4873.781 ms/op
Iteration   1: 4886.364 ms/op
                 executeQuery·p0.00:   4873.781 ms/op
                 executeQuery·p0.50:   4886.364 ms/op
                 executeQuery·p0.90:   4898.947 ms/op
                 executeQuery·p0.95:   4898.947 ms/op
                 executeQuery·p0.99:   4898.947 ms/op
                 executeQuery·p0.999:  4898.947 ms/op
                 executeQuery·p0.9999: 4898.947 ms/op
                 executeQuery·p1.00:   4898.947 ms/op

Iteration   2: 4873.781 ms/op
                 executeQuery·p0.00:   4865.393 ms/op
                 executeQuery·p0.50:   4873.781 ms/op
                 executeQuery·p0.90:   4882.170 ms/op
                 executeQuery·p0.95:   4882.170 ms/op
                 executeQuery·p0.99:   4882.170 ms/op
                 executeQuery·p0.999:  4882.170 ms/op
                 executeQuery·p0.9999: 4882.170 ms/op
                 executeQuery·p1.00:   4882.170 ms/op

Iteration   3: 4869.587 ms/op
                 executeQuery·p0.00:   4857.004 ms/op
                 executeQuery·p0.50:   4869.587 ms/op
                 executeQuery·p0.90:   4882.170 ms/op
                 executeQuery·p0.95:   4882.170 ms/op
                 executeQuery·p0.99:   4882.170 ms/op
                 executeQuery·p0.999:  4882.170 ms/op
                 executeQuery·p0.9999: 4882.170 ms/op
                 executeQuery·p1.00:   4882.170 ms/op

Iteration   4: 4857.004 ms/op
                 executeQuery·p0.00:   4840.227 ms/op
                 executeQuery·p0.50:   4857.004 ms/op
                 executeQuery·p0.90:   4873.781 ms/op
                 executeQuery·p0.95:   4873.781 ms/op
                 executeQuery·p0.99:   4873.781 ms/op
                 executeQuery·p0.999:  4873.781 ms/op
                 executeQuery·p0.9999: 4873.781 ms/op
                 executeQuery·p1.00:   4873.781 ms/op

Iteration   5: 4861.198 ms/op
                 executeQuery·p0.00:   4857.004 ms/op
                 executeQuery·p0.50:   4861.198 ms/op
                 executeQuery·p0.90:   4865.393 ms/op
                 executeQuery·p0.95:   4865.393 ms/op
                 executeQuery·p0.99:   4865.393 ms/op
                 executeQuery·p0.999:  4865.393 ms/op
                 executeQuery·p0.9999: 4865.393 ms/op
                 executeQuery·p1.00:   4865.393 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery":
  N = 20
  mean =   4880.073 ±(99.9%) 23.020 ms/op

  Histogram, ms/op:
    [4800.000, 4812.500) = 0 
    [4812.500, 4825.000) = 0 
    [4825.000, 4837.500) = 0 
    [4837.500, 4850.000) = 1 
    [4850.000, 4862.500) = 3 
    [4862.500, 4875.000) = 9 
    [4875.000, 4887.500) = 2 
    [4887.500, 4900.000) = 2 
    [4900.000, 4912.500) = 0 
    [4912.500, 4925.000) = 1 
    [4925.000, 4937.500) = 1 
    [4937.500, 4950.000) = 1 
    [4950.000, 4962.500) = 0 
    [4962.500, 4975.000) = 0 
    [4975.000, 4987.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   4840.227 ms/op
     p(50.0000) =   4873.781 ms/op
     p(90.0000) =   4931.663 ms/op
     p(95.0000) =   4940.471 ms/op
     p(99.0000) =   4940.890 ms/op
     p(99.9000) =   4940.890 ms/op
     p(99.9900) =   4940.890 ms/op
     p(99.9990) =   4940.890 ms/op
     p(99.9999) =   4940.890 ms/op
    p(100.0000) =   4940.890 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 87.34% complete, ETA 02:36:23
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 289.433 ±(99.9%) 36.715 ms/op
# Warmup Iteration   2: 259.989 ±(99.9%) 4.389 ms/op
# Warmup Iteration   3: 261.867 ±(99.9%) 4.170 ms/op
# Warmup Iteration   4: 262.166 ±(99.9%) 4.334 ms/op
# Warmup Iteration   5: 263.035 ±(99.9%) 2.952 ms/op
Iteration   1: 261.170 ±(99.9%) 2.798 ms/op
                 executeQuery·p0.00:   251.658 ms/op
                 executeQuery·p0.50:   260.309 ms/op
                 executeQuery·p0.90:   266.600 ms/op
                 executeQuery·p0.95:   273.049 ms/op
                 executeQuery·p0.99:   276.824 ms/op
                 executeQuery·p0.999:  276.824 ms/op
                 executeQuery·p0.9999: 276.824 ms/op
                 executeQuery·p1.00:   276.824 ms/op

Iteration   2: 266.331 ±(99.9%) 3.411 ms/op
                 executeQuery·p0.00:   257.163 ms/op
                 executeQuery·p0.50:   265.290 ms/op
                 executeQuery·p0.90:   277.348 ms/op
                 executeQuery·p0.95:   277.977 ms/op
                 executeQuery·p0.99:   278.397 ms/op
                 executeQuery·p0.999:  278.397 ms/op
                 executeQuery·p0.9999: 278.397 ms/op
                 executeQuery·p1.00:   278.397 ms/op

Iteration   3: 265.170 ±(99.9%) 3.693 ms/op
                 executeQuery·p0.00:   254.804 ms/op
                 executeQuery·p0.50:   263.455 ms/op
                 executeQuery·p0.90:   276.195 ms/op
                 executeQuery·p0.95:   278.187 ms/op
                 executeQuery·p0.99:   281.543 ms/op
                 executeQuery·p0.999:  281.543 ms/op
                 executeQuery·p0.9999: 281.543 ms/op
                 executeQuery·p1.00:   281.543 ms/op

Iteration   4: 266.323 ±(99.9%) 3.872 ms/op
                 executeQuery·p0.00:   255.853 ms/op
                 executeQuery·p0.50:   264.503 ms/op
                 executeQuery·p0.90:   276.300 ms/op
                 executeQuery·p0.95:   276.929 ms/op
                 executeQuery·p0.99:   277.348 ms/op
                 executeQuery·p0.999:  277.348 ms/op
                 executeQuery·p0.9999: 277.348 ms/op
                 executeQuery·p1.00:   277.348 ms/op

Iteration   5: 266.503 ±(99.9%) 4.055 ms/op
                 executeQuery·p0.00:   255.066 ms/op
                 executeQuery·p0.50:   264.765 ms/op
                 executeQuery·p0.90:   276.509 ms/op
                 executeQuery·p0.95:   277.558 ms/op
                 executeQuery·p0.99:   278.397 ms/op
                 executeQuery·p0.999:  278.397 ms/op
                 executeQuery·p0.9999: 278.397 ms/op
                 executeQuery·p1.00:   278.397 ms/op


# Run progress: 87.66% complete, ETA 02:32:10
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 284.059 ±(99.9%) 35.315 ms/op
# Warmup Iteration   2: 259.406 ±(99.9%) 5.423 ms/op
# Warmup Iteration   3: 257.964 ±(99.9%) 3.726 ms/op
# Warmup Iteration   4: 259.756 ±(99.9%) 4.302 ms/op
# Warmup Iteration   5: 259.927 ±(99.9%) 4.268 ms/op
Iteration   1: 257.972 ±(99.9%) 4.109 ms/op
                 executeQuery·p0.00:   245.891 ms/op
                 executeQuery·p0.50:   257.425 ms/op
                 executeQuery·p0.90:   272.263 ms/op
                 executeQuery·p0.95:   273.469 ms/op
                 executeQuery·p0.99:   275.251 ms/op
                 executeQuery·p0.999:  275.251 ms/op
                 executeQuery·p0.9999: 275.251 ms/op
                 executeQuery·p1.00:   275.251 ms/op

Iteration   2: 261.777 ±(99.9%) 3.939 ms/op
                 executeQuery·p0.00:   249.823 ms/op
                 executeQuery·p0.50:   260.571 ms/op
                 executeQuery·p0.90:   273.154 ms/op
                 executeQuery·p0.95:   275.985 ms/op
                 executeQuery·p0.99:   276.824 ms/op
                 executeQuery·p0.999:  276.824 ms/op
                 executeQuery·p0.9999: 276.824 ms/op
                 executeQuery·p1.00:   276.824 ms/op

Iteration   3: 261.695 ±(99.9%) 4.760 ms/op
                 executeQuery·p0.00:   247.726 ms/op
                 executeQuery·p0.50:   260.571 ms/op
                 executeQuery·p0.90:   274.937 ms/op
                 executeQuery·p0.95:   276.824 ms/op
                 executeQuery·p0.99:   276.824 ms/op
                 executeQuery·p0.999:  276.824 ms/op
                 executeQuery·p0.9999: 276.824 ms/op
                 executeQuery·p1.00:   276.824 ms/op

Iteration   4: 261.859 ±(99.9%) 5.581 ms/op
                 executeQuery·p0.00:   247.726 ms/op
                 executeQuery·p0.50:   259.785 ms/op
                 executeQuery·p0.90:   275.985 ms/op
                 executeQuery·p0.95:   276.405 ms/op
                 executeQuery·p0.99:   276.824 ms/op
                 executeQuery·p0.999:  276.824 ms/op
                 executeQuery·p0.9999: 276.824 ms/op
                 executeQuery·p1.00:   276.824 ms/op

Iteration   5: 264.481 ±(99.9%) 4.532 ms/op
                 executeQuery·p0.00:   250.610 ms/op
                 executeQuery·p0.50:   262.144 ms/op
                 executeQuery·p0.90:   275.985 ms/op
                 executeQuery·p0.95:   277.348 ms/op
                 executeQuery·p0.99:   279.446 ms/op
                 executeQuery·p0.999:  279.446 ms/op
                 executeQuery·p0.9999: 279.446 ms/op
                 executeQuery·p1.00:   279.446 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery":
  N = 351
  mean =    263.313 ±(99.9%) 1.285 ms/op

  Histogram, ms/op:
    [240.000, 245.000) = 0 
    [245.000, 250.000) = 10 
    [250.000, 255.000) = 20 
    [255.000, 260.000) = 84 
    [260.000, 265.000) = 123 
    [265.000, 270.000) = 46 
    [270.000, 275.000) = 25 
    [275.000, 280.000) = 42 
    [280.000, 285.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    245.891 ms/op
     p(50.0000) =    262.406 ms/op
     p(90.0000) =    275.775 ms/op
     p(95.0000) =    276.824 ms/op
     p(99.0000) =    278.397 ms/op
     p(99.9000) =    281.543 ms/op
     p(99.9900) =    281.543 ms/op
     p(99.9990) =    281.543 ms/op
     p(99.9999) =    281.543 ms/op
    p(100.0000) =    281.543 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 87.97% complete, ETA 02:27:58
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3191.865 ±(99.9%) 13536.206 ms/op
# Warmup Iteration   2: 2717.909 ±(99.9%) 530.144 ms/op
# Warmup Iteration   3: 2695.539 ±(99.9%) 192.570 ms/op
# Warmup Iteration   4: 2689.947 ±(99.9%) 88.357 ms/op
# Warmup Iteration   5: 2677.364 ±(99.9%) 44.179 ms/op
Iteration   1: 2689.947 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2688.549 ms/op
                 executeQuery·p0.50:   2688.549 ms/op
                 executeQuery·p0.90:   2692.743 ms/op
                 executeQuery·p0.95:   2692.743 ms/op
                 executeQuery·p0.99:   2692.743 ms/op
                 executeQuery·p0.999:  2692.743 ms/op
                 executeQuery·p0.9999: 2692.743 ms/op
                 executeQuery·p1.00:   2692.743 ms/op

Iteration   2: 2684.355 ±(99.9%) 132.536 ms/op
                 executeQuery·p0.00:   2680.160 ms/op
                 executeQuery·p0.50:   2680.160 ms/op
                 executeQuery·p0.90:   2692.743 ms/op
                 executeQuery·p0.95:   2692.743 ms/op
                 executeQuery·p0.99:   2692.743 ms/op
                 executeQuery·p0.999:  2692.743 ms/op
                 executeQuery·p0.9999: 2692.743 ms/op
                 executeQuery·p1.00:   2692.743 ms/op

Iteration   3: 2689.947 ±(99.9%) 159.288 ms/op
                 executeQuery·p0.00:   2680.160 ms/op
                 executeQuery·p0.50:   2692.743 ms/op
                 executeQuery·p0.90:   2696.937 ms/op
                 executeQuery·p0.95:   2696.937 ms/op
                 executeQuery·p0.99:   2696.937 ms/op
                 executeQuery·p0.999:  2696.937 ms/op
                 executeQuery·p0.9999: 2696.937 ms/op
                 executeQuery·p1.00:   2696.937 ms/op

Iteration   4: 2687.151 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   2684.355 ms/op
                 executeQuery·p0.50:   2684.355 ms/op
                 executeQuery·p0.90:   2692.743 ms/op
                 executeQuery·p0.95:   2692.743 ms/op
                 executeQuery·p0.99:   2692.743 ms/op
                 executeQuery·p0.999:  2692.743 ms/op
                 executeQuery·p0.9999: 2692.743 ms/op
                 executeQuery·p1.00:   2692.743 ms/op

Iteration   5: 2688.549 ±(99.9%) 76.520 ms/op
                 executeQuery·p0.00:   2684.355 ms/op
                 executeQuery·p0.50:   2688.549 ms/op
                 executeQuery·p0.90:   2692.743 ms/op
                 executeQuery·p0.95:   2692.743 ms/op
                 executeQuery·p0.99:   2692.743 ms/op
                 executeQuery·p0.999:  2692.743 ms/op
                 executeQuery·p0.9999: 2692.743 ms/op
                 executeQuery·p1.00:   2692.743 ms/op


# Run progress: 88.29% complete, ETA 02:23:51
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3663.725 ms/op
# Warmup Iteration   2: 2800.397 ±(99.9%) 467.543 ms/op
# Warmup Iteration   3: 2804.591 ±(99.9%) 1347.993 ms/op
# Warmup Iteration   4: 2761.250 ±(99.9%) 245.976 ms/op
# Warmup Iteration   5: 2761.250 ±(99.9%) 44.179 ms/op
Iteration   1: 2759.852 ±(99.9%) 0.001 ms/op
                 executeQuery·p0.00:   2759.852 ms/op
                 executeQuery·p0.50:   2759.852 ms/op
                 executeQuery·p0.90:   2759.852 ms/op
                 executeQuery·p0.95:   2759.852 ms/op
                 executeQuery·p0.99:   2759.852 ms/op
                 executeQuery·p0.999:  2759.852 ms/op
                 executeQuery·p0.9999: 2759.852 ms/op
                 executeQuery·p1.00:   2759.852 ms/op

Iteration   2: 2765.444 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2764.046 ms/op
                 executeQuery·p0.50:   2764.046 ms/op
                 executeQuery·p0.90:   2768.241 ms/op
                 executeQuery·p0.95:   2768.241 ms/op
                 executeQuery·p0.99:   2768.241 ms/op
                 executeQuery·p0.999:  2768.241 ms/op
                 executeQuery·p0.9999: 2768.241 ms/op
                 executeQuery·p1.00:   2768.241 ms/op

Iteration   3: 2758.454 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2755.658 ms/op
                 executeQuery·p0.50:   2759.852 ms/op
                 executeQuery·p0.90:   2759.852 ms/op
                 executeQuery·p0.95:   2759.852 ms/op
                 executeQuery·p0.99:   2759.852 ms/op
                 executeQuery·p0.999:  2759.852 ms/op
                 executeQuery·p0.9999: 2759.852 ms/op
                 executeQuery·p1.00:   2759.852 ms/op

Iteration   4: 2757.056 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2755.658 ms/op
                 executeQuery·p0.50:   2755.658 ms/op
                 executeQuery·p0.90:   2759.852 ms/op
                 executeQuery·p0.95:   2759.852 ms/op
                 executeQuery·p0.99:   2759.852 ms/op
                 executeQuery·p0.999:  2759.852 ms/op
                 executeQuery·p0.9999: 2759.852 ms/op
                 executeQuery·p1.00:   2759.852 ms/op

Iteration   5: 2759.852 ±(99.9%) 76.520 ms/op
                 executeQuery·p0.00:   2755.658 ms/op
                 executeQuery·p0.50:   2759.852 ms/op
                 executeQuery·p0.90:   2764.046 ms/op
                 executeQuery·p0.95:   2764.046 ms/op
                 executeQuery·p0.99:   2764.046 ms/op
                 executeQuery·p0.999:  2764.046 ms/op
                 executeQuery·p0.9999: 2764.046 ms/op
                 executeQuery·p1.00:   2764.046 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery":
  N = 30
  mean =   2724.061 ±(99.9%) 24.702 ms/op

  Histogram, ms/op:
    [2680.000, 2685.000) = 6 
    [2685.000, 2690.000) = 3 
    [2690.000, 2695.000) = 5 
    [2695.000, 2700.000) = 1 
    [2700.000, 2705.000) = 0 
    [2705.000, 2710.000) = 0 
    [2710.000, 2715.000) = 0 
    [2715.000, 2720.000) = 0 
    [2720.000, 2725.000) = 0 
    [2725.000, 2730.000) = 0 
    [2730.000, 2735.000) = 0 
    [2735.000, 2740.000) = 0 
    [2740.000, 2745.000) = 0 
    [2745.000, 2750.000) = 0 
    [2750.000, 2755.000) = 0 
    [2755.000, 2760.000) = 11 
    [2760.000, 2765.000) = 3 

  Percentiles, ms/op:
      p(0.0000) =   2680.160 ms/op
     p(50.0000) =   2726.298 ms/op
     p(90.0000) =   2764.046 ms/op
     p(95.0000) =   2765.934 ms/op
     p(99.0000) =   2768.241 ms/op
     p(99.9000) =   2768.241 ms/op
     p(99.9900) =   2768.241 ms/op
     p(99.9990) =   2768.241 ms/op
     p(99.9999) =   2768.241 ms/op
    p(100.0000) =   2768.241 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 88.61% complete, ETA 02:19:45
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 284.697 ±(99.9%) 37.625 ms/op
# Warmup Iteration   2: 262.093 ±(99.9%) 2.969 ms/op
# Warmup Iteration   3: 264.638 ±(99.9%) 3.655 ms/op
# Warmup Iteration   4: 264.383 ±(99.9%) 4.765 ms/op
# Warmup Iteration   5: 266.765 ±(99.9%) 3.399 ms/op
Iteration   1: 262.024 ±(99.9%) 4.262 ms/op
                 executeQuery·p0.00:   254.018 ms/op
                 executeQuery·p0.50:   259.523 ms/op
                 executeQuery·p0.90:   272.630 ms/op
                 executeQuery·p0.95:   275.041 ms/op
                 executeQuery·p0.99:   276.300 ms/op
                 executeQuery·p0.999:  276.300 ms/op
                 executeQuery·p0.9999: 276.300 ms/op
                 executeQuery·p1.00:   276.300 ms/op

Iteration   2: 264.076 ±(99.9%) 4.329 ms/op
                 executeQuery·p0.00:   250.872 ms/op
                 executeQuery·p0.50:   264.503 ms/op
                 executeQuery·p0.90:   275.356 ms/op
                 executeQuery·p0.95:   277.873 ms/op
                 executeQuery·p0.99:   277.873 ms/op
                 executeQuery·p0.999:  277.873 ms/op
                 executeQuery·p0.9999: 277.873 ms/op
                 executeQuery·p1.00:   277.873 ms/op

Iteration   3: 266.780 ±(99.9%) 4.051 ms/op
                 executeQuery·p0.00:   251.134 ms/op
                 executeQuery·p0.50:   265.814 ms/op
                 executeQuery·p0.90:   277.558 ms/op
                 executeQuery·p0.95:   278.502 ms/op
                 executeQuery·p0.99:   278.921 ms/op
                 executeQuery·p0.999:  278.921 ms/op
                 executeQuery·p0.9999: 278.921 ms/op
                 executeQuery·p1.00:   278.921 ms/op

Iteration   4: 267.207 ±(99.9%) 3.895 ms/op
                 executeQuery·p0.00:   251.920 ms/op
                 executeQuery·p0.50:   265.552 ms/op
                 executeQuery·p0.90:   278.816 ms/op
                 executeQuery·p0.95:   280.075 ms/op
                 executeQuery·p0.99:   280.494 ms/op
                 executeQuery·p0.999:  280.494 ms/op
                 executeQuery·p0.9999: 280.494 ms/op
                 executeQuery·p1.00:   280.494 ms/op

Iteration   5: 265.732 ±(99.9%) 5.473 ms/op
                 executeQuery·p0.00:   245.629 ms/op
                 executeQuery·p0.50:   265.028 ms/op
                 executeQuery·p0.90:   279.131 ms/op
                 executeQuery·p0.95:   279.550 ms/op
                 executeQuery·p0.99:   279.970 ms/op
                 executeQuery·p0.999:  279.970 ms/op
                 executeQuery·p0.9999: 279.970 ms/op
                 executeQuery·p1.00:   279.970 ms/op


# Run progress: 88.92% complete, ETA 02:15:36
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 297.062 ±(99.9%) 35.133 ms/op
# Warmup Iteration   2: 273.092 ±(99.9%) 4.218 ms/op
# Warmup Iteration   3: 269.154 ±(99.9%) 3.074 ms/op
# Warmup Iteration   4: 272.961 ±(99.9%) 4.250 ms/op
# Warmup Iteration   5: 269.544 ±(99.9%) 2.521 ms/op
Iteration   1: 270.849 ±(99.9%) 3.480 ms/op
                 executeQuery·p0.00:   265.028 ms/op
                 executeQuery·p0.50:   268.435 ms/op
                 executeQuery·p0.90:   280.232 ms/op
                 executeQuery·p0.95:   283.771 ms/op
                 executeQuery·p0.99:   285.737 ms/op
                 executeQuery·p0.999:  285.737 ms/op
                 executeQuery·p0.9999: 285.737 ms/op
                 executeQuery·p1.00:   285.737 ms/op

Iteration   2: 275.590 ±(99.9%) 3.664 ms/op
                 executeQuery·p0.00:   259.523 ms/op
                 executeQuery·p0.50:   274.203 ms/op
                 executeQuery·p0.90:   286.261 ms/op
                 executeQuery·p0.95:   287.179 ms/op
                 executeQuery·p0.99:   289.931 ms/op
                 executeQuery·p0.999:  289.931 ms/op
                 executeQuery·p0.9999: 289.931 ms/op
                 executeQuery·p1.00:   289.931 ms/op

Iteration   3: 277.125 ±(99.9%) 4.497 ms/op
                 executeQuery·p0.00:   260.309 ms/op
                 executeQuery·p0.50:   274.727 ms/op
                 executeQuery·p0.90:   286.261 ms/op
                 executeQuery·p0.95:   289.407 ms/op
                 executeQuery·p0.99:   289.407 ms/op
                 executeQuery·p0.999:  289.407 ms/op
                 executeQuery·p0.9999: 289.407 ms/op
                 executeQuery·p1.00:   289.407 ms/op

Iteration   4: 271.967 ±(99.9%) 4.576 ms/op
                 executeQuery·p0.00:   261.882 ms/op
                 executeQuery·p0.50:   270.533 ms/op
                 executeQuery·p0.90:   284.426 ms/op
                 executeQuery·p0.95:   290.980 ms/op
                 executeQuery·p0.99:   292.553 ms/op
                 executeQuery·p0.999:  292.553 ms/op
                 executeQuery·p0.9999: 292.553 ms/op
                 executeQuery·p1.00:   292.553 ms/op

Iteration   5: 270.918 ±(99.9%) 3.272 ms/op
                 executeQuery·p0.00:   257.950 ms/op
                 executeQuery·p0.50:   269.746 ms/op
                 executeQuery·p0.90:   279.183 ms/op
                 executeQuery·p0.95:   284.164 ms/op
                 executeQuery·p0.99:   284.164 ms/op
                 executeQuery·p0.999:  284.164 ms/op
                 executeQuery·p0.9999: 284.164 ms/op
                 executeQuery·p1.00:   284.164 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 345
  mean =    269.168 ±(99.9%) 1.466 ms/op

  Histogram, ms/op:
    [240.000, 245.000) = 0 
    [245.000, 250.000) = 3 
    [250.000, 255.000) = 10 
    [255.000, 260.000) = 33 
    [260.000, 265.000) = 48 
    [265.000, 270.000) = 95 
    [270.000, 275.000) = 81 
    [275.000, 280.000) = 45 
    [280.000, 285.000) = 15 
    [285.000, 290.000) = 13 
    [290.000, 295.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =    245.629 ms/op
     p(50.0000) =    268.435 ms/op
     p(90.0000) =    279.655 ms/op
     p(95.0000) =    284.164 ms/op
     p(99.0000) =    289.690 ms/op
     p(99.9000) =    292.553 ms/op
     p(99.9900) =    292.553 ms/op
     p(99.9990) =    292.553 ms/op
     p(99.9999) =    292.553 ms/op
    p(100.0000) =    292.553 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 89.24% complete, ETA 02:11:28
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 4429.185 ms/op
# Warmup Iteration   2: 2866.807 ms/op
# Warmup Iteration   3: 2625.634 ±(99.9%) 2054.665 ms/op
# Warmup Iteration   4: 2620.042 ±(99.9%) 2143.008 ms/op
# Warmup Iteration   5: 2509.592 ±(99.9%) 233.772 ms/op
Iteration   1: 2660.587 ±(99.9%) 5280.600 ms/op
                 executeQuery·p0.00:   2487.222 ms/op
                 executeQuery·p0.50:   2499.805 ms/op
                 executeQuery·p0.90:   2994.733 ms/op
                 executeQuery·p0.95:   2994.733 ms/op
                 executeQuery·p0.99:   2994.733 ms/op
                 executeQuery·p0.999:  2994.733 ms/op
                 executeQuery·p0.9999: 2994.733 ms/op
                 executeQuery·p1.00:   2994.733 ms/op

Iteration   2: 2499.805 ±(99.9%) 76.520 ms/op
                 executeQuery·p0.00:   2495.611 ms/op
                 executeQuery·p0.50:   2499.805 ms/op
                 executeQuery·p0.90:   2503.999 ms/op
                 executeQuery·p0.95:   2503.999 ms/op
                 executeQuery·p0.99:   2503.999 ms/op
                 executeQuery·p0.999:  2503.999 ms/op
                 executeQuery·p0.9999: 2503.999 ms/op
                 executeQuery·p1.00:   2503.999 ms/op

Iteration   3: 2638.217 ±(99.9%) 4307.591 ms/op
                 executeQuery·p0.00:   2499.805 ms/op
                 executeQuery·p0.50:   2503.999 ms/op
                 executeQuery·p0.90:   2910.847 ms/op
                 executeQuery·p0.95:   2910.847 ms/op
                 executeQuery·p0.99:   2910.847 ms/op
                 executeQuery·p0.999:  2910.847 ms/op
                 executeQuery·p0.9999: 2910.847 ms/op
                 executeQuery·p1.00:   2910.847 ms/op

Iteration   4: 2564.118 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2562.720 ms/op
                 executeQuery·p0.50:   2562.720 ms/op
                 executeQuery·p0.90:   2566.914 ms/op
                 executeQuery·p0.95:   2566.914 ms/op
                 executeQuery·p0.99:   2566.914 ms/op
                 executeQuery·p0.999:  2566.914 ms/op
                 executeQuery·p0.9999: 2566.914 ms/op
                 executeQuery·p1.00:   2566.914 ms/op

Iteration   5: 2657.791 ±(99.9%) 4727.738 ms/op
                 executeQuery·p0.00:   2503.999 ms/op
                 executeQuery·p0.50:   2512.388 ms/op
                 executeQuery·p0.90:   2956.984 ms/op
                 executeQuery·p0.95:   2956.984 ms/op
                 executeQuery·p0.99:   2956.984 ms/op
                 executeQuery·p0.999:  2956.984 ms/op
                 executeQuery·p0.9999: 2956.984 ms/op
                 executeQuery·p1.00:   2956.984 ms/op


# Run progress: 89.56% complete, ETA 02:07:24
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3655.336 ms/op
# Warmup Iteration   2: 2836.748 ±(99.9%) 935.086 ms/op
# Warmup Iteration   3: 2778.027 ±(99.9%) 44.179 ms/op
# Warmup Iteration   4: 2782.222 ±(99.9%) 116.886 ms/op
# Warmup Iteration   5: 2773.833 ±(99.9%) 44.179 ms/op
Iteration   1: 2779.425 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2776.629 ms/op
                 executeQuery·p0.50:   2780.824 ms/op
                 executeQuery·p0.90:   2780.824 ms/op
                 executeQuery·p0.95:   2780.824 ms/op
                 executeQuery·p0.99:   2780.824 ms/op
                 executeQuery·p0.999:  2780.824 ms/op
                 executeQuery·p0.9999: 2780.824 ms/op
                 executeQuery·p1.00:   2780.824 ms/op

Iteration   2: 2773.833 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2772.435 ms/op
                 executeQuery·p0.50:   2772.435 ms/op
                 executeQuery·p0.90:   2776.629 ms/op
                 executeQuery·p0.95:   2776.629 ms/op
                 executeQuery·p0.99:   2776.629 ms/op
                 executeQuery·p0.999:  2776.629 ms/op
                 executeQuery·p0.9999: 2776.629 ms/op
                 executeQuery·p1.00:   2776.629 ms/op

Iteration   3: 2775.231 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2772.435 ms/op
                 executeQuery·p0.50:   2776.629 ms/op
                 executeQuery·p0.90:   2776.629 ms/op
                 executeQuery·p0.95:   2776.629 ms/op
                 executeQuery·p0.99:   2776.629 ms/op
                 executeQuery·p0.999:  2776.629 ms/op
                 executeQuery·p0.9999: 2776.629 ms/op
                 executeQuery·p1.00:   2776.629 ms/op

Iteration   4: 2773.833 ±(99.9%) 88.357 ms/op
                 executeQuery·p0.00:   2768.241 ms/op
                 executeQuery·p0.50:   2776.629 ms/op
                 executeQuery·p0.90:   2776.629 ms/op
                 executeQuery·p0.95:   2776.629 ms/op
                 executeQuery·p0.99:   2776.629 ms/op
                 executeQuery·p0.999:  2776.629 ms/op
                 executeQuery·p0.9999: 2776.629 ms/op
                 executeQuery·p1.00:   2776.629 ms/op

Iteration   5: 2773.833 ±(99.9%) 44.179 ms/op
                 executeQuery·p0.00:   2772.435 ms/op
                 executeQuery·p0.50:   2772.435 ms/op
                 executeQuery·p0.90:   2776.629 ms/op
                 executeQuery·p0.95:   2776.629 ms/op
                 executeQuery·p0.99:   2776.629 ms/op
                 executeQuery·p0.999:  2776.629 ms/op
                 executeQuery·p0.9999: 2776.629 ms/op
                 executeQuery·p1.00:   2776.629 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 30
  mean =   2689.667 ±(99.9%) 103.232 ms/op

  Histogram, ms/op:
    [2400.000, 2450.000) = 0 
    [2450.000, 2500.000) = 5 
    [2500.000, 2550.000) = 4 
    [2550.000, 2600.000) = 3 
    [2600.000, 2650.000) = 0 
    [2650.000, 2700.000) = 0 
    [2700.000, 2750.000) = 0 
    [2750.000, 2800.000) = 15 
    [2800.000, 2850.000) = 0 
    [2850.000, 2900.000) = 0 
    [2900.000, 2950.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2487.222 ms/op
     p(50.0000) =   2772.435 ms/op
     p(90.0000) =   2897.845 ms/op
     p(95.0000) =   2973.971 ms/op
     p(99.0000) =   2994.733 ms/op
     p(99.9000) =   2994.733 ms/op
     p(99.9900) =   2994.733 ms/op
     p(99.9990) =   2994.733 ms/op
     p(99.9999) =   2994.733 ms/op
    p(100.0000) =   2994.733 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 89.87% complete, ETA 02:03:22
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 356.726 ±(99.9%) 96.591 ms/op
# Warmup Iteration   2: 327.481 ±(99.9%) 15.834 ms/op
# Warmup Iteration   3: 331.069 ±(99.9%) 25.087 ms/op
# Warmup Iteration   4: 353.331 ±(99.9%) 35.853 ms/op
# Warmup Iteration   5: 329.741 ±(99.9%) 29.674 ms/op
Iteration   1: 349.409 ±(99.9%) 34.792 ms/op
                 executeQuery·p0.00:   295.174 ms/op
                 executeQuery·p0.50:   315.097 ms/op
                 executeQuery·p0.90:   411.252 ms/op
                 executeQuery·p0.95:   412.405 ms/op
                 executeQuery·p0.99:   412.615 ms/op
                 executeQuery·p0.999:  412.615 ms/op
                 executeQuery·p0.9999: 412.615 ms/op
                 executeQuery·p1.00:   412.615 ms/op

Iteration   2: 361.603 ±(99.9%) 36.745 ms/op
                 executeQuery·p0.00:   297.271 ms/op
                 executeQuery·p0.50:   397.935 ms/op
                 executeQuery·p0.90:   413.454 ms/op
                 executeQuery·p0.95:   418.382 ms/op
                 executeQuery·p0.99:   419.430 ms/op
                 executeQuery·p0.999:  419.430 ms/op
                 executeQuery·p0.9999: 419.430 ms/op
                 executeQuery·p1.00:   419.430 ms/op

Iteration   3: 343.427 ±(99.9%) 32.304 ms/op
                 executeQuery·p0.00:   300.417 ms/op
                 executeQuery·p0.50:   313.000 ms/op
                 executeQuery·p0.90:   406.376 ms/op
                 executeQuery·p0.95:   415.891 ms/op
                 executeQuery·p0.99:   419.430 ms/op
                 executeQuery·p0.999:  419.430 ms/op
                 executeQuery·p0.9999: 419.430 ms/op
                 executeQuery·p1.00:   419.430 ms/op

Iteration   4: 303.732 ±(99.9%) 2.262 ms/op
                 executeQuery·p0.00:   295.174 ms/op
                 executeQuery·p0.50:   303.038 ms/op
                 executeQuery·p0.90:   308.596 ms/op
                 executeQuery·p0.95:   309.330 ms/op
                 executeQuery·p0.99:   309.330 ms/op
                 executeQuery·p0.999:  309.330 ms/op
                 executeQuery·p0.9999: 309.330 ms/op
                 executeQuery·p1.00:   309.330 ms/op

Iteration   5: 302.074 ±(99.9%) 2.712 ms/op
                 executeQuery·p0.00:   292.553 ms/op
                 executeQuery·p0.50:   301.990 ms/op
                 executeQuery·p0.90:   305.660 ms/op
                 executeQuery·p0.95:   312.371 ms/op
                 executeQuery·p0.99:   316.146 ms/op
                 executeQuery·p0.999:  316.146 ms/op
                 executeQuery·p0.9999: 316.146 ms/op
                 executeQuery·p1.00:   316.146 ms/op


# Run progress: 90.19% complete, ETA 01:59:17
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 343.933 ±(99.9%) 93.620 ms/op
# Warmup Iteration   2: 311.742 ±(99.9%) 6.799 ms/op
# Warmup Iteration   3: 314.206 ±(99.9%) 5.215 ms/op
# Warmup Iteration   4: 296.223 ±(99.9%) 6.401 ms/op
# Warmup Iteration   5: 298.828 ±(99.9%) 4.194 ms/op
Iteration   1: 295.633 ±(99.9%) 4.236 ms/op
                 executeQuery·p0.00:   281.543 ms/op
                 executeQuery·p0.50:   297.796 ms/op
                 executeQuery·p0.90:   303.091 ms/op
                 executeQuery·p0.95:   304.087 ms/op
                 executeQuery·p0.99:   304.087 ms/op
                 executeQuery·p0.999:  304.087 ms/op
                 executeQuery·p0.9999: 304.087 ms/op
                 executeQuery·p1.00:   304.087 ms/op

Iteration   2: 298.500 ±(99.9%) 4.340 ms/op
                 executeQuery·p0.00:   279.970 ms/op
                 executeQuery·p0.50:   300.417 ms/op
                 executeQuery·p0.90:   304.664 ms/op
                 executeQuery·p0.95:   308.517 ms/op
                 executeQuery·p0.99:   310.903 ms/op
                 executeQuery·p0.999:  310.903 ms/op
                 executeQuery·p0.9999: 310.903 ms/op
                 executeQuery·p1.00:   310.903 ms/op

Iteration   3: 299.844 ±(99.9%) 4.259 ms/op
                 executeQuery·p0.00:   286.786 ms/op
                 executeQuery·p0.50:   299.631 ms/op
                 executeQuery·p0.90:   308.176 ms/op
                 executeQuery·p0.95:   313.183 ms/op
                 executeQuery·p0.99:   313.524 ms/op
                 executeQuery·p0.999:  313.524 ms/op
                 executeQuery·p0.9999: 313.524 ms/op
                 executeQuery·p1.00:   313.524 ms/op

Iteration   4: 300.171 ±(99.9%) 3.839 ms/op
                 executeQuery·p0.00:   284.164 ms/op
                 executeQuery·p0.50:   300.417 ms/op
                 executeQuery·p0.90:   306.027 ms/op
                 executeQuery·p0.95:   309.304 ms/op
                 executeQuery·p0.99:   315.097 ms/op
                 executeQuery·p0.999:  315.097 ms/op
                 executeQuery·p0.9999: 315.097 ms/op
                 executeQuery·p1.00:   315.097 ms/op

Iteration   5: 298.926 ±(99.9%) 3.148 ms/op
                 executeQuery·p0.00:   285.737 ms/op
                 executeQuery·p0.50:   299.368 ms/op
                 executeQuery·p0.90:   304.611 ms/op
                 executeQuery·p0.95:   305.660 ms/op
                 executeQuery·p0.99:   305.660 ms/op
                 executeQuery·p0.999:  305.660 ms/op
                 executeQuery·p0.9999: 305.660 ms/op
                 executeQuery·p1.00:   305.660 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery":
  N = 304
  mean =    313.723 ±(99.9%) 6.577 ms/op

  Histogram, ms/op:
    [200.000, 225.000) = 0 
    [225.000, 250.000) = 0 
    [250.000, 275.000) = 0 
    [275.000, 300.000) = 105 
    [300.000, 325.000) = 161 
    [325.000, 350.000) = 2 
    [350.000, 375.000) = 0 
    [375.000, 400.000) = 9 
    [400.000, 425.000) = 27 
    [425.000, 450.000) = 0 
    [450.000, 475.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =    279.970 ms/op
     p(50.0000) =    301.990 ms/op
     p(90.0000) =    398.197 ms/op
     p(95.0000) =    406.585 ms/op
     p(99.0000) =    416.599 ms/op
     p(99.9000) =    419.430 ms/op
     p(99.9900) =    419.430 ms/op
     p(99.9990) =    419.430 ms/op
     p(99.9999) =    419.430 ms/op
    p(100.0000) =    419.430 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 90.51% complete, ETA 01:55:12
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 4915.724 ms/op
# Warmup Iteration   2: 3376.415 ms/op
# Warmup Iteration   3: 3403.678 ms/op
# Warmup Iteration   4: 3527.410 ms/op
# Warmup Iteration   5: 3527.410 ms/op
Iteration   1: 3506.438 ms/op
                 executeQuery·p0.00:   3506.438 ms/op
                 executeQuery·p0.50:   3506.438 ms/op
                 executeQuery·p0.90:   3506.438 ms/op
                 executeQuery·p0.95:   3506.438 ms/op
                 executeQuery·p0.99:   3506.438 ms/op
                 executeQuery·p0.999:  3506.438 ms/op
                 executeQuery·p0.9999: 3506.438 ms/op
                 executeQuery·p1.00:   3506.438 ms/op

Iteration   2: 3285.538 ±(99.9%) 497.868 ms/op
                 executeQuery·p0.00:   3258.974 ms/op
                 executeQuery·p0.50:   3284.140 ms/op
                 executeQuery·p0.90:   3313.500 ms/op
                 executeQuery·p0.95:   3313.500 ms/op
                 executeQuery·p0.99:   3313.500 ms/op
                 executeQuery·p0.999:  3313.500 ms/op
                 executeQuery·p0.9999: 3313.500 ms/op
                 executeQuery·p1.00:   3313.500 ms/op

Iteration   3: 3217.031 ±(99.9%) 809.809 ms/op
                 executeQuery·p0.00:   3166.700 ms/op
                 executeQuery·p0.50:   3233.808 ms/op
                 executeQuery·p0.90:   3250.586 ms/op
                 executeQuery·p0.95:   3250.586 ms/op
                 executeQuery·p0.99:   3250.586 ms/op
                 executeQuery·p0.999:  3250.586 ms/op
                 executeQuery·p0.9999: 3250.586 ms/op
                 executeQuery·p1.00:   3250.586 ms/op

Iteration   4: 3242.197 ±(99.9%) 1764.937 ms/op
                 executeQuery·p0.00:   3141.534 ms/op
                 executeQuery·p0.50:   3250.586 ms/op
                 executeQuery·p0.90:   3334.472 ms/op
                 executeQuery·p0.95:   3334.472 ms/op
                 executeQuery·p0.99:   3334.472 ms/op
                 executeQuery·p0.999:  3334.472 ms/op
                 executeQuery·p0.9999: 3334.472 ms/op
                 executeQuery·p1.00:   3334.472 ms/op

Iteration   5: 3267.363 ±(99.9%) 1417.165 ms/op
                 executeQuery·p0.00:   3179.282 ms/op
                 executeQuery·p0.50:   3296.723 ms/op
                 executeQuery·p0.90:   3326.083 ms/op
                 executeQuery·p0.95:   3326.083 ms/op
                 executeQuery·p0.99:   3326.083 ms/op
                 executeQuery·p0.999:  3326.083 ms/op
                 executeQuery·p0.9999: 3326.083 ms/op
                 executeQuery·p1.00:   3326.083 ms/op


# Run progress: 90.82% complete, ETA 01:51:12
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 4974.445 ms/op
# Warmup Iteration   2: 3581.936 ms/op
# Warmup Iteration   3: 3353.346 ms/op
# Warmup Iteration   4: 3502.244 ms/op
# Warmup Iteration   5: 3571.450 ms/op
Iteration   1: 3558.867 ms/op
                 executeQuery·p0.00:   3552.575 ms/op
                 executeQuery·p0.50:   3558.867 ms/op
                 executeQuery·p0.90:   3565.158 ms/op
                 executeQuery·p0.95:   3565.158 ms/op
                 executeQuery·p0.99:   3565.158 ms/op
                 executeQuery·p0.999:  3565.158 ms/op
                 executeQuery·p0.9999: 3565.158 ms/op
                 executeQuery·p1.00:   3565.158 ms/op

Iteration   2: 3483.369 ms/op
                 executeQuery·p0.00:   3405.775 ms/op
                 executeQuery·p0.50:   3483.369 ms/op
                 executeQuery·p0.90:   3560.964 ms/op
                 executeQuery·p0.95:   3560.964 ms/op
                 executeQuery·p0.99:   3560.964 ms/op
                 executeQuery·p0.999:  3560.964 ms/op
                 executeQuery·p0.9999: 3560.964 ms/op
                 executeQuery·p1.00:   3560.964 ms/op

Iteration   3: 3244.993 ±(99.9%) 2111.353 ms/op
                 executeQuery·p0.00:   3158.311 ms/op
                 executeQuery·p0.50:   3200.254 ms/op
                 executeQuery·p0.90:   3376.415 ms/op
                 executeQuery·p0.95:   3376.415 ms/op
                 executeQuery·p0.99:   3376.415 ms/op
                 executeQuery·p0.999:  3376.415 ms/op
                 executeQuery·p0.9999: 3376.415 ms/op
                 executeQuery·p1.00:   3376.415 ms/op

Iteration   4: 3279.946 ±(99.9%) 1127.206 ms/op
                 executeQuery·p0.00:   3208.643 ms/op
                 executeQuery·p0.50:   3313.500 ms/op
                 executeQuery·p0.90:   3317.694 ms/op
                 executeQuery·p0.95:   3317.694 ms/op
                 executeQuery·p0.99:   3317.694 ms/op
                 executeQuery·p0.999:  3317.694 ms/op
                 executeQuery·p0.9999: 3317.694 ms/op
                 executeQuery·p1.00:   3317.694 ms/op

Iteration   5: 3279.946 ±(99.9%) 1704.175 ms/op
                 executeQuery·p0.00:   3179.282 ms/op
                 executeQuery·p0.50:   3296.723 ms/op
                 executeQuery·p0.90:   3363.832 ms/op
                 executeQuery·p0.95:   3363.832 ms/op
                 executeQuery·p0.99:   3363.832 ms/op
                 executeQuery·p0.999:  3363.832 ms/op
                 executeQuery·p0.9999: 3363.832 ms/op
                 executeQuery·p1.00:   3363.832 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery":
  N = 27
  mean =   3316.607 ±(99.9%) 91.230 ms/op

  Histogram, ms/op:
    [3100.000, 3150.000) = 1 
    [3150.000, 3200.000) = 4 
    [3200.000, 3250.000) = 3 
    [3250.000, 3300.000) = 6 
    [3300.000, 3350.000) = 5 
    [3350.000, 3400.000) = 2 
    [3400.000, 3450.000) = 1 
    [3450.000, 3500.000) = 0 
    [3500.000, 3550.000) = 2 

  Percentiles, ms/op:
      p(0.0000) =   3141.534 ms/op
     p(50.0000) =   3296.723 ms/op
     p(90.0000) =   3554.253 ms/op
     p(95.0000) =   3563.481 ms/op
     p(99.0000) =   3565.158 ms/op
     p(99.9000) =   3565.158 ms/op
     p(99.9900) =   3565.158 ms/op
     p(99.9990) =   3565.158 ms/op
     p(99.9999) =   3565.158 ms/op
    p(100.0000) =   3565.158 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 91.14% complete, ETA 01:47:12
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 339.880 ±(99.9%) 78.457 ms/op
# Warmup Iteration   2: 331.668 ±(99.9%) 29.638 ms/op
# Warmup Iteration   3: 359.077 ±(99.9%) 26.916 ms/op
# Warmup Iteration   4: 305.542 ±(99.9%) 18.739 ms/op
# Warmup Iteration   5: 300.045 ±(99.9%) 5.864 ms/op
Iteration   1: 290.177 ±(99.9%) 4.416 ms/op
                 executeQuery·p0.00:   282.067 ms/op
                 executeQuery·p0.50:   288.096 ms/op
                 executeQuery·p0.90:   303.405 ms/op
                 executeQuery·p0.95:   304.638 ms/op
                 executeQuery·p0.99:   305.660 ms/op
                 executeQuery·p0.999:  305.660 ms/op
                 executeQuery·p0.9999: 305.660 ms/op
                 executeQuery·p1.00:   305.660 ms/op

Iteration   2: 288.867 ±(99.9%) 3.661 ms/op
                 executeQuery·p0.00:   281.543 ms/op
                 executeQuery·p0.50:   287.310 ms/op
                 executeQuery·p0.90:   297.062 ms/op
                 executeQuery·p0.95:   303.720 ms/op
                 executeQuery·p0.99:   304.087 ms/op
                 executeQuery·p0.999:  304.087 ms/op
                 executeQuery·p0.9999: 304.087 ms/op
                 executeQuery·p1.00:   304.087 ms/op

Iteration   3: 286.086 ±(99.9%) 2.975 ms/op
                 executeQuery·p0.00:   278.921 ms/op
                 executeQuery·p0.50:   286.261 ms/op
                 executeQuery·p0.90:   290.351 ms/op
                 executeQuery·p0.95:   295.803 ms/op
                 executeQuery·p0.99:   304.611 ms/op
                 executeQuery·p0.999:  304.611 ms/op
                 executeQuery·p0.9999: 304.611 ms/op
                 executeQuery·p1.00:   304.611 ms/op

Iteration   4: 284.927 ±(99.9%) 7.170 ms/op
                 executeQuery·p0.00:   272.630 ms/op
                 executeQuery·p0.50:   281.543 ms/op
                 executeQuery·p0.90:   293.916 ms/op
                 executeQuery·p0.95:   309.068 ms/op
                 executeQuery·p0.99:   340.263 ms/op
                 executeQuery·p0.999:  340.263 ms/op
                 executeQuery·p0.9999: 340.263 ms/op
                 executeQuery·p1.00:   340.263 ms/op

Iteration   5: 287.993 ±(99.9%) 13.943 ms/op
                 executeQuery·p0.00:   274.727 ms/op
                 executeQuery·p0.50:   284.688 ms/op
                 executeQuery·p0.90:   290.980 ms/op
                 executeQuery·p0.95:   327.470 ms/op
                 executeQuery·p0.99:   408.945 ms/op
                 executeQuery·p0.999:  408.945 ms/op
                 executeQuery·p0.9999: 408.945 ms/op
                 executeQuery·p1.00:   408.945 ms/op


# Run progress: 91.46% complete, ETA 01:43:11
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 342.248 ±(99.9%) 72.188 ms/op
# Warmup Iteration   2: 345.040 ±(99.9%) 29.782 ms/op
# Warmup Iteration   3: 386.526 ±(99.9%) 31.122 ms/op
# Warmup Iteration   4: 312.423 ±(99.9%) 15.042 ms/op
# Warmup Iteration   5: 307.047 ±(99.9%) 5.257 ms/op
Iteration   1: 303.309 ±(99.9%) 4.439 ms/op
                 executeQuery·p0.00:   290.456 ms/op
                 executeQuery·p0.50:   301.466 ms/op
                 executeQuery·p0.90:   314.678 ms/op
                 executeQuery·p0.95:   315.936 ms/op
                 executeQuery·p0.99:   317.194 ms/op
                 executeQuery·p0.999:  317.194 ms/op
                 executeQuery·p0.9999: 317.194 ms/op
                 executeQuery·p1.00:   317.194 ms/op

Iteration   2: 302.108 ±(99.9%) 3.130 ms/op
                 executeQuery·p0.00:   292.028 ms/op
                 executeQuery·p0.50:   301.990 ms/op
                 executeQuery·p0.90:   308.806 ms/op
                 executeQuery·p0.95:   309.330 ms/op
                 executeQuery·p0.99:   309.330 ms/op
                 executeQuery·p0.999:  309.330 ms/op
                 executeQuery·p0.9999: 309.330 ms/op
                 executeQuery·p1.00:   309.330 ms/op

Iteration   3: 320.952 ±(99.9%) 24.235 ms/op
                 executeQuery·p0.00:   286.786 ms/op
                 executeQuery·p0.50:   307.495 ms/op
                 executeQuery·p0.90:   400.713 ms/op
                 executeQuery·p0.95:   411.094 ms/op
                 executeQuery·p0.99:   422.052 ms/op
                 executeQuery·p0.999:  422.052 ms/op
                 executeQuery·p0.9999: 422.052 ms/op
                 executeQuery·p1.00:   422.052 ms/op

Iteration   4: 310.395 ±(99.9%) 17.583 ms/op
                 executeQuery·p0.00:   286.786 ms/op
                 executeQuery·p0.50:   306.184 ms/op
                 executeQuery·p0.90:   350.329 ms/op
                 executeQuery·p0.95:   385.352 ms/op
                 executeQuery·p0.99:   407.372 ms/op
                 executeQuery·p0.999:  407.372 ms/op
                 executeQuery·p0.9999: 407.372 ms/op
                 executeQuery·p1.00:   407.372 ms/op

Iteration   5: 311.864 ±(99.9%) 17.540 ms/op
                 executeQuery·p0.00:   285.737 ms/op
                 executeQuery·p0.50:   303.563 ms/op
                 executeQuery·p0.90:   358.718 ms/op
                 executeQuery·p0.95:   375.626 ms/op
                 executeQuery·p0.99:   393.216 ms/op
                 executeQuery·p0.999:  393.216 ms/op
                 executeQuery·p0.9999: 393.216 ms/op
                 executeQuery·p1.00:   393.216 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 317
  mean =    298.234 ±(99.9%) 4.077 ms/op

  Histogram, ms/op:
    [200.000, 225.000) = 0 
    [225.000, 250.000) = 0 
    [250.000, 275.000) = 2 
    [275.000, 300.000) = 204 
    [300.000, 325.000) = 94 
    [325.000, 350.000) = 3 
    [350.000, 375.000) = 7 
    [375.000, 400.000) = 2 
    [400.000, 425.000) = 5 
    [425.000, 450.000) = 0 
    [450.000, 475.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =    272.630 ms/op
     p(50.0000) =    292.028 ms/op
     p(90.0000) =    313.000 ms/op
     p(95.0000) =    328.938 ms/op
     p(99.0000) =    406.428 ms/op
     p(99.9000) =    422.052 ms/op
     p(99.9900) =    422.052 ms/op
     p(99.9990) =    422.052 ms/op
     p(99.9999) =    422.052 ms/op
    p(100.0000) =    422.052 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 91.77% complete, ETA 01:39:10
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 4974.445 ms/op
# Warmup Iteration   2: 3628.073 ms/op
# Warmup Iteration   3: 3539.993 ms/op
# Warmup Iteration   4: 3934.257 ms/op
# Warmup Iteration   5: 3967.812 ms/op
Iteration   1: 3951.034 ms/op
                 executeQuery·p0.00:   3951.034 ms/op
                 executeQuery·p0.50:   3951.034 ms/op
                 executeQuery·p0.90:   3951.034 ms/op
                 executeQuery·p0.95:   3951.034 ms/op
                 executeQuery·p0.99:   3951.034 ms/op
                 executeQuery·p0.999:  3951.034 ms/op
                 executeQuery·p0.9999: 3951.034 ms/op
                 executeQuery·p1.00:   3951.034 ms/op

Iteration   2: 3468.689 ms/op
                 executeQuery·p0.00:   3439.329 ms/op
                 executeQuery·p0.50:   3468.689 ms/op
                 executeQuery·p0.90:   3498.050 ms/op
                 executeQuery·p0.95:   3498.050 ms/op
                 executeQuery·p0.99:   3498.050 ms/op
                 executeQuery·p0.999:  3498.050 ms/op
                 executeQuery·p0.9999: 3498.050 ms/op
                 executeQuery·p1.00:   3498.050 ms/op

Iteration   3: 3447.718 ms/op
                 executeQuery·p0.00:   3447.718 ms/op
                 executeQuery·p0.50:   3447.718 ms/op
                 executeQuery·p0.90:   3447.718 ms/op
                 executeQuery·p0.95:   3447.718 ms/op
                 executeQuery·p0.99:   3447.718 ms/op
                 executeQuery·p0.999:  3447.718 ms/op
                 executeQuery·p0.9999: 3447.718 ms/op
                 executeQuery·p1.00:   3447.718 ms/op

Iteration   4: 3454.009 ms/op
                 executeQuery·p0.00:   3451.912 ms/op
                 executeQuery·p0.50:   3454.009 ms/op
                 executeQuery·p0.90:   3456.106 ms/op
                 executeQuery·p0.95:   3456.106 ms/op
                 executeQuery·p0.99:   3456.106 ms/op
                 executeQuery·p0.999:  3456.106 ms/op
                 executeQuery·p0.9999: 3456.106 ms/op
                 executeQuery·p1.00:   3456.106 ms/op

Iteration   5: 3351.249 ms/op
                 executeQuery·p0.00:   3351.249 ms/op
                 executeQuery·p0.50:   3351.249 ms/op
                 executeQuery·p0.90:   3351.249 ms/op
                 executeQuery·p0.95:   3351.249 ms/op
                 executeQuery·p0.99:   3351.249 ms/op
                 executeQuery·p0.999:  3351.249 ms/op
                 executeQuery·p0.9999: 3351.249 ms/op
                 executeQuery·p1.00:   3351.249 ms/op


# Run progress: 92.09% complete, ETA 01:35:12
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 4330.619 ms/op
# Warmup Iteration   2: 3472.884 ms/op
# Warmup Iteration   3: 3795.845 ms/op
# Warmup Iteration   4: 3972.006 ms/op
# Warmup Iteration   5: 3644.850 ms/op
Iteration   1: 3531.604 ms/op
                 executeQuery·p0.00:   3422.552 ms/op
                 executeQuery·p0.50:   3531.604 ms/op
                 executeQuery·p0.90:   3640.656 ms/op
                 executeQuery·p0.95:   3640.656 ms/op
                 executeQuery·p0.99:   3640.656 ms/op
                 executeQuery·p0.999:  3640.656 ms/op
                 executeQuery·p0.9999: 3640.656 ms/op
                 executeQuery·p1.00:   3640.656 ms/op

Iteration   2: 3321.889 ±(99.9%) 1012.261 ms/op
                 executeQuery·p0.00:   3279.946 ms/op
                 executeQuery·p0.50:   3300.917 ms/op
                 executeQuery·p0.90:   3384.803 ms/op
                 executeQuery·p0.95:   3384.803 ms/op
                 executeQuery·p0.99:   3384.803 ms/op
                 executeQuery·p0.999:  3384.803 ms/op
                 executeQuery·p0.9999: 3384.803 ms/op
                 executeQuery·p1.00:   3384.803 ms/op

Iteration   3: 3256.178 ±(99.9%) 623.217 ms/op
                 executeQuery·p0.00:   3217.031 ms/op
                 executeQuery·p0.50:   3271.557 ms/op
                 executeQuery·p0.90:   3279.946 ms/op
                 executeQuery·p0.95:   3279.946 ms/op
                 executeQuery·p0.99:   3279.946 ms/op
                 executeQuery·p0.999:  3279.946 ms/op
                 executeQuery·p0.9999: 3279.946 ms/op
                 executeQuery·p1.00:   3279.946 ms/op

Iteration   4: 3145.728 ±(99.9%) 426.044 ms/op
                 executeQuery·p0.00:   3124.756 ms/op
                 executeQuery·p0.50:   3141.534 ms/op
                 executeQuery·p0.90:   3170.894 ms/op
                 executeQuery·p0.95:   3170.894 ms/op
                 executeQuery·p0.99:   3170.894 ms/op
                 executeQuery·p0.999:  3170.894 ms/op
                 executeQuery·p0.9999: 3170.894 ms/op
                 executeQuery·p1.00:   3170.894 ms/op

Iteration   5: 3198.856 ±(99.9%) 377.463 ms/op
                 executeQuery·p0.00:   3175.088 ms/op
                 executeQuery·p0.50:   3208.643 ms/op
                 executeQuery·p0.90:   3212.837 ms/op
                 executeQuery·p0.95:   3212.837 ms/op
                 executeQuery·p0.99:   3212.837 ms/op
                 executeQuery·p0.999:  3212.837 ms/op
                 executeQuery·p0.9999: 3212.837 ms/op
                 executeQuery·p1.00:   3212.837 ms/op



Result "benchmarks.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 24
  mean =   3382.357 ±(99.9%) 167.474 ms/op

  Histogram, ms/op:
    [3100.000, 3150.000) = 2 
    [3150.000, 3200.000) = 2 
    [3200.000, 3250.000) = 3 
    [3250.000, 3300.000) = 3 
    [3300.000, 3350.000) = 1 
    [3350.000, 3400.000) = 3 
    [3400.000, 3450.000) = 4 
    [3450.000, 3500.000) = 3 
    [3500.000, 3550.000) = 0 
    [3550.000, 3600.000) = 0 
    [3600.000, 3650.000) = 1 
    [3650.000, 3700.000) = 0 
    [3700.000, 3750.000) = 0 
    [3750.000, 3800.000) = 0 
    [3800.000, 3850.000) = 0 
    [3850.000, 3900.000) = 0 
    [3900.000, 3950.000) = 0 

  Percentiles, ms/op:
      p(0.0000) =   3124.756 ms/op
     p(50.0000) =   3351.249 ms/op
     p(90.0000) =   3795.845 ms/op
     p(95.0000) =   3951.034 ms/op
     p(99.0000) =   3951.034 ms/op
     p(99.9000) =   3951.034 ms/op
     p(99.9900) =   3951.034 ms/op
     p(99.9990) =   3951.034 ms/op
     p(99.9999) =   3951.034 ms/op
    p(100.0000) =   3951.034 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 92.41% complete, ETA 01:31:15
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 199.675 ±(99.9%) 9.803 ms/op
# Warmup Iteration   2: 190.148 ±(99.9%) 1.485 ms/op
# Warmup Iteration   3: 189.639 ±(99.9%) 1.123 ms/op
# Warmup Iteration   4: 188.546 ±(99.9%) 1.354 ms/op
# Warmup Iteration   5: 187.195 ±(99.9%) 1.182 ms/op
Iteration   1: 186.981 ±(99.9%) 1.222 ms/op
                 executeQuery·p0.00:   181.666 ms/op
                 executeQuery·p0.50:   187.040 ms/op
                 executeQuery·p0.90:   189.792 ms/op
                 executeQuery·p0.95:   190.579 ms/op
                 executeQuery·p0.99:   195.559 ms/op
                 executeQuery·p0.999:  195.559 ms/op
                 executeQuery·p0.9999: 195.559 ms/op
                 executeQuery·p1.00:   195.559 ms/op

Iteration   2: 189.154 ±(99.9%) 1.547 ms/op
                 executeQuery·p0.00:   182.977 ms/op
                 executeQuery·p0.50:   189.268 ms/op
                 executeQuery·p0.90:   192.047 ms/op
                 executeQuery·p0.95:   196.084 ms/op
                 executeQuery·p0.99:   200.802 ms/op
                 executeQuery·p0.999:  200.802 ms/op
                 executeQuery·p0.9999: 200.802 ms/op
                 executeQuery·p1.00:   200.802 ms/op

Iteration   3: 187.797 ±(99.9%) 1.295 ms/op
                 executeQuery·p0.00:   183.239 ms/op
                 executeQuery·p0.50:   187.826 ms/op
                 executeQuery·p0.90:   190.972 ms/op
                 executeQuery·p0.95:   192.610 ms/op
                 executeQuery·p0.99:   195.822 ms/op
                 executeQuery·p0.999:  195.822 ms/op
                 executeQuery·p0.9999: 195.822 ms/op
                 executeQuery·p1.00:   195.822 ms/op

Iteration   4: 188.427 ±(99.9%) 1.216 ms/op
                 executeQuery·p0.00:   180.617 ms/op
                 executeQuery·p0.50:   188.744 ms/op
                 executeQuery·p0.90:   191.260 ms/op
                 executeQuery·p0.95:   192.414 ms/op
                 executeQuery·p0.99:   195.297 ms/op
                 executeQuery·p0.999:  195.297 ms/op
                 executeQuery·p0.9999: 195.297 ms/op
                 executeQuery·p1.00:   195.297 ms/op

Iteration   5: 188.907 ±(99.9%) 1.440 ms/op
                 executeQuery·p0.00:   183.239 ms/op
                 executeQuery·p0.50:   189.792 ms/op
                 executeQuery·p0.90:   192.047 ms/op
                 executeQuery·p0.95:   192.754 ms/op
                 executeQuery·p0.99:   192.938 ms/op
                 executeQuery·p0.999:  192.938 ms/op
                 executeQuery·p0.9999: 192.938 ms/op
                 executeQuery·p1.00:   192.938 ms/op


# Run progress: 92.72% complete, ETA 01:27:17
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 202.317 ±(99.9%) 9.354 ms/op
# Warmup Iteration   2: 190.495 ±(99.9%) 1.595 ms/op
# Warmup Iteration   3: 189.941 ±(99.9%) 1.716 ms/op
# Warmup Iteration   4: 191.713 ±(99.9%) 2.088 ms/op
# Warmup Iteration   5: 191.753 ±(99.9%) 2.170 ms/op
Iteration   1: 191.375 ±(99.9%) 2.146 ms/op
                 executeQuery·p0.00:   182.452 ms/op
                 executeQuery·p0.50:   191.627 ms/op
                 executeQuery·p0.90:   196.608 ms/op
                 executeQuery·p0.95:   197.447 ms/op
                 executeQuery·p0.99:   198.443 ms/op
                 executeQuery·p0.999:  198.443 ms/op
                 executeQuery·p0.9999: 198.443 ms/op
                 executeQuery·p1.00:   198.443 ms/op

Iteration   2: 191.167 ±(99.9%) 2.203 ms/op
                 executeQuery·p0.00:   181.666 ms/op
                 executeQuery·p0.50:   191.365 ms/op
                 executeQuery·p0.90:   195.979 ms/op
                 executeQuery·p0.95:   197.027 ms/op
                 executeQuery·p0.99:   198.443 ms/op
                 executeQuery·p0.999:  198.443 ms/op
                 executeQuery·p0.9999: 198.443 ms/op
                 executeQuery·p1.00:   198.443 ms/op

Iteration   3: 192.157 ±(99.9%) 2.163 ms/op
                 executeQuery·p0.00:   182.977 ms/op
                 executeQuery·p0.50:   193.855 ms/op
                 executeQuery·p0.90:   196.792 ms/op
                 executeQuery·p0.95:   197.958 ms/op
                 executeQuery·p0.99:   202.899 ms/op
                 executeQuery·p0.999:  202.899 ms/op
                 executeQuery·p0.9999: 202.899 ms/op
                 executeQuery·p1.00:   202.899 ms/op

Iteration   4: 191.975 ±(99.9%) 1.879 ms/op
                 executeQuery·p0.00:   183.239 ms/op
                 executeQuery·p0.50:   193.987 ms/op
                 executeQuery·p0.90:   196.005 ms/op
                 executeQuery·p0.95:   196.962 ms/op
                 executeQuery·p0.99:   197.657 ms/op
                 executeQuery·p0.999:  197.657 ms/op
                 executeQuery·p0.9999: 197.657 ms/op
                 executeQuery·p1.00:   197.657 ms/op

Iteration   5: 194.859 ±(99.9%) 2.076 ms/op
                 executeQuery·p0.00:   185.074 ms/op
                 executeQuery·p0.50:   195.166 ms/op
                 executeQuery·p0.90:   200.016 ms/op
                 executeQuery·p0.95:   200.370 ms/op
                 executeQuery·p0.99:   200.802 ms/op
                 executeQuery·p0.999:  200.802 ms/op
                 executeQuery·p0.9999: 200.802 ms/op
                 executeQuery·p1.00:   200.802 ms/op



Result "benchmarks.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 529
  mean =    190.254 ±(99.9%) 0.619 ms/op

  Histogram, ms/op:
    [180.000, 182.500) = 7 
    [182.500, 185.000) = 48 
    [185.000, 187.500) = 94 
    [187.500, 190.000) = 131 
    [190.000, 192.500) = 99 
    [192.500, 195.000) = 48 
    [195.000, 197.500) = 73 
    [197.500, 200.000) = 21 
    [200.000, 202.500) = 7 
    [202.500, 205.000) = 1 
    [205.000, 207.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =    180.617 ms/op
     p(50.0000) =    189.792 ms/op
     p(90.0000) =    195.822 ms/op
     p(95.0000) =    198.050 ms/op
     p(99.0000) =    200.199 ms/op
     p(99.9000) =    202.899 ms/op
     p(99.9900) =    202.899 ms/op
     p(99.9990) =    202.899 ms/op
     p(99.9999) =    202.899 ms/op
    p(100.0000) =    202.899 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 93.04% complete, ETA 01:23:19
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 1886.388 ±(99.9%) 363.294 ms/op
# Warmup Iteration   2: 1851.436 ±(99.9%) 91.061 ms/op
# Warmup Iteration   3: 1845.144 ±(99.9%) 64.573 ms/op
# Warmup Iteration   4: 1831.513 ±(99.9%) 80.776 ms/op
# Warmup Iteration   5: 1807.745 ±(99.9%) 58.098 ms/op
Iteration   1: 1847.940 ±(99.9%) 69.126 ms/op
                 executeQuery·p0.00:   1801.454 ms/op
                 executeQuery·p0.50:   1853.882 ms/op
                 executeQuery·p0.90:   1870.660 ms/op
                 executeQuery·p0.95:   1870.660 ms/op
                 executeQuery·p0.99:   1870.660 ms/op
                 executeQuery·p0.999:  1870.660 ms/op
                 executeQuery·p0.9999: 1870.660 ms/op
                 executeQuery·p1.00:   1870.660 ms/op

Iteration   2: 1851.436 ±(99.9%) 38.548 ms/op
                 executeQuery·p0.00:   1837.105 ms/op
                 executeQuery·p0.50:   1851.785 ms/op
                 executeQuery·p0.90:   1866.465 ms/op
                 executeQuery·p0.95:   1866.465 ms/op
                 executeQuery·p0.99:   1866.465 ms/op
                 executeQuery·p0.999:  1866.465 ms/op
                 executeQuery·p0.9999: 1866.465 ms/op
                 executeQuery·p1.00:   1866.465 ms/op

Iteration   3: 1834.309 ±(99.9%) 82.219 ms/op
                 executeQuery·p0.00:   1797.259 ms/op
                 executeQuery·p0.50:   1846.542 ms/op
                 executeQuery·p0.90:   1862.271 ms/op
                 executeQuery·p0.95:   1862.271 ms/op
                 executeQuery·p0.99:   1862.271 ms/op
                 executeQuery·p0.999:  1862.271 ms/op
                 executeQuery·p0.9999: 1862.271 ms/op
                 executeQuery·p1.00:   1862.271 ms/op

Iteration   4: 1852.834 ±(99.9%) 38.964 ms/op
                 executeQuery·p0.00:   1839.202 ms/op
                 executeQuery·p0.50:   1850.737 ms/op
                 executeQuery·p0.90:   1872.757 ms/op
                 executeQuery·p0.95:   1872.757 ms/op
                 executeQuery·p0.99:   1872.757 ms/op
                 executeQuery·p0.999:  1872.757 ms/op
                 executeQuery·p0.9999: 1872.757 ms/op
                 executeQuery·p1.00:   1872.757 ms/op

Iteration   5: 1863.320 ±(99.9%) 92.443 ms/op
                 executeQuery·p0.00:   1820.328 ms/op
                 executeQuery·p0.50:   1873.805 ms/op
                 executeQuery·p0.90:   1895.825 ms/op
                 executeQuery·p0.95:   1895.825 ms/op
                 executeQuery·p0.99:   1895.825 ms/op
                 executeQuery·p0.999:  1895.825 ms/op
                 executeQuery·p0.9999: 1895.825 ms/op
                 executeQuery·p1.00:   1895.825 ms/op


# Run progress: 93.35% complete, ETA 01:19:24
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 1897.224 ±(99.9%) 288.835 ms/op
# Warmup Iteration   2: 1831.513 ±(99.9%) 51.358 ms/op
# Warmup Iteration   3: 1825.221 ±(99.9%) 61.303 ms/op
# Warmup Iteration   4: 1813.687 ±(99.9%) 23.645 ms/op
# Warmup Iteration   5: 1802.852 ±(99.9%) 26.992 ms/op
Iteration   1: 1811.590 ±(99.9%) 29.148 ms/op
                 executeQuery·p0.00:   1795.162 ms/op
                 executeQuery·p0.50:   1815.085 ms/op
                 executeQuery·p0.90:   1822.425 ms/op
                 executeQuery·p0.95:   1822.425 ms/op
                 executeQuery·p0.99:   1822.425 ms/op
                 executeQuery·p0.999:  1822.425 ms/op
                 executeQuery·p0.9999: 1822.425 ms/op
                 executeQuery·p1.00:   1822.425 ms/op

Iteration   2: 1814.386 ±(99.9%) 31.432 ms/op
                 executeQuery·p0.00:   1801.454 ms/op
                 executeQuery·p0.50:   1814.036 ms/op
                 executeQuery·p0.90:   1830.814 ms/op
                 executeQuery·p0.95:   1830.814 ms/op
                 executeQuery·p0.99:   1830.814 ms/op
                 executeQuery·p0.999:  1830.814 ms/op
                 executeQuery·p0.9999: 1830.814 ms/op
                 executeQuery·p1.00:   1830.814 ms/op

Iteration   3: 1812.289 ±(99.9%) 20.513 ms/op
                 executeQuery·p0.00:   1801.454 ms/op
                 executeQuery·p0.50:   1815.085 ms/op
                 executeQuery·p0.90:   1818.231 ms/op
                 executeQuery·p0.95:   1818.231 ms/op
                 executeQuery·p0.99:   1818.231 ms/op
                 executeQuery·p0.999:  1818.231 ms/op
                 executeQuery·p0.9999: 1818.231 ms/op
                 executeQuery·p1.00:   1818.231 ms/op

Iteration   4: 1832.212 ±(99.9%) 95.528 ms/op
                 executeQuery·p0.00:   1805.648 ms/op
                 executeQuery·p0.50:   1817.182 ms/op
                 executeQuery·p0.90:   1893.728 ms/op
                 executeQuery·p0.95:   1893.728 ms/op
                 executeQuery·p0.99:   1893.728 ms/op
                 executeQuery·p0.999:  1893.728 ms/op
                 executeQuery·p0.9999: 1893.728 ms/op
                 executeQuery·p1.00:   1893.728 ms/op

Iteration   5: 1857.727 ±(99.9%) 108.527 ms/op
                 executeQuery·p0.00:   1820.328 ms/op
                 executeQuery·p0.50:   1858.077 ms/op
                 executeQuery·p0.90:   1893.728 ms/op
                 executeQuery·p0.95:   1893.728 ms/op
                 executeQuery·p0.99:   1893.728 ms/op
                 executeQuery·p0.999:  1893.728 ms/op
                 executeQuery·p0.9999: 1893.728 ms/op
                 executeQuery·p1.00:   1893.728 ms/op



Result "benchmarks.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery":
  N = 60
  mean =   1837.804 ±(99.9%) 13.063 ms/op

  Histogram, ms/op:
    [1700.000, 1712.500) = 0 
    [1712.500, 1725.000) = 0 
    [1725.000, 1737.500) = 0 
    [1737.500, 1750.000) = 0 
    [1750.000, 1762.500) = 0 
    [1762.500, 1775.000) = 0 
    [1775.000, 1787.500) = 0 
    [1787.500, 1800.000) = 3 
    [1800.000, 1812.500) = 12 
    [1812.500, 1825.000) = 14 
    [1825.000, 1837.500) = 3 
    [1837.500, 1850.000) = 9 
    [1850.000, 1862.500) = 6 
    [1862.500, 1875.000) = 7 
    [1875.000, 1887.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =   1795.162 ms/op
     p(50.0000) =   1833.959 ms/op
     p(90.0000) =   1889.953 ms/op
     p(95.0000) =   1893.728 ms/op
     p(99.0000) =   1895.825 ms/op
     p(99.9000) =   1895.825 ms/op
     p(99.9900) =   1895.825 ms/op
     p(99.9990) =   1895.825 ms/op
     p(99.9999) =   1895.825 ms/op
    p(100.0000) =   1895.825 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 93.67% complete, ETA 01:15:29
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 208.667 ±(99.9%) 31.347 ms/op
# Warmup Iteration   2: 191.799 ±(99.9%) 2.900 ms/op
# Warmup Iteration   3: 191.266 ±(99.9%) 1.701 ms/op
# Warmup Iteration   4: 190.401 ±(99.9%) 1.857 ms/op
# Warmup Iteration   5: 192.167 ±(99.9%) 1.324 ms/op
Iteration   1: 189.941 ±(99.9%) 1.690 ms/op
                 executeQuery·p0.00:   182.452 ms/op
                 executeQuery·p0.50:   189.006 ms/op
                 executeQuery·p0.90:   194.511 ms/op
                 executeQuery·p0.95:   195.822 ms/op
                 executeQuery·p0.99:   202.637 ms/op
                 executeQuery·p0.999:  202.637 ms/op
                 executeQuery·p0.9999: 202.637 ms/op
                 executeQuery·p1.00:   202.637 ms/op

Iteration   2: 188.966 ±(99.9%) 1.706 ms/op
                 executeQuery·p0.00:   183.239 ms/op
                 executeQuery·p0.50:   188.744 ms/op
                 executeQuery·p0.90:   194.616 ms/op
                 executeQuery·p0.95:   195.035 ms/op
                 executeQuery·p0.99:   200.016 ms/op
                 executeQuery·p0.999:  200.016 ms/op
                 executeQuery·p0.9999: 200.016 ms/op
                 executeQuery·p1.00:   200.016 ms/op

Iteration   3: 189.016 ±(99.9%) 1.639 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   188.744 ms/op
                 executeQuery·p0.90:   192.781 ms/op
                 executeQuery·p0.95:   196.162 ms/op
                 executeQuery·p0.99:   201.589 ms/op
                 executeQuery·p0.999:  201.589 ms/op
                 executeQuery·p0.9999: 201.589 ms/op
                 executeQuery·p1.00:   201.589 ms/op

Iteration   4: 189.451 ±(99.9%) 1.441 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   189.530 ms/op
                 executeQuery·p0.90:   193.882 ms/op
                 executeQuery·p0.95:   195.900 ms/op
                 executeQuery·p0.99:   196.084 ms/op
                 executeQuery·p0.999:  196.084 ms/op
                 executeQuery·p0.9999: 196.084 ms/op
                 executeQuery·p1.00:   196.084 ms/op

Iteration   5: 194.546 ±(99.9%) 1.164 ms/op
                 executeQuery·p0.00:   188.744 ms/op
                 executeQuery·p0.50:   194.511 ms/op
                 executeQuery·p0.90:   196.870 ms/op
                 executeQuery·p0.95:   197.132 ms/op
                 executeQuery·p0.99:   203.948 ms/op
                 executeQuery·p0.999:  203.948 ms/op
                 executeQuery·p0.9999: 203.948 ms/op
                 executeQuery·p1.00:   203.948 ms/op


# Run progress: 93.99% complete, ETA 01:11:35
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 212.203 ±(99.9%) 30.670 ms/op
# Warmup Iteration   2: 196.120 ±(99.9%) 2.440 ms/op
# Warmup Iteration   3: 194.153 ±(99.9%) 1.191 ms/op
# Warmup Iteration   4: 194.677 ±(99.9%) 1.066 ms/op
# Warmup Iteration   5: 193.377 ±(99.9%) 1.416 ms/op
Iteration   1: 193.387 ±(99.9%) 1.438 ms/op
                 executeQuery·p0.00:   188.482 ms/op
                 executeQuery·p0.50:   193.331 ms/op
                 executeQuery·p0.90:   196.529 ms/op
                 executeQuery·p0.95:   197.145 ms/op
                 executeQuery·p0.99:   206.307 ms/op
                 executeQuery·p0.999:  206.307 ms/op
                 executeQuery·p0.9999: 206.307 ms/op
                 executeQuery·p1.00:   206.307 ms/op

Iteration   2: 193.755 ±(99.9%) 1.358 ms/op
                 executeQuery·p0.00:   186.909 ms/op
                 executeQuery·p0.50:   193.593 ms/op
                 executeQuery·p0.90:   196.608 ms/op
                 executeQuery·p0.95:   197.748 ms/op
                 executeQuery·p0.99:   204.210 ms/op
                 executeQuery·p0.999:  204.210 ms/op
                 executeQuery·p0.9999: 204.210 ms/op
                 executeQuery·p1.00:   204.210 ms/op

Iteration   3: 192.615 ±(99.9%) 1.462 ms/op
                 executeQuery·p0.00:   186.122 ms/op
                 executeQuery·p0.50:   192.545 ms/op
                 executeQuery·p0.90:   196.084 ms/op
                 executeQuery·p0.95:   196.975 ms/op
                 executeQuery·p0.99:   200.278 ms/op
                 executeQuery·p0.999:  200.278 ms/op
                 executeQuery·p0.9999: 200.278 ms/op
                 executeQuery·p1.00:   200.278 ms/op

Iteration   4: 192.590 ±(99.9%) 1.450 ms/op
                 executeQuery·p0.00:   186.122 ms/op
                 executeQuery·p0.50:   192.676 ms/op
                 executeQuery·p0.90:   196.529 ms/op
                 executeQuery·p0.95:   196.975 ms/op
                 executeQuery·p0.99:   198.181 ms/op
                 executeQuery·p0.999:  198.181 ms/op
                 executeQuery·p0.9999: 198.181 ms/op
                 executeQuery·p1.00:   198.181 ms/op

Iteration   5: 192.958 ±(99.9%) 1.614 ms/op
                 executeQuery·p0.00:   185.860 ms/op
                 executeQuery·p0.50:   193.593 ms/op
                 executeQuery·p0.90:   195.926 ms/op
                 executeQuery·p0.95:   196.608 ms/op
                 executeQuery·p0.99:   204.210 ms/op
                 executeQuery·p0.999:  204.210 ms/op
                 executeQuery·p0.9999: 204.210 ms/op
                 executeQuery·p1.00:   204.210 ms/op



Result "benchmarks.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery":
  N = 524
  mean =    191.704 ±(99.9%) 0.536 ms/op

  Histogram, ms/op:
    [180.000, 182.500) = 1 
    [182.500, 185.000) = 18 
    [185.000, 187.500) = 56 
    [187.500, 190.000) = 96 
    [190.000, 192.500) = 127 
    [192.500, 195.000) = 107 
    [195.000, 197.500) = 105 
    [197.500, 200.000) = 6 
    [200.000, 202.500) = 3 
    [202.500, 205.000) = 4 
    [205.000, 207.500) = 1 

  Percentiles, ms/op:
      p(0.0000) =    182.452 ms/op
     p(50.0000) =    191.627 ms/op
     p(90.0000) =    196.084 ms/op
     p(95.0000) =    196.608 ms/op
     p(99.0000) =    202.375 ms/op
     p(99.9000) =    206.307 ms/op
     p(99.9900) =    206.307 ms/op
     p(99.9990) =    206.307 ms/op
     p(99.9999) =    206.307 ms/op
    p(100.0000) =    206.307 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 94.30% complete, ETA 01:07:41
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2009.491 ±(99.9%) 927.271 ms/op
# Warmup Iteration   2: 1854.581 ±(99.9%) 24.858 ms/op
# Warmup Iteration   3: 1829.416 ±(99.9%) 55.125 ms/op
# Warmup Iteration   4: 1808.095 ±(99.9%) 24.788 ms/op
# Warmup Iteration   5: 1808.794 ±(99.9%) 35.432 ms/op
Iteration   1: 1830.464 ±(99.9%) 47.254 ms/op
                 executeQuery·p0.00:   1805.648 ms/op
                 executeQuery·p0.50:   1833.959 ms/op
                 executeQuery·p0.90:   1851.785 ms/op
                 executeQuery·p0.95:   1851.785 ms/op
                 executeQuery·p0.99:   1851.785 ms/op
                 executeQuery·p0.999:  1851.785 ms/op
                 executeQuery·p0.9999: 1851.785 ms/op
                 executeQuery·p1.00:   1851.785 ms/op

Iteration   2: 1830.115 ±(99.9%) 32.988 ms/op
                 executeQuery·p0.00:   1809.842 ms/op
                 executeQuery·p0.50:   1832.911 ms/op
                 executeQuery·p0.90:   1843.397 ms/op
                 executeQuery·p0.95:   1843.397 ms/op
                 executeQuery·p0.99:   1843.397 ms/op
                 executeQuery·p0.999:  1843.397 ms/op
                 executeQuery·p0.9999: 1843.397 ms/op
                 executeQuery·p1.00:   1843.397 ms/op

Iteration   3: 1814.386 ±(99.9%) 67.506 ms/op
                 executeQuery·p0.00:   1793.065 ms/op
                 executeQuery·p0.50:   1809.842 ms/op
                 executeQuery·p0.90:   1860.174 ms/op
                 executeQuery·p0.95:   1860.174 ms/op
                 executeQuery·p0.99:   1860.174 ms/op
                 executeQuery·p0.999:  1860.174 ms/op
                 executeQuery·p0.9999: 1860.174 ms/op
                 executeQuery·p1.00:   1860.174 ms/op

Iteration   4: 1819.978 ±(99.9%) 79.547 ms/op
                 executeQuery·p0.00:   1788.871 ms/op
                 executeQuery·p0.50:   1820.328 ms/op
                 executeQuery·p0.90:   1851.785 ms/op
                 executeQuery·p0.95:   1851.785 ms/op
                 executeQuery·p0.99:   1851.785 ms/op
                 executeQuery·p0.999:  1851.785 ms/op
                 executeQuery·p0.9999: 1851.785 ms/op
                 executeQuery·p1.00:   1851.785 ms/op

Iteration   5: 1822.775 ±(99.9%) 81.352 ms/op
                 executeQuery·p0.00:   1795.162 ms/op
                 executeQuery·p0.50:   1820.328 ms/op
                 executeQuery·p0.90:   1855.980 ms/op
                 executeQuery·p0.95:   1855.980 ms/op
                 executeQuery·p0.99:   1855.980 ms/op
                 executeQuery·p0.999:  1855.980 ms/op
                 executeQuery·p0.9999: 1855.980 ms/op
                 executeQuery·p1.00:   1855.980 ms/op


# Run progress: 94.62% complete, ETA 01:03:49
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 2027.107 ±(99.9%) 917.856 ms/op
# Warmup Iteration   2: 1835.358 ±(99.9%) 118.169 ms/op
# Warmup Iteration   3: 1801.454 ±(99.9%) 29.986 ms/op
# Warmup Iteration   4: 1811.590 ±(99.9%) 87.339 ms/op
# Warmup Iteration   5: 1822.775 ±(99.9%) 104.963 ms/op
Iteration   1: 1891.981 ±(99.9%) 440.384 ms/op
                 executeQuery·p0.00:   1786.774 ms/op
                 executeQuery·p0.50:   1848.639 ms/op
                 executeQuery·p0.90:   2206.204 ms/op
                 executeQuery·p0.95:   2206.204 ms/op
                 executeQuery·p0.99:   2206.204 ms/op
                 executeQuery·p0.999:  2206.204 ms/op
                 executeQuery·p0.9999: 2206.204 ms/op
                 executeQuery·p1.00:   2206.204 ms/op

Iteration   2: 1821.377 ±(99.9%) 100.955 ms/op
                 executeQuery·p0.00:   1784.676 ms/op
                 executeQuery·p0.50:   1819.279 ms/op
                 executeQuery·p0.90:   1862.271 ms/op
                 executeQuery·p0.95:   1862.271 ms/op
                 executeQuery·p0.99:   1862.271 ms/op
                 executeQuery·p0.999:  1862.271 ms/op
                 executeQuery·p0.9999: 1862.271 ms/op
                 executeQuery·p1.00:   1862.271 ms/op

Iteration   3: 1823.124 ±(99.9%) 105.963 ms/op
                 executeQuery·p0.00:   1786.774 ms/op
                 executeQuery·p0.50:   1823.474 ms/op
                 executeQuery·p0.90:   1864.368 ms/op
                 executeQuery·p0.95:   1864.368 ms/op
                 executeQuery·p0.99:   1864.368 ms/op
                 executeQuery·p0.999:  1864.368 ms/op
                 executeQuery·p0.9999: 1864.368 ms/op
                 executeQuery·p1.00:   1864.368 ms/op

Iteration   4: 1821.726 ±(99.9%) 104.252 ms/op
                 executeQuery·p0.00:   1786.774 ms/op
                 executeQuery·p0.50:   1819.279 ms/op
                 executeQuery·p0.90:   1864.368 ms/op
                 executeQuery·p0.95:   1864.368 ms/op
                 executeQuery·p0.99:   1864.368 ms/op
                 executeQuery·p0.999:  1864.368 ms/op
                 executeQuery·p0.9999: 1864.368 ms/op
                 executeQuery·p1.00:   1864.368 ms/op

Iteration   5: 1809.143 ±(99.9%) 104.782 ms/op
                 executeQuery·p0.00:   1782.579 ms/op
                 executeQuery·p0.50:   1787.822 ms/op
                 executeQuery·p0.90:   1862.271 ms/op
                 executeQuery·p0.95:   1862.271 ms/op
                 executeQuery·p0.99:   1862.271 ms/op
                 executeQuery·p0.999:  1862.271 ms/op
                 executeQuery·p0.9999: 1862.271 ms/op
                 executeQuery·p1.00:   1862.271 ms/op



Result "benchmarks.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery":
  N = 60
  mean =   1828.507 ±(99.9%) 25.579 ms/op

  Histogram, ms/op:
    [1700.000, 1750.000) = 0 
    [1750.000, 1800.000) = 23 
    [1800.000, 1850.000) = 21 
    [1850.000, 1900.000) = 15 
    [1900.000, 1950.000) = 0 
    [1950.000, 2000.000) = 0 
    [2000.000, 2050.000) = 0 
    [2050.000, 2100.000) = 0 
    [2100.000, 2150.000) = 0 
    [2150.000, 2200.000) = 0 
    [2200.000, 2250.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   1782.579 ms/op
     p(50.0000) =   1827.668 ms/op
     p(90.0000) =   1862.061 ms/op
     p(95.0000) =   1864.368 ms/op
     p(99.0000) =   2206.204 ms/op
     p(99.9000) =   2206.204 ms/op
     p(99.9900) =   2206.204 ms/op
     p(99.9990) =   2206.204 ms/op
     p(99.9999) =   2206.204 ms/op
    p(100.0000) =   2206.204 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 94.94% complete, ETA 00:59:58
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 196.802 ±(99.9%) 11.481 ms/op
# Warmup Iteration   2: 189.194 ±(99.9%) 1.942 ms/op
# Warmup Iteration   3: 189.031 ±(99.9%) 1.558 ms/op
# Warmup Iteration   4: 187.512 ±(99.9%) 1.988 ms/op
# Warmup Iteration   5: 185.627 ±(99.9%) 1.438 ms/op
Iteration   1: 185.633 ±(99.9%) 1.595 ms/op
                 executeQuery·p0.00:   182.452 ms/op
                 executeQuery·p0.50:   183.501 ms/op
                 executeQuery·p0.90:   190.579 ms/op
                 executeQuery·p0.95:   190.998 ms/op
                 executeQuery·p0.99:   192.152 ms/op
                 executeQuery·p0.999:  192.152 ms/op
                 executeQuery·p0.9999: 192.152 ms/op
                 executeQuery·p1.00:   192.152 ms/op

Iteration   2: 188.139 ±(99.9%) 2.816 ms/op
                 executeQuery·p0.00:   182.190 ms/op
                 executeQuery·p0.50:   188.088 ms/op
                 executeQuery·p0.90:   198.024 ms/op
                 executeQuery·p0.95:   199.845 ms/op
                 executeQuery·p0.99:   209.191 ms/op
                 executeQuery·p0.999:  209.191 ms/op
                 executeQuery·p0.9999: 209.191 ms/op
                 executeQuery·p1.00:   209.191 ms/op

Iteration   3: 184.282 ±(99.9%) 1.395 ms/op
                 executeQuery·p0.00:   181.404 ms/op
                 executeQuery·p0.50:   182.714 ms/op
                 executeQuery·p0.90:   189.687 ms/op
                 executeQuery·p0.95:   190.579 ms/op
                 executeQuery·p0.99:   191.627 ms/op
                 executeQuery·p0.999:  191.627 ms/op
                 executeQuery·p0.9999: 191.627 ms/op
                 executeQuery·p1.00:   191.627 ms/op

Iteration   4: 184.693 ±(99.9%) 1.582 ms/op
                 executeQuery·p0.00:   181.404 ms/op
                 executeQuery·p0.50:   182.452 ms/op
                 executeQuery·p0.90:   190.212 ms/op
                 executeQuery·p0.95:   190.657 ms/op
                 executeQuery·p0.99:   191.627 ms/op
                 executeQuery·p0.999:  191.627 ms/op
                 executeQuery·p0.9999: 191.627 ms/op
                 executeQuery·p1.00:   191.627 ms/op

Iteration   5: 188.819 ±(99.9%) 2.123 ms/op
                 executeQuery·p0.00:   182.190 ms/op
                 executeQuery·p0.50:   189.137 ms/op
                 executeQuery·p0.90:   196.267 ms/op
                 executeQuery·p0.95:   196.962 ms/op
                 executeQuery·p0.99:   198.181 ms/op
                 executeQuery·p0.999:  198.181 ms/op
                 executeQuery·p0.9999: 198.181 ms/op
                 executeQuery·p1.00:   198.181 ms/op


# Run progress: 95.25% complete, ETA 00:56:07
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 202.506 ±(99.9%) 11.249 ms/op
# Warmup Iteration   2: 194.254 ±(99.9%) 1.281 ms/op
# Warmup Iteration   3: 193.235 ±(99.9%) 1.407 ms/op
# Warmup Iteration   4: 192.867 ±(99.9%) 1.817 ms/op
# Warmup Iteration   5: 185.899 ±(99.9%) 1.420 ms/op
Iteration   1: 188.704 ±(99.9%) 1.713 ms/op
                 executeQuery·p0.00:   182.190 ms/op
                 executeQuery·p0.50:   186.909 ms/op
                 executeQuery·p0.90:   194.301 ms/op
                 executeQuery·p0.95:   194.852 ms/op
                 executeQuery·p0.99:   195.297 ms/op
                 executeQuery·p0.999:  195.297 ms/op
                 executeQuery·p0.9999: 195.297 ms/op
                 executeQuery·p1.00:   195.297 ms/op

Iteration   2: 190.070 ±(99.9%) 1.972 ms/op
                 executeQuery·p0.00:   181.666 ms/op
                 executeQuery·p0.50:   189.530 ms/op
                 executeQuery·p0.90:   196.870 ms/op
                 executeQuery·p0.95:   197.316 ms/op
                 executeQuery·p0.99:   197.919 ms/op
                 executeQuery·p0.999:  197.919 ms/op
                 executeQuery·p0.9999: 197.919 ms/op
                 executeQuery·p1.00:   197.919 ms/op

Iteration   3: 187.262 ±(99.9%) 2.416 ms/op
                 executeQuery·p0.00:   181.404 ms/op
                 executeQuery·p0.50:   188.613 ms/op
                 executeQuery·p0.90:   192.335 ms/op
                 executeQuery·p0.95:   197.250 ms/op
                 executeQuery·p0.99:   201.064 ms/op
                 executeQuery·p0.999:  201.064 ms/op
                 executeQuery·p0.9999: 201.064 ms/op
                 executeQuery·p1.00:   201.064 ms/op

Iteration   4: 187.524 ±(99.9%) 2.297 ms/op
                 executeQuery·p0.00:   180.879 ms/op
                 executeQuery·p0.50:   188.744 ms/op
                 executeQuery·p0.90:   193.174 ms/op
                 executeQuery·p0.95:   196.805 ms/op
                 executeQuery·p0.99:   198.705 ms/op
                 executeQuery·p0.999:  198.705 ms/op
                 executeQuery·p0.9999: 198.705 ms/op
                 executeQuery·p1.00:   198.705 ms/op

Iteration   5: 191.992 ±(99.9%) 1.067 ms/op
                 executeQuery·p0.00:   190.054 ms/op
                 executeQuery·p0.50:   191.365 ms/op
                 executeQuery·p0.90:   195.559 ms/op
                 executeQuery·p0.95:   198.758 ms/op
                 executeQuery·p0.99:   200.016 ms/op
                 executeQuery·p0.999:  200.016 ms/op
                 executeQuery·p0.9999: 200.016 ms/op
                 executeQuery·p1.00:   200.016 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery":
  N = 523
  mean =    187.689 ±(99.9%) 0.669 ms/op

  Histogram, ms/op:
    [180.000, 182.500) = 106 
    [182.500, 185.000) = 80 
    [185.000, 187.500) = 53 
    [187.500, 190.000) = 103 
    [190.000, 192.500) = 126 
    [192.500, 195.000) = 19 
    [195.000, 197.500) = 20 
    [197.500, 200.000) = 12 
    [200.000, 202.500) = 3 
    [202.500, 205.000) = 0 
    [205.000, 207.500) = 0 

  Percentiles, ms/op:
      p(0.0000) =    180.879 ms/op
     p(50.0000) =    188.744 ms/op
     p(90.0000) =    193.095 ms/op
     p(95.0000) =    196.346 ms/op
     p(99.0000) =    199.628 ms/op
     p(99.9000) =    209.191 ms/op
     p(99.9900) =    209.191 ms/op
     p(99.9990) =    209.191 ms/op
     p(99.9999) =    209.191 ms/op
    p(100.0000) =    209.191 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 95.57% complete, ETA 00:52:16
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 1881.145 ±(99.9%) 317.455 ms/op
# Warmup Iteration   2: 1817.881 ±(99.9%) 88.753 ms/op
# Warmup Iteration   3: 1789.570 ±(99.9%) 47.144 ms/op
# Warmup Iteration   4: 1805.298 ±(99.9%) 113.145 ms/op
# Warmup Iteration   5: 1794.114 ±(99.9%) 55.511 ms/op
Iteration   1: 1804.599 ±(99.9%) 87.048 ms/op
                 executeQuery·p0.00:   1774.191 ms/op
                 executeQuery·p0.50:   1805.648 ms/op
                 executeQuery·p0.90:   1832.911 ms/op
                 executeQuery·p0.95:   1832.911 ms/op
                 executeQuery·p0.99:   1832.911 ms/op
                 executeQuery·p0.999:  1832.911 ms/op
                 executeQuery·p0.9999: 1832.911 ms/op
                 executeQuery·p1.00:   1832.911 ms/op

Iteration   2: 1809.842 ±(99.9%) 92.909 ms/op
                 executeQuery·p0.00:   1776.288 ms/op
                 executeQuery·p0.50:   1809.842 ms/op
                 executeQuery·p0.90:   1845.494 ms/op
                 executeQuery·p0.95:   1845.494 ms/op
                 executeQuery·p0.99:   1845.494 ms/op
                 executeQuery·p0.999:  1845.494 ms/op
                 executeQuery·p0.9999: 1845.494 ms/op
                 executeQuery·p1.00:   1845.494 ms/op

Iteration   3: 1792.016 ±(99.9%) 79.663 ms/op
                 executeQuery·p0.00:   1767.899 ms/op
                 executeQuery·p0.50:   1780.482 ms/op
                 executeQuery·p0.90:   1832.911 ms/op
                 executeQuery·p0.95:   1832.911 ms/op
                 executeQuery·p0.99:   1832.911 ms/op
                 executeQuery·p0.999:  1832.911 ms/op
                 executeQuery·p0.9999: 1832.911 ms/op
                 executeQuery·p1.00:   1832.911 ms/op

Iteration   4: 1772.443 ±(99.9%) 37.456 ms/op
                 executeQuery·p0.00:   1761.608 ms/op
                 executeQuery·p0.50:   1768.948 ms/op
                 executeQuery·p0.90:   1797.259 ms/op
                 executeQuery·p0.95:   1797.259 ms/op
                 executeQuery·p0.99:   1797.259 ms/op
                 executeQuery·p0.999:  1797.259 ms/op
                 executeQuery·p0.9999: 1797.259 ms/op
                 executeQuery·p1.00:   1797.259 ms/op

Iteration   5: 1788.172 ±(99.9%) 54.367 ms/op
                 executeQuery·p0.00:   1765.802 ms/op
                 executeQuery·p0.50:   1793.065 ms/op
                 executeQuery·p0.90:   1816.134 ms/op
                 executeQuery·p0.95:   1816.134 ms/op
                 executeQuery·p0.99:   1816.134 ms/op
                 executeQuery·p0.999:  1816.134 ms/op
                 executeQuery·p0.9999: 1816.134 ms/op
                 executeQuery·p1.00:   1816.134 ms/op


# Run progress: 95.89% complete, ETA 00:48:27
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 1886.738 ±(99.9%) 380.660 ms/op
# Warmup Iteration   2: 1815.435 ±(99.9%) 93.256 ms/op
# Warmup Iteration   3: 1810.192 ±(99.9%) 98.504 ms/op
# Warmup Iteration   4: 1801.454 ±(99.9%) 86.988 ms/op
# Warmup Iteration   5: 1817.182 ±(99.9%) 93.780 ms/op
Iteration   1: 1812.988 ±(99.9%) 87.127 ms/op
                 executeQuery·p0.00:   1782.579 ms/op
                 executeQuery·p0.50:   1812.988 ms/op
                 executeQuery·p0.90:   1843.397 ms/op
                 executeQuery·p0.95:   1843.397 ms/op
                 executeQuery·p0.99:   1843.397 ms/op
                 executeQuery·p0.999:  1843.397 ms/op
                 executeQuery·p0.9999: 1843.397 ms/op
                 executeQuery·p1.00:   1843.397 ms/op

Iteration   2: 1807.395 ±(99.9%) 92.118 ms/op
                 executeQuery·p0.00:   1774.191 ms/op
                 executeQuery·p0.50:   1808.794 ms/op
                 executeQuery·p0.90:   1839.202 ms/op
                 executeQuery·p0.95:   1839.202 ms/op
                 executeQuery·p0.99:   1839.202 ms/op
                 executeQuery·p0.999:  1839.202 ms/op
                 executeQuery·p0.9999: 1839.202 ms/op
                 executeQuery·p1.00:   1839.202 ms/op

Iteration   3: 1809.493 ±(99.9%) 79.721 ms/op
                 executeQuery·p0.00:   1774.191 ms/op
                 executeQuery·p0.50:   1817.182 ms/op
                 executeQuery·p0.90:   1839.202 ms/op
                 executeQuery·p0.95:   1839.202 ms/op
                 executeQuery·p0.99:   1839.202 ms/op
                 executeQuery·p0.999:  1839.202 ms/op
                 executeQuery·p0.9999: 1839.202 ms/op
                 executeQuery·p1.00:   1839.202 ms/op

Iteration   4: 1819.279 ±(99.9%) 82.478 ms/op
                 executeQuery·p0.00:   1795.162 ms/op
                 executeQuery·p0.50:   1803.551 ms/op
                 executeQuery·p0.90:   1858.077 ms/op
                 executeQuery·p0.95:   1858.077 ms/op
                 executeQuery·p0.99:   1858.077 ms/op
                 executeQuery·p0.999:  1858.077 ms/op
                 executeQuery·p0.9999: 1858.077 ms/op
                 executeQuery·p1.00:   1858.077 ms/op

Iteration   5: 1819.279 ±(99.9%) 82.729 ms/op
                 executeQuery·p0.00:   1795.162 ms/op
                 executeQuery·p0.50:   1804.599 ms/op
                 executeQuery·p0.90:   1858.077 ms/op
                 executeQuery·p0.95:   1858.077 ms/op
                 executeQuery·p0.99:   1858.077 ms/op
                 executeQuery·p0.999:  1858.077 ms/op
                 executeQuery·p0.9999: 1858.077 ms/op
                 executeQuery·p1.00:   1858.077 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery":
  N = 60
  mean =   1803.551 ±(99.9%) 13.289 ms/op

  Histogram, ms/op:
    [1760.000, 1770.000) = 8 
    [1770.000, 1780.000) = 10 
    [1780.000, 1790.000) = 7 
    [1790.000, 1800.000) = 8 
    [1800.000, 1810.000) = 5 
    [1810.000, 1820.000) = 1 
    [1820.000, 1830.000) = 1 
    [1830.000, 1840.000) = 13 
    [1840.000, 1850.000) = 3 

  Percentiles, ms/op:
      p(0.0000) =   1761.608 ms/op
     p(50.0000) =   1796.211 ms/op
     p(90.0000) =   1843.187 ms/op
     p(95.0000) =   1855.980 ms/op
     p(99.0000) =   1858.077 ms/op
     p(99.9000) =   1858.077 ms/op
     p(99.9900) =   1858.077 ms/op
     p(99.9990) =   1858.077 ms/op
     p(99.9999) =   1858.077 ms/op
    p(100.0000) =   1858.077 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 96.20% complete, ETA 00:44:39
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 196.996 ±(99.9%) 11.878 ms/op
# Warmup Iteration   2: 190.148 ±(99.9%) 2.279 ms/op
# Warmup Iteration   3: 191.123 ±(99.9%) 2.307 ms/op
# Warmup Iteration   4: 186.564 ±(99.9%) 1.467 ms/op
# Warmup Iteration   5: 185.782 ±(99.9%) 1.635 ms/op
Iteration   1: 185.919 ±(99.9%) 2.093 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   183.501 ms/op
                 executeQuery·p0.90:   191.889 ms/op
                 executeQuery·p0.95:   196.608 ms/op
                 executeQuery·p0.99:   198.181 ms/op
                 executeQuery·p0.999:  198.181 ms/op
                 executeQuery·p0.9999: 198.181 ms/op
                 executeQuery·p1.00:   198.181 ms/op

Iteration   2: 185.959 ±(99.9%) 2.050 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   183.239 ms/op
                 executeQuery·p0.90:   191.313 ms/op
                 executeQuery·p0.95:   196.162 ms/op
                 executeQuery·p0.99:   196.870 ms/op
                 executeQuery·p0.999:  196.870 ms/op
                 executeQuery·p0.9999: 196.870 ms/op
                 executeQuery·p1.00:   196.870 ms/op

Iteration   3: 185.667 ±(99.9%) 1.786 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   183.501 ms/op
                 executeQuery·p0.90:   191.785 ms/op
                 executeQuery·p0.95:   193.279 ms/op
                 executeQuery·p0.99:   193.724 ms/op
                 executeQuery·p0.999:  193.724 ms/op
                 executeQuery·p0.9999: 193.724 ms/op
                 executeQuery·p1.00:   193.724 ms/op

Iteration   4: 185.657 ±(99.9%) 1.701 ms/op
                 executeQuery·p0.00:   182.190 ms/op
                 executeQuery·p0.50:   183.239 ms/op
                 executeQuery·p0.90:   191.260 ms/op
                 executeQuery·p0.95:   191.785 ms/op
                 executeQuery·p0.99:   192.938 ms/op
                 executeQuery·p0.999:  192.938 ms/op
                 executeQuery·p0.9999: 192.938 ms/op
                 executeQuery·p1.00:   192.938 ms/op

Iteration   5: 185.924 ±(99.9%) 1.746 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   183.501 ms/op
                 executeQuery·p0.90:   190.841 ms/op
                 executeQuery·p0.95:   191.785 ms/op
                 executeQuery·p0.99:   195.297 ms/op
                 executeQuery·p0.999:  195.297 ms/op
                 executeQuery·p0.9999: 195.297 ms/op
                 executeQuery·p1.00:   195.297 ms/op


# Run progress: 96.52% complete, ETA 00:40:52
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 196.487 ±(99.9%) 11.618 ms/op
# Warmup Iteration   2: 188.397 ±(99.9%) 1.623 ms/op
# Warmup Iteration   3: 188.056 ±(99.9%) 1.817 ms/op
# Warmup Iteration   4: 188.610 ±(99.9%) 1.379 ms/op
# Warmup Iteration   5: 187.141 ±(99.9%) 1.422 ms/op
Iteration   1: 186.775 ±(99.9%) 1.946 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   184.025 ms/op
                 executeQuery·p0.90:   193.095 ms/op
                 executeQuery·p0.95:   193.541 ms/op
                 executeQuery·p0.99:   194.249 ms/op
                 executeQuery·p0.999:  194.249 ms/op
                 executeQuery·p0.9999: 194.249 ms/op
                 executeQuery·p1.00:   194.249 ms/op

Iteration   2: 185.870 ±(99.9%) 1.867 ms/op
                 executeQuery·p0.00:   182.714 ms/op
                 executeQuery·p0.50:   183.501 ms/op
                 executeQuery·p0.90:   192.833 ms/op
                 executeQuery·p0.95:   193.541 ms/op
                 executeQuery·p0.99:   196.084 ms/op
                 executeQuery·p0.999:  196.084 ms/op
                 executeQuery·p0.9999: 196.084 ms/op
                 executeQuery·p1.00:   196.084 ms/op

Iteration   3: 187.630 ±(99.9%) 1.926 ms/op
                 executeQuery·p0.00:   181.928 ms/op
                 executeQuery·p0.50:   185.598 ms/op
                 executeQuery·p0.90:   192.676 ms/op
                 executeQuery·p0.95:   193.724 ms/op
                 executeQuery·p0.99:   198.181 ms/op
                 executeQuery·p0.999:  198.181 ms/op
                 executeQuery·p0.9999: 198.181 ms/op
                 executeQuery·p1.00:   198.181 ms/op

Iteration   4: 185.400 ±(99.9%) 1.976 ms/op
                 executeQuery·p0.00:   181.666 ms/op
                 executeQuery·p0.50:   182.714 ms/op
                 executeQuery·p0.90:   191.942 ms/op
                 executeQuery·p0.95:   192.754 ms/op
                 executeQuery·p0.99:   193.724 ms/op
                 executeQuery·p0.999:  193.724 ms/op
                 executeQuery·p0.9999: 193.724 ms/op
                 executeQuery·p1.00:   193.724 ms/op

Iteration   5: 185.474 ±(99.9%) 1.905 ms/op
                 executeQuery·p0.00:   181.666 ms/op
                 executeQuery·p0.50:   182.977 ms/op
                 executeQuery·p0.90:   192.047 ms/op
                 executeQuery·p0.95:   192.938 ms/op
                 executeQuery·p0.99:   192.938 ms/op
                 executeQuery·p0.999:  192.938 ms/op
                 executeQuery·p0.9999: 192.938 ms/op
                 executeQuery·p1.00:   192.938 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 529
  mean =    186.025 ±(99.9%) 0.574 ms/op

  Histogram, ms/op:
    [180.000, 181.250) = 0 
    [181.250, 182.500) = 42 
    [182.500, 183.750) = 239 
    [183.750, 185.000) = 36 
    [185.000, 186.250) = 17 
    [186.250, 187.500) = 16 
    [187.500, 188.750) = 21 
    [188.750, 190.000) = 23 
    [190.000, 191.250) = 55 
    [191.250, 192.500) = 40 
    [192.500, 193.750) = 28 
    [193.750, 195.000) = 1 
    [195.000, 196.250) = 5 
    [196.250, 197.500) = 4 
    [197.500, 198.750) = 2 

  Percentiles, ms/op:
      p(0.0000) =    181.666 ms/op
     p(50.0000) =    183.501 ms/op
     p(90.0000) =    191.889 ms/op
     p(95.0000) =    192.938 ms/op
     p(99.0000) =    196.529 ms/op
     p(99.9000) =    198.181 ms/op
     p(99.9900) =    198.181 ms/op
     p(99.9990) =    198.181 ms/op
     p(99.9999) =    198.181 ms/op
    p(100.0000) =    198.181 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 96.84% complete, ETA 00:37:05
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 1928.331 ±(99.9%) 256.736 ms/op
# Warmup Iteration   2: 1852.135 ±(99.9%) 101.137 ms/op
# Warmup Iteration   3: 1823.124 ±(99.9%) 106.094 ms/op
# Warmup Iteration   4: 1814.036 ±(99.9%) 101.109 ms/op
# Warmup Iteration   5: 1832.212 ±(99.9%) 93.256 ms/op
Iteration   1: 1821.377 ±(99.9%) 98.457 ms/op
                 executeQuery·p0.00:   1776.288 ms/op
                 executeQuery·p0.50:   1840.251 ms/op
                 executeQuery·p0.90:   1849.688 ms/op
                 executeQuery·p0.95:   1849.688 ms/op
                 executeQuery·p0.99:   1849.688 ms/op
                 executeQuery·p0.999:  1849.688 ms/op
                 executeQuery·p0.9999: 1849.688 ms/op
                 executeQuery·p1.00:   1849.688 ms/op

Iteration   2: 1819.279 ±(99.9%) 91.767 ms/op
                 executeQuery·p0.00:   1780.482 ms/op
                 executeQuery·p0.50:   1827.668 ms/op
                 executeQuery·p0.90:   1849.688 ms/op
                 executeQuery·p0.95:   1849.688 ms/op
                 executeQuery·p0.99:   1849.688 ms/op
                 executeQuery·p0.999:  1849.688 ms/op
                 executeQuery·p0.9999: 1849.688 ms/op
                 executeQuery·p1.00:   1849.688 ms/op

Iteration   3: 1827.318 ±(99.9%) 111.498 ms/op
                 executeQuery·p0.00:   1776.288 ms/op
                 executeQuery·p0.50:   1843.397 ms/op
                 executeQuery·p0.90:   1866.465 ms/op
                 executeQuery·p0.95:   1866.465 ms/op
                 executeQuery·p0.99:   1866.465 ms/op
                 executeQuery·p0.999:  1866.465 ms/op
                 executeQuery·p0.9999: 1866.465 ms/op
                 executeQuery·p1.00:   1866.465 ms/op

Iteration   4: 1822.076 ±(99.9%) 95.437 ms/op
                 executeQuery·p0.00:   1776.288 ms/op
                 executeQuery·p0.50:   1840.251 ms/op
                 executeQuery·p0.90:   1847.591 ms/op
                 executeQuery·p0.95:   1847.591 ms/op
                 executeQuery·p0.99:   1847.591 ms/op
                 executeQuery·p0.999:  1847.591 ms/op
                 executeQuery·p0.9999: 1847.591 ms/op
                 executeQuery·p1.00:   1847.591 ms/op

Iteration   5: 1823.823 ±(99.9%) 104.848 ms/op
                 executeQuery·p0.00:   1778.385 ms/op
                 executeQuery·p0.50:   1826.619 ms/op
                 executeQuery·p0.90:   1870.660 ms/op
                 executeQuery·p0.95:   1870.660 ms/op
                 executeQuery·p0.99:   1870.660 ms/op
                 executeQuery·p0.999:  1870.660 ms/op
                 executeQuery·p0.9999: 1870.660 ms/op
                 executeQuery·p1.00:   1870.660 ms/op


# Run progress: 97.15% complete, ETA 00:33:19
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 1937.419 ±(99.9%) 368.955 ms/op
# Warmup Iteration   2: 1833.959 ±(99.9%) 90.017 ms/op
# Warmup Iteration   3: 1851.086 ±(99.9%) 202.685 ms/op
# Warmup Iteration   4: 1825.221 ±(99.9%) 51.626 ms/op
# Warmup Iteration   5: 1815.435 ±(99.9%) 63.629 ms/op
Iteration   1: 1809.143 ±(99.9%) 58.769 ms/op
                 executeQuery·p0.00:   1793.065 ms/op
                 executeQuery·p0.50:   1805.648 ms/op
                 executeQuery·p0.90:   1849.688 ms/op
                 executeQuery·p0.95:   1849.688 ms/op
                 executeQuery·p0.99:   1849.688 ms/op
                 executeQuery·p0.999:  1849.688 ms/op
                 executeQuery·p0.9999: 1849.688 ms/op
                 executeQuery·p1.00:   1849.688 ms/op

Iteration   2: 1862.621 ±(99.9%) 295.060 ms/op
                 executeQuery·p0.00:   1784.676 ms/op
                 executeQuery·p0.50:   1840.251 ms/op
                 executeQuery·p0.90:   2069.889 ms/op
                 executeQuery·p0.95:   2069.889 ms/op
                 executeQuery·p0.99:   2069.889 ms/op
                 executeQuery·p0.999:  2069.889 ms/op
                 executeQuery·p0.9999: 2069.889 ms/op
                 executeQuery·p1.00:   2069.889 ms/op

Iteration   3: 1846.193 ±(99.9%) 84.296 ms/op
                 executeQuery·p0.00:   1793.065 ms/op
                 executeQuery·p0.50:   1846.542 ms/op
                 executeQuery·p0.90:   1876.951 ms/op
                 executeQuery·p0.95:   1876.951 ms/op
                 executeQuery·p0.99:   1876.951 ms/op
                 executeQuery·p0.999:  1876.951 ms/op
                 executeQuery·p0.9999: 1876.951 ms/op
                 executeQuery·p1.00:   1876.951 ms/op

Iteration   4: 1827.318 ±(99.9%) 79.742 ms/op
                 executeQuery·p0.00:   1788.871 ms/op
                 executeQuery·p0.50:   1841.299 ms/op
                 executeQuery·p0.90:   1849.688 ms/op
                 executeQuery·p0.95:   1849.688 ms/op
                 executeQuery·p0.99:   1849.688 ms/op
                 executeQuery·p0.999:  1849.688 ms/op
                 executeQuery·p0.9999: 1849.688 ms/op
                 executeQuery·p1.00:   1849.688 ms/op

Iteration   5: 1789.220 ±(99.9%) 17.610 ms/op
                 executeQuery·p0.00:   1780.482 ms/op
                 executeQuery·p0.50:   1788.871 ms/op
                 executeQuery·p0.90:   1799.356 ms/op
                 executeQuery·p0.95:   1799.356 ms/op
                 executeQuery·p0.99:   1799.356 ms/op
                 executeQuery·p0.999:  1799.356 ms/op
                 executeQuery·p0.9999: 1799.356 ms/op
                 executeQuery·p1.00:   1799.356 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery":
  N = 60
  mean =   1824.837 ±(99.9%) 20.104 ms/op

  Histogram, ms/op:
    [1700.000, 1725.000) = 0 
    [1725.000, 1750.000) = 0 
    [1750.000, 1775.000) = 0 
    [1775.000, 1800.000) = 23 
    [1800.000, 1825.000) = 5 
    [1825.000, 1850.000) = 25 
    [1850.000, 1875.000) = 5 
    [1875.000, 1900.000) = 1 
    [1900.000, 1925.000) = 0 
    [1925.000, 1950.000) = 0 
    [1950.000, 1975.000) = 0 
    [1975.000, 2000.000) = 0 
    [2000.000, 2025.000) = 0 
    [2025.000, 2050.000) = 0 
    [2050.000, 2075.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   1776.288 ms/op
     p(50.0000) =   1839.202 ms/op
     p(90.0000) =   1855.560 ms/op
     p(95.0000) =   1872.652 ms/op
     p(99.0000) =   2069.889 ms/op
     p(99.9000) =   2069.889 ms/op
     p(99.9900) =   2069.889 ms/op
     p(99.9990) =   2069.889 ms/op
     p(99.9999) =   2069.889 ms/op
    p(100.0000) =   2069.889 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 97.47% complete, ETA 00:29:34
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 331.219 ±(99.9%) 111.579 ms/op
# Warmup Iteration   2: 204.825 ±(99.9%) 4.077 ms/op
# Warmup Iteration   3: 204.970 ±(99.9%) 5.657 ms/op
# Warmup Iteration   4: 205.355 ±(99.9%) 4.812 ms/op
# Warmup Iteration   5: 203.108 ±(99.9%) 3.288 ms/op
Iteration   1: 202.732 ±(99.9%) 3.310 ms/op
                 executeQuery·p0.00:   194.511 ms/op
                 executeQuery·p0.50:   201.982 ms/op
                 executeQuery·p0.90:   211.078 ms/op
                 executeQuery·p0.95:   214.814 ms/op
                 executeQuery·p0.99:   235.667 ms/op
                 executeQuery·p0.999:  235.667 ms/op
                 executeQuery·p0.9999: 235.667 ms/op
                 executeQuery·p1.00:   235.667 ms/op

Iteration   2: 203.340 ±(99.9%) 2.399 ms/op
                 executeQuery·p0.00:   195.035 ms/op
                 executeQuery·p0.50:   202.113 ms/op
                 executeQuery·p0.90:   211.026 ms/op
                 executeQuery·p0.95:   216.334 ms/op
                 executeQuery·p0.99:   219.939 ms/op
                 executeQuery·p0.999:  219.939 ms/op
                 executeQuery·p0.9999: 219.939 ms/op
                 executeQuery·p1.00:   219.939 ms/op

Iteration   3: 203.622 ±(99.9%) 4.455 ms/op
                 executeQuery·p0.00:   190.579 ms/op
                 executeQuery·p0.50:   201.589 ms/op
                 executeQuery·p0.90:   214.434 ms/op
                 executeQuery·p0.95:   219.939 ms/op
                 executeQuery·p0.99:   246.940 ms/op
                 executeQuery·p0.999:  246.940 ms/op
                 executeQuery·p0.9999: 246.940 ms/op
                 executeQuery·p1.00:   246.940 ms/op

Iteration   4: 198.674 ±(99.9%) 2.974 ms/op
                 executeQuery·p0.00:   190.054 ms/op
                 executeQuery·p0.50:   196.870 ms/op
                 executeQuery·p0.90:   207.566 ms/op
                 executeQuery·p0.95:   214.172 ms/op
                 executeQuery·p0.99:   217.842 ms/op
                 executeQuery·p0.999:  217.842 ms/op
                 executeQuery·p0.9999: 217.842 ms/op
                 executeQuery·p1.00:   217.842 ms/op

Iteration   5: 198.386 ±(99.9%) 2.639 ms/op
                 executeQuery·p0.00:   191.103 ms/op
                 executeQuery·p0.50:   197.657 ms/op
                 executeQuery·p0.90:   204.525 ms/op
                 executeQuery·p0.95:   210.082 ms/op
                 executeQuery·p0.99:   219.415 ms/op
                 executeQuery·p0.999:  219.415 ms/op
                 executeQuery·p0.9999: 219.415 ms/op
                 executeQuery·p1.00:   219.415 ms/op


# Run progress: 97.78% complete, ETA 00:25:49
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 325.769 ±(99.9%) 105.560 ms/op
# Warmup Iteration   2: 202.837 ±(99.9%) 4.748 ms/op
# Warmup Iteration   3: 203.718 ±(99.9%) 3.876 ms/op
# Warmup Iteration   4: 200.891 ±(99.9%) 2.148 ms/op
# Warmup Iteration   5: 200.949 ±(99.9%) 1.975 ms/op
Iteration   1: 201.552 ±(99.9%) 3.720 ms/op
                 executeQuery·p0.00:   191.365 ms/op
                 executeQuery·p0.50:   199.623 ms/op
                 executeQuery·p0.90:   212.048 ms/op
                 executeQuery·p0.95:   216.505 ms/op
                 executeQuery·p0.99:   235.930 ms/op
                 executeQuery·p0.999:  235.930 ms/op
                 executeQuery·p0.9999: 235.930 ms/op
                 executeQuery·p1.00:   235.930 ms/op

Iteration   2: 201.358 ±(99.9%) 2.456 ms/op
                 executeQuery·p0.00:   192.938 ms/op
                 executeQuery·p0.50:   200.671 ms/op
                 executeQuery·p0.90:   206.805 ms/op
                 executeQuery·p0.95:   214.604 ms/op
                 executeQuery·p0.99:   217.580 ms/op
                 executeQuery·p0.999:  217.580 ms/op
                 executeQuery·p0.9999: 217.580 ms/op
                 executeQuery·p1.00:   217.580 ms/op

Iteration   3: 200.142 ±(99.9%) 2.362 ms/op
                 executeQuery·p0.00:   192.676 ms/op
                 executeQuery·p0.50:   200.016 ms/op
                 executeQuery·p0.90:   206.098 ms/op
                 executeQuery·p0.95:   211.275 ms/op
                 executeQuery·p0.99:   217.580 ms/op
                 executeQuery·p0.999:  217.580 ms/op
                 executeQuery·p0.9999: 217.580 ms/op
                 executeQuery·p1.00:   217.580 ms/op

Iteration   4: 202.055 ±(99.9%) 5.797 ms/op
                 executeQuery·p0.00:   191.103 ms/op
                 executeQuery·p0.50:   199.885 ms/op
                 executeQuery·p0.90:   211.891 ms/op
                 executeQuery·p0.95:   215.391 ms/op
                 executeQuery·p0.99:   274.203 ms/op
                 executeQuery·p0.999:  274.203 ms/op
                 executeQuery·p0.9999: 274.203 ms/op
                 executeQuery·p1.00:   274.203 ms/op

Iteration   5: 201.117 ±(99.9%) 3.505 ms/op
                 executeQuery·p0.00:   191.103 ms/op
                 executeQuery·p0.50:   199.623 ms/op
                 executeQuery·p0.90:   209.165 ms/op
                 executeQuery·p0.95:   216.177 ms/op
                 executeQuery·p0.99:   236.454 ms/op
                 executeQuery·p0.999:  236.454 ms/op
                 executeQuery·p0.9999: 236.454 ms/op
                 executeQuery·p1.00:   236.454 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedSimd.executeQuery":
  N = 501
  mean =    201.282 ±(99.9%) 1.070 ms/op

  Histogram, ms/op:
    [190.000, 195.000) = 53 
    [195.000, 200.000) = 161 
    [200.000, 205.000) = 212 
    [205.000, 210.000) = 33 
    [210.000, 215.000) = 20 
    [215.000, 220.000) = 16 
    [220.000, 225.000) = 1 
    [225.000, 230.000) = 0 
    [230.000, 235.000) = 0 
    [235.000, 240.000) = 3 
    [240.000, 245.000) = 0 
    [245.000, 250.000) = 1 
    [250.000, 255.000) = 0 
    [255.000, 260.000) = 0 
    [260.000, 265.000) = 0 
    [265.000, 270.000) = 0 
    [270.000, 275.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =    190.054 ms/op
     p(50.0000) =    200.540 ms/op
     p(90.0000) =    207.880 ms/op
     p(95.0000) =    214.172 ms/op
     p(99.0000) =    235.363 ms/op
     p(99.9000) =    274.203 ms/op
     p(99.9900) =    274.203 ms/op
     p(99.9990) =    274.203 ms/op
     p(99.9999) =    274.203 ms/op
    p(100.0000) =    274.203 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedSimd.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 98.10% complete, ETA 00:22:06
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3447.718 ±(99.9%) 25059.244 ms/op
# Warmup Iteration   2: 2069.470 ±(99.9%) 255.838 ms/op
# Warmup Iteration   3: 2049.337 ±(99.9%) 81.237 ms/op
# Warmup Iteration   4: 2154.195 ±(99.9%) 559.520 ms/op
# Warmup Iteration   5: 2066.953 ±(99.9%) 92.180 ms/op
Iteration   1: 2070.308 ±(99.9%) 54.292 ms/op
                 executeQuery·p0.00:   2053.112 ms/op
                 executeQuery·p0.50:   2078.278 ms/op
                 executeQuery·p0.90:   2084.569 ms/op
                 executeQuery·p0.95:   2084.569 ms/op
                 executeQuery·p0.99:   2084.569 ms/op
                 executeQuery·p0.999:  2084.569 ms/op
                 executeQuery·p0.9999: 2084.569 ms/op
                 executeQuery·p1.00:   2084.569 ms/op

Iteration   2: 2070.308 ±(99.9%) 69.561 ms/op
                 executeQuery·p0.00:   2040.529 ms/op
                 executeQuery·p0.50:   2071.986 ms/op
                 executeQuery·p0.90:   2086.666 ms/op
                 executeQuery·p0.95:   2086.666 ms/op
                 executeQuery·p0.99:   2086.666 ms/op
                 executeQuery·p0.999:  2086.666 ms/op
                 executeQuery·p0.9999: 2086.666 ms/op
                 executeQuery·p1.00:   2086.666 ms/op

Iteration   3: 2081.214 ±(99.9%) 17.692 ms/op
                 executeQuery·p0.00:   2074.083 ms/op
                 executeQuery·p0.50:   2082.472 ms/op
                 executeQuery·p0.90:   2086.666 ms/op
                 executeQuery·p0.95:   2086.666 ms/op
                 executeQuery·p0.99:   2086.666 ms/op
                 executeQuery·p0.999:  2086.666 ms/op
                 executeQuery·p0.9999: 2086.666 ms/op
                 executeQuery·p1.00:   2086.666 ms/op

Iteration   4: 2071.147 ±(99.9%) 40.618 ms/op
                 executeQuery·p0.00:   2059.403 ms/op
                 executeQuery·p0.50:   2071.986 ms/op
                 executeQuery·p0.90:   2082.472 ms/op
                 executeQuery·p0.95:   2082.472 ms/op
                 executeQuery·p0.99:   2082.472 ms/op
                 executeQuery·p0.999:  2082.472 ms/op
                 executeQuery·p0.9999: 2082.472 ms/op
                 executeQuery·p1.00:   2082.472 ms/op

Iteration   5: 2077.858 ±(99.9%) 23.124 ms/op
                 executeQuery·p0.00:   2069.889 ms/op
                 executeQuery·p0.50:   2078.278 ms/op
                 executeQuery·p0.90:   2084.569 ms/op
                 executeQuery·p0.95:   2084.569 ms/op
                 executeQuery·p0.99:   2084.569 ms/op
                 executeQuery·p0.999:  2084.569 ms/op
                 executeQuery·p0.9999: 2084.569 ms/op
                 executeQuery·p1.00:   2084.569 ms/op


# Run progress: 98.42% complete, ETA 00:18:23
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3499.448 ±(99.9%) 24016.264 ms/op
# Warmup Iteration   2: 2150.000 ±(99.9%) 439.326 ms/op
# Warmup Iteration   3: 2138.676 ±(99.9%) 679.159 ms/op
# Warmup Iteration   4: 2043.045 ±(99.9%) 108.252 ms/op
# Warmup Iteration   5: 2276.668 ±(99.9%) 413.882 ms/op
Iteration   1: 2086.247 ±(99.9%) 199.071 ms/op
                 executeQuery·p0.00:   2025.849 ms/op
                 executeQuery·p0.50:   2082.472 ms/op
                 executeQuery·p0.90:   2168.455 ms/op
                 executeQuery·p0.95:   2168.455 ms/op
                 executeQuery·p0.99:   2168.455 ms/op
                 executeQuery·p0.999:  2168.455 ms/op
                 executeQuery·p0.9999: 2168.455 ms/op
                 executeQuery·p1.00:   2168.455 ms/op

Iteration   2: 2122.737 ±(99.9%) 518.506 ms/op
                 executeQuery·p0.00:   2032.140 ms/op
                 executeQuery·p0.50:   2074.083 ms/op
                 executeQuery·p0.90:   2361.393 ms/op
                 executeQuery·p0.95:   2361.393 ms/op
                 executeQuery·p0.99:   2361.393 ms/op
                 executeQuery·p0.999:  2361.393 ms/op
                 executeQuery·p0.9999: 2361.393 ms/op
                 executeQuery·p1.00:   2361.393 ms/op

Iteration   3: 2094.635 ±(99.9%) 98.473 ms/op
                 executeQuery·p0.00:   2071.986 ms/op
                 executeQuery·p0.50:   2078.278 ms/op
                 executeQuery·p0.90:   2126.512 ms/op
                 executeQuery·p0.95:   2126.512 ms/op
                 executeQuery·p0.99:   2126.512 ms/op
                 executeQuery·p0.999:  2126.512 ms/op
                 executeQuery·p0.9999: 2126.512 ms/op
                 executeQuery·p1.00:   2126.512 ms/op

Iteration   4: 2124.834 ±(99.9%) 596.114 ms/op
                 executeQuery·p0.00:   2030.043 ms/op
                 executeQuery·p0.50:   2067.792 ms/op
                 executeQuery·p0.90:   2399.142 ms/op
                 executeQuery·p0.95:   2399.142 ms/op
                 executeQuery·p0.99:   2399.142 ms/op
                 executeQuery·p0.999:  2399.142 ms/op
                 executeQuery·p0.9999: 2399.142 ms/op
                 executeQuery·p1.00:   2399.142 ms/op

Iteration   5: 2070.308 ±(99.9%) 356.526 ms/op
                 executeQuery·p0.00:   2021.655 ms/op
                 executeQuery·p0.50:   2030.043 ms/op
                 executeQuery·p0.90:   2235.564 ms/op
                 executeQuery·p0.95:   2235.564 ms/op
                 executeQuery·p0.99:   2235.564 ms/op
                 executeQuery·p0.999:  2235.564 ms/op
                 executeQuery·p0.9999: 2235.564 ms/op
                 executeQuery·p1.00:   2235.564 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedSimd.executeQuery":
  N = 50
  mean =   2086.960 ±(99.9%) 34.546 ms/op

  Histogram, ms/op:
    [2000.000, 2025.000) = 1 
    [2025.000, 2050.000) = 8 
    [2050.000, 2075.000) = 15 
    [2075.000, 2100.000) = 20 
    [2100.000, 2125.000) = 1 
    [2125.000, 2150.000) = 1 
    [2150.000, 2175.000) = 1 
    [2175.000, 2200.000) = 0 
    [2200.000, 2225.000) = 0 
    [2225.000, 2250.000) = 1 
    [2250.000, 2275.000) = 0 
    [2275.000, 2300.000) = 0 
    [2300.000, 2325.000) = 0 
    [2325.000, 2350.000) = 0 
    [2350.000, 2375.000) = 1 

  Percentiles, ms/op:
      p(0.0000) =   2021.655 ms/op
     p(50.0000) =   2078.278 ms/op
     p(90.0000) =   2125.673 ms/op
     p(95.0000) =   2292.187 ms/op
     p(99.0000) =   2399.142 ms/op
     p(99.9000) =   2399.142 ms/op
     p(99.9900) =   2399.142 ms/op
     p(99.9990) =   2399.142 ms/op
     p(99.9999) =   2399.142 ms/op
    p(100.0000) =   2399.142 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-1)

# Run progress: 98.73% complete, ETA 00:14:41
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 454.987 ±(99.9%) 145.576 ms/op
# Warmup Iteration   2: 287.564 ±(99.9%) 3.981 ms/op
# Warmup Iteration   3: 289.152 ±(99.9%) 2.926 ms/op
# Warmup Iteration   4: 276.911 ±(99.9%) 4.242 ms/op
# Warmup Iteration   5: 282.897 ±(99.9%) 4.005 ms/op
Iteration   1: 285.737 ±(99.9%) 1.667 ms/op
                 executeQuery·p0.00:   281.543 ms/op
                 executeQuery·p0.50:   285.737 ms/op
                 executeQuery·p0.90:   290.875 ms/op
                 executeQuery·p0.95:   292.133 ms/op
                 executeQuery·p0.99:   292.553 ms/op
                 executeQuery·p0.999:  292.553 ms/op
                 executeQuery·p0.9999: 292.553 ms/op
                 executeQuery·p1.00:   292.553 ms/op

Iteration   2: 285.707 ±(99.9%) 2.111 ms/op
                 executeQuery·p0.00:   280.494 ms/op
                 executeQuery·p0.50:   284.688 ms/op
                 executeQuery·p0.90:   290.875 ms/op
                 executeQuery·p0.95:   294.126 ms/op
                 executeQuery·p0.99:   296.223 ms/op
                 executeQuery·p0.999:  296.223 ms/op
                 executeQuery·p0.9999: 296.223 ms/op
                 executeQuery·p1.00:   296.223 ms/op

Iteration   3: 288.343 ±(99.9%) 1.942 ms/op
                 executeQuery·p0.00:   284.164 ms/op
                 executeQuery·p0.50:   286.786 ms/op
                 executeQuery·p0.90:   293.706 ms/op
                 executeQuery·p0.95:   295.279 ms/op
                 executeQuery·p0.99:   295.698 ms/op
                 executeQuery·p0.999:  295.698 ms/op
                 executeQuery·p0.9999: 295.698 ms/op
                 executeQuery·p1.00:   295.698 ms/op

Iteration   4: 287.325 ±(99.9%) 1.521 ms/op
                 executeQuery·p0.00:   283.640 ms/op
                 executeQuery·p0.50:   286.786 ms/op
                 executeQuery·p0.90:   290.980 ms/op
                 executeQuery·p0.95:   293.287 ms/op
                 executeQuery·p0.99:   294.126 ms/op
                 executeQuery·p0.999:  294.126 ms/op
                 executeQuery·p0.9999: 294.126 ms/op
                 executeQuery·p1.00:   294.126 ms/op

Iteration   5: 287.579 ±(99.9%) 1.898 ms/op
                 executeQuery·p0.00:   284.164 ms/op
                 executeQuery·p0.50:   286.261 ms/op
                 executeQuery·p0.90:   293.077 ms/op
                 executeQuery·p0.95:   294.650 ms/op
                 executeQuery·p0.99:   294.650 ms/op
                 executeQuery·p0.999:  294.650 ms/op
                 executeQuery·p0.9999: 294.650 ms/op
                 executeQuery·p1.00:   294.650 ms/op


# Run progress: 99.05% complete, ETA 00:10:59
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 397.379 ±(99.9%) 134.860 ms/op
# Warmup Iteration   2: 241.472 ±(99.9%) 4.623 ms/op
# Warmup Iteration   3: 237.802 ±(99.9%) 5.035 ms/op
# Warmup Iteration   4: 236.953 ±(99.9%) 3.673 ms/op
# Warmup Iteration   5: 235.533 ±(99.9%) 3.405 ms/op
Iteration   1: 236.460 ±(99.9%) 3.121 ms/op
                 executeQuery·p0.00:   228.327 ms/op
                 executeQuery·p0.50:   236.061 ms/op
                 executeQuery·p0.90:   245.812 ms/op
                 executeQuery·p0.95:   247.529 ms/op
                 executeQuery·p0.99:   252.183 ms/op
                 executeQuery·p0.999:  252.183 ms/op
                 executeQuery·p0.9999: 252.183 ms/op
                 executeQuery·p1.00:   252.183 ms/op

Iteration   2: 235.198 ±(99.9%) 3.632 ms/op
                 executeQuery·p0.00:   227.017 ms/op
                 executeQuery·p0.50:   234.881 ms/op
                 executeQuery·p0.90:   247.569 ms/op
                 executeQuery·p0.95:   250.819 ms/op
                 executeQuery·p0.99:   252.445 ms/op
                 executeQuery·p0.999:  252.445 ms/op
                 executeQuery·p0.9999: 252.445 ms/op
                 executeQuery·p1.00:   252.445 ms/op

Iteration   3: 235.003 ±(99.9%) 3.894 ms/op
                 executeQuery·p0.00:   224.920 ms/op
                 executeQuery·p0.50:   234.095 ms/op
                 executeQuery·p0.90:   244.475 ms/op
                 executeQuery·p0.95:   253.808 ms/op
                 executeQuery·p0.99:   257.688 ms/op
                 executeQuery·p0.999:  257.688 ms/op
                 executeQuery·p0.9999: 257.688 ms/op
                 executeQuery·p1.00:   257.688 ms/op

Iteration   4: 235.052 ±(99.9%) 3.375 ms/op
                 executeQuery·p0.00:   227.017 ms/op
                 executeQuery·p0.50:   234.881 ms/op
                 executeQuery·p0.90:   243.270 ms/op
                 executeQuery·p0.95:   245.786 ms/op
                 executeQuery·p0.99:   260.571 ms/op
                 executeQuery·p0.999:  260.571 ms/op
                 executeQuery·p0.9999: 260.571 ms/op
                 executeQuery·p1.00:   260.571 ms/op

Iteration   5: 231.217 ±(99.9%) 2.846 ms/op
                 executeQuery·p0.00:   224.920 ms/op
                 executeQuery·p0.50:   228.852 ms/op
                 executeQuery·p0.90:   239.390 ms/op
                 executeQuery·p0.95:   243.637 ms/op
                 executeQuery·p0.99:   249.299 ms/op
                 executeQuery·p0.999:  249.299 ms/op
                 executeQuery·p0.9999: 249.299 ms/op
                 executeQuery·p1.00:   249.299 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 389
  mean =    258.133 ±(99.9%) 4.472 ms/op

  Histogram, ms/op:
    [220.000, 225.000) = 2 
    [225.000, 230.000) = 64 
    [230.000, 235.000) = 54 
    [235.000, 240.000) = 60 
    [240.000, 245.000) = 18 
    [245.000, 250.000) = 9 
    [250.000, 255.000) = 5 
    [255.000, 260.000) = 1 
    [260.000, 265.000) = 1 
    [265.000, 270.000) = 0 
    [270.000, 275.000) = 0 
    [275.000, 280.000) = 0 
    [280.000, 285.000) = 52 
    [285.000, 290.000) = 92 
    [290.000, 295.000) = 28 

  Percentiles, ms/op:
      p(0.0000) =    224.920 ms/op
     p(50.0000) =    244.318 ms/op
     p(90.0000) =    288.883 ms/op
     p(95.0000) =    291.504 ms/op
     p(99.0000) =    294.702 ms/op
     p(99.9000) =    296.223 ms/op
     p(99.9900) =    296.223 ms/op
     p(99.9990) =    296.223 ms/op
     p(99.9999) =    296.223 ms/op
    p(100.0000) =    296.223 ms/op


# JMH version: 1.36
# VM version: JDK 20.0.1, OpenJDK 64-Bit Server VM, 20.0.1+9-29
# VM invoker: /home/olivier/external_software/openjdk-20.0.1/bin/java
# VM options: --add-modules=jdk.incubator.vector --add-opens=java.base/java.nio=ALL-UNNAMED -Darrow.enable_unsafe_memory_access=true -Darrow.enable_null_check_for_get=false --enable-preview --enable-native-access=ALL-UNNAMED -Xmx32g -Xms16g
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Sampling time
# Benchmark: benchmarks.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery
# Parameters: (tpchInstance = /nvtmp/AethraTestData/tpch/sf-10)

# Run progress: 99.37% complete, ETA 00:07:19
# Fork: 1 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3916.082 ±(99.9%) 25708.842 ms/op
# Warmup Iteration   2: 2663.383 ±(99.9%) 85.709 ms/op
# Warmup Iteration   3: 2681.209 ±(99.9%) 94.862 ms/op
# Warmup Iteration   4: 2651.849 ±(99.9%) 106.993 ms/op
# Warmup Iteration   5: 2636.120 ±(99.9%) 64.519 ms/op
Iteration   1: 2631.926 ±(99.9%) 34.991 ms/op
                 executeQuery·p0.00:   2625.634 ms/op
                 executeQuery·p0.50:   2631.926 ms/op
                 executeQuery·p0.90:   2638.217 ms/op
                 executeQuery·p0.95:   2638.217 ms/op
                 executeQuery·p0.99:   2638.217 ms/op
                 executeQuery·p0.999:  2638.217 ms/op
                 executeQuery·p0.9999: 2638.217 ms/op
                 executeQuery·p1.00:   2638.217 ms/op

Iteration   2: 2631.926 ±(99.9%) 34.991 ms/op
                 executeQuery·p0.00:   2625.634 ms/op
                 executeQuery·p0.50:   2631.926 ms/op
                 executeQuery·p0.90:   2638.217 ms/op
                 executeQuery·p0.95:   2638.217 ms/op
                 executeQuery·p0.99:   2638.217 ms/op
                 executeQuery·p0.999:  2638.217 ms/op
                 executeQuery·p0.9999: 2638.217 ms/op
                 executeQuery·p1.00:   2638.217 ms/op

Iteration   3: 2639.266 ±(99.9%) 67.759 ms/op
                 executeQuery·p0.00:   2634.023 ms/op
                 executeQuery·p0.50:   2634.023 ms/op
                 executeQuery·p0.90:   2654.994 ms/op
                 executeQuery·p0.95:   2654.994 ms/op
                 executeQuery·p0.99:   2654.994 ms/op
                 executeQuery·p0.999:  2654.994 ms/op
                 executeQuery·p0.9999: 2654.994 ms/op
                 executeQuery·p1.00:   2654.994 ms/op

Iteration   4: 2646.606 ±(99.9%) 38.330 ms/op
                 executeQuery·p0.00:   2642.412 ms/op
                 executeQuery·p0.50:   2644.509 ms/op
                 executeQuery·p0.90:   2654.994 ms/op
                 executeQuery·p0.95:   2654.994 ms/op
                 executeQuery·p0.99:   2654.994 ms/op
                 executeQuery·p0.999:  2654.994 ms/op
                 executeQuery·p0.9999: 2654.994 ms/op
                 executeQuery·p1.00:   2654.994 ms/op

Iteration   5: 2645.557 ±(99.9%) 40.655 ms/op
                 executeQuery·p0.00:   2638.217 ms/op
                 executeQuery·p0.50:   2646.606 ms/op
                 executeQuery·p0.90:   2650.800 ms/op
                 executeQuery·p0.95:   2650.800 ms/op
                 executeQuery·p0.99:   2650.800 ms/op
                 executeQuery·p0.999:  2650.800 ms/op
                 executeQuery·p0.9999: 2650.800 ms/op
                 executeQuery·p1.00:   2650.800 ms/op


# Run progress: 99.68% complete, ETA 00:03:39
# Fork: 2 of 2
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 3927.267 ±(99.9%) 22727.044 ms/op
# Warmup Iteration   2: 2646.606 ±(99.9%) 38.330 ms/op
# Warmup Iteration   3: 2646.606 ±(99.9%) 66.390 ms/op
# Warmup Iteration   4: 2628.780 ±(99.9%) 80.933 ms/op
# Warmup Iteration   5: 2604.663 ±(99.9%) 22.130 ms/op
Iteration   1: 2594.177 ±(99.9%) 15.648 ms/op
                 executeQuery·p0.00:   2592.080 ms/op
                 executeQuery·p0.50:   2594.177 ms/op
                 executeQuery·p0.90:   2596.274 ms/op
                 executeQuery·p0.95:   2596.274 ms/op
                 executeQuery·p0.99:   2596.274 ms/op
                 executeQuery·p0.999:  2596.274 ms/op
                 executeQuery·p0.9999: 2596.274 ms/op
                 executeQuery·p1.00:   2596.274 ms/op

Iteration   2: 2615.149 ±(99.9%) 34.991 ms/op
                 executeQuery·p0.00:   2608.857 ms/op
                 executeQuery·p0.50:   2615.149 ms/op
                 executeQuery·p0.90:   2621.440 ms/op
                 executeQuery·p0.95:   2621.440 ms/op
                 executeQuery·p0.99:   2621.440 ms/op
                 executeQuery·p0.999:  2621.440 ms/op
                 executeQuery·p0.9999: 2621.440 ms/op
                 executeQuery·p1.00:   2621.440 ms/op

Iteration   3: 2623.537 ±(99.9%) 15.648 ms/op
                 executeQuery·p0.00:   2621.440 ms/op
                 executeQuery·p0.50:   2623.537 ms/op
                 executeQuery·p0.90:   2625.634 ms/op
                 executeQuery·p0.95:   2625.634 ms/op
                 executeQuery·p0.99:   2625.634 ms/op
                 executeQuery·p0.999:  2625.634 ms/op
                 executeQuery·p0.9999: 2625.634 ms/op
                 executeQuery·p1.00:   2625.634 ms/op

Iteration   4: 2628.780 ±(99.9%) 25.950 ms/op
                 executeQuery·p0.00:   2625.634 ms/op
                 executeQuery·p0.50:   2627.731 ms/op
                 executeQuery·p0.90:   2634.023 ms/op
                 executeQuery·p0.95:   2634.023 ms/op
                 executeQuery·p0.99:   2634.023 ms/op
                 executeQuery·p0.999:  2634.023 ms/op
                 executeQuery·p0.9999: 2634.023 ms/op
                 executeQuery·p1.00:   2634.023 ms/op

Iteration   5: 2626.683 ±(99.9%) 13.552 ms/op
                 executeQuery·p0.00:   2625.634 ms/op
                 executeQuery·p0.50:   2625.634 ms/op
                 executeQuery·p0.90:   2629.829 ms/op
                 executeQuery·p0.95:   2629.829 ms/op
                 executeQuery·p0.99:   2629.829 ms/op
                 executeQuery·p0.999:  2629.829 ms/op
                 executeQuery·p0.9999: 2629.829 ms/op
                 executeQuery·p1.00:   2629.829 ms/op



Result "benchmarks.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery":
  N = 40
  mean =   2628.361 ±(99.9%) 8.773 ms/op

  Histogram, ms/op:
    [2590.000, 2595.000) = 2 
    [2595.000, 2600.000) = 2 
    [2600.000, 2605.000) = 0 
    [2605.000, 2610.000) = 1 
    [2610.000, 2615.000) = 1 
    [2615.000, 2620.000) = 1 
    [2620.000, 2625.000) = 3 
    [2625.000, 2630.000) = 13 
    [2630.000, 2635.000) = 6 
    [2635.000, 2640.000) = 3 
    [2640.000, 2645.000) = 3 
    [2645.000, 2650.000) = 1 
    [2650.000, 2655.000) = 4 

  Percentiles, ms/op:
      p(0.0000) =   2592.080 ms/op
     p(50.0000) =   2629.829 ms/op
     p(90.0000) =   2650.381 ms/op
     p(95.0000) =   2654.785 ms/op
     p(99.0000) =   2654.994 ms/op
     p(99.9000) =   2654.994 ms/op
     p(99.9900) =   2654.994 ms/op
     p(99.9990) =   2654.994 ms/op
     p(99.9999) =   2654.994 ms/op
    p(100.0000) =   2654.994 ms/op


# Run complete. Total time: 19:12:31

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

NOTE: Current JVM experimentally supports Compiler Blackholes, and they are in use. Please exercise
extra caution when trusting the results, look into the generated code to check the benchmark still
works, and factor in a small probability of new VM bugs. Additionally, while comparisons between
different JVMs are already problematic, the performance difference caused by different Blackhole
modes can be very significant. Please make sure you use the consistent Blackhole mode for comparisons.

Benchmark                                                                                                                                                            (tableFilePath)                    (tpchInstance)    Mode   Cnt       Score      Error  Units
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample   305     334.501 ±    5.216  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           327.156             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           331.350             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           336.069             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           342.203             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           391.004             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           743.440             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           743.440             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           743.440             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample   215     475.824 ±    1.347  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           467.665             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           476.054             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           482.869             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           484.442             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           490.042             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           493.355             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           493.355             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           493.355             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample   161     633.822 ±    4.796  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           597.688             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           629.146             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           655.360             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           657.352             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           663.497             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                  /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           664.797             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           664.797             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           664.797             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample    10    1973.420 ±   46.478  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          1946.157             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          1961.886             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2041.158             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2044.723             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2044.723             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2044.723             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                               /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2044.723             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2044.723             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample    10    4906.497 ±  257.941  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          4638.900             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          4840.227             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5099.435             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5100.274             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5100.274             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5100.274             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                               /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5100.274             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                 /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5100.274             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample    40    3221.330 ±   14.842  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3166.700             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3221.225             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3238.003             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3266.314             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3334.472             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3334.472             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3334.472             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3334.472             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample    30    4543.829 ±   11.527  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4487.905             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4546.626             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4563.403             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4575.566             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4580.180             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4580.180             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4580.180             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4580.180             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample    20    6535.145 ±   73.320  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6400.508             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6555.697             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6627.000             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6714.661             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6719.275             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                            /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6719.275             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6719.275             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6719.275             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample    10   21337.263 ± 2123.575  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         20031.996             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         20703.085             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         24061.883             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         24226.300             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         24226.300             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                          /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         24226.300             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                         /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         24226.300             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         24226.300             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample    10   49231.063 ± 2149.186  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         47244.640             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         49123.688             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50855.097             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50868.519             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50868.519             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                          /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50868.519             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                         /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50868.519             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                           /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50868.519             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample    20    6356.048 ±   70.430  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6232.736             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6366.953             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6441.612             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6450.420             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6450.840             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6450.840             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6450.840             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6450.840             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample    10   11096.451 ±   38.188  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11056.185             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11098.128             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11138.394             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11140.071             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11140.071             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11140.071             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11140.071             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11140.071             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample    10   12534.258 ±  575.488  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         11962.155             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12767.461             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12879.869             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12884.902             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12884.902             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                            /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12884.902             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12884.902             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12884.902             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample    10   45325.327 ± 2135.840  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         43889.197             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         44660.949             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         47714.402             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         47781.511             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         47781.511             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                          /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         47781.511             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                         /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         47781.511             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         47781.511             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery                                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample    10   97267.587 ± 4176.203  ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample         94086.627             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample         97240.744             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        102891.310             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103347.651             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103347.651             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                          /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103347.651             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                         /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103347.651             ms/op
b.aggregation_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                           /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103347.651             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample   290     345.847 ±    0.807  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           339.739             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           344.457             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           350.224             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           351.745             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           364.092             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           372.769             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           372.769             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           372.769             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample   215     473.712 ±    1.506  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           463.471             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           474.481             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           480.772             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           486.225             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           494.844             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           495.452             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           495.452             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           495.452             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample   150     683.686 ±    3.734  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           645.923             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           684.720             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           699.295             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           702.546             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           714.594             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           715.129             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           715.129             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           715.129             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample    10    2453.458 ±  426.370  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2078.278             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2495.611             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2830.736             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2839.544             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2839.544             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2839.544             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                  /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2839.544             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2839.544             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample    10    5033.165 ±  296.525  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          4789.895             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          4974.445             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5377.937             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                  /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample    30    3374.178 ±   21.565  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3359.638             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3365.929             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3380.190             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3484.418             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3519.021             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3519.021             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3519.021             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3519.021             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample    30    4553.336 ±   21.400  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4513.071             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4555.014             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4596.118             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4627.995             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4655.677             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4655.677             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4655.677             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4655.677             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample    20    6614.837 ±  209.572  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6358.565             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6580.863             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6922.279             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          7295.572             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          7314.866             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          7314.866             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          7314.866             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          7314.866             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample    10   25464.458 ± 1360.890  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         23387.439             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         25518.146             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26558.333             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26575.110             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26575.110             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26575.110             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26575.110             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26575.110             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample    10   49660.559 ± 1781.241  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         47445.967             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50365.202             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50660.481             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50667.192             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50667.192             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50667.192             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50667.192             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         50667.192             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample    20    6704.595 ±   32.307  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6585.057             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6710.886             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6736.052             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6744.021             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6744.441             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6744.441             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6744.441             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6744.441             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample    10   10995.787 ±   21.389  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10972.299             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10989.076             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11020.953             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11022.631             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11022.631             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11022.631             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11022.631             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         11022.631             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample    10   12619.822 ±  862.882  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         11928.601             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12582.912             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13354.664             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13354.664             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13354.664             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13354.664             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13354.664             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13354.664             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample    10   51029.580 ± 3525.431  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         45835.354             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         51170.509             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         54733.989             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         54895.051             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         54895.051             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         54895.051             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         54895.051             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         54895.051             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample    10  101280.698 ± 1537.066  ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample         99992.207             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        101065.949             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103106.059             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103213.433             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103213.433             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103213.433             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103213.433             ms/op
b.aggregation_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103213.433             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample   292     345.915 ±    3.488  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           339.214             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           343.409             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           349.700             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           350.749             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           367.479             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           642.777             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           642.777             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           642.777             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample   217     470.861 ±    2.690  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           455.606             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           468.713             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           479.724             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           481.873             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           489.066             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           608.174             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           608.174             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           608.174             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample   150     681.288 ±    4.127  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           642.777             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           682.623             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           697.303             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           699.400             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           709.225             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           716.177             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           716.177             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           716.177             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample    10    2540.909 ±   56.227  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2487.222             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2539.651             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2593.758             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2596.274             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2596.274             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2596.274             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                  /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2596.274             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2596.274             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample    10    5013.032 ±  287.666  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          4848.615             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          4974.445             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5378.775             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                   /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                  /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                    /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5385.486             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample    30    3537.196 ±  102.958  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3363.832             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3617.587             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3673.371             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3775.712             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3812.622             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3812.622             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3812.622             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          3812.622             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample    30    4534.881 ±   12.712  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4521.460             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4529.848             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4554.175             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4590.666             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4613.734             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4613.734             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4613.734             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          4613.734             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample    20    6405.960 ±  229.247  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          5964.300             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6366.953             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6735.213             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6736.052             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6736.052             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6736.052             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6736.052             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          6736.052             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample    10   25659.074 ± 1008.102  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         24998.052             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         25635.586             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         27145.535             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         27279.753             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         27279.753             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         27279.753             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         27279.753             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         27279.753             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample    10   49566.607 ± 1873.988  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         47513.076             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         49291.461             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         51056.424             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         51069.846             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         51069.846             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         51069.846             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         51069.846             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         51069.846             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample    20    6763.315 ±  180.093  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6610.223             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6719.275             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          6962.545             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          7545.133             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          7574.913             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          7574.913             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          7574.913             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample          7574.913             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample    10   10796.138 ±   40.105  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10754.195             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10796.138             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10849.826             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10854.859             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10854.859             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10854.859             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10854.859             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         10854.859             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample    10   12775.850 ± 1151.872  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         11593.056             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         12968.788             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13584.512             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13589.545             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13589.545             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13589.545             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13589.545             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         13589.545             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample    10   50405.468 ± 1632.793  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         48922.362             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         50532.975             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         51948.972             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         52009.370             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         52009.370             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         52009.370             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         52009.370             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         52009.370             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery                                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample    10  101092.793 ± 2039.974  ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample         99186.901             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        101065.949             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103025.528             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103079.215             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103079.215             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                             /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103079.215             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                            /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103079.215             ms/op
b.aggregation_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                              /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103079.215             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                               /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample   200     515.016 ±    1.414  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           499.646             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           514.589             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           520.094             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           521.142             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           535.193             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           571.474             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                          /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           571.474             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_2                               N/A  sample           571.474             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                              /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample   148     709.851 ±    7.690  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           699.400             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           704.643             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           716.282             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           730.962             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample           897.036             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                          /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample          1024.459             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample          1024.459             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                           /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_16                               N/A  sample          1024.459             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                            /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample   110     959.342 ±    3.687  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           923.795             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           963.117             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           970.981             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           974.127             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           984.036             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                        /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           984.613             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           984.613             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                         /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_8192                               N/A  sample           984.613             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                          /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample    10    2688.129 ±  164.259  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2541.748             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2657.092             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2899.942             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2906.653             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2906.653             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2906.653             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2906.653             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_262144                               N/A  sample          2906.653             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                          /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample    10    5143.894 ±  182.399  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          4982.833             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5112.857             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5326.766             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5326.766             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5326.766             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                      /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5326.766             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                     /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5326.766             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                       /nvtmp/AethraTestData/aggregation_query_int/arrow_size_31457280_keys_524288                               N/A  sample          5326.766             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                         /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample    20    5162.349 ±   89.007  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5083.496             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5108.662             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5299.923             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5484.891             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5494.538             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5494.538             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                    /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5494.538             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_2                               N/A  sample          5494.538             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                        /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample    20    6738.988 ±  254.531  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          6442.451             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          6723.469             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          7152.966             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          7307.736             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          7314.866             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                    /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          7314.866             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          7314.866             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                     /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_16                               N/A  sample          7314.866             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                      /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample    17    9580.284 ±  723.736  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          8363.442             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample          9613.345             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample         10921.968             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample         10921.968             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample         10921.968             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                  /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample         10921.968             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample         10921.968             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_8192                               N/A  sample         10921.968             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                    /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample    10   25424.193 ± 1733.576  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         22246.588             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         25769.804             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26155.680             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26172.457             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26172.457             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26172.457             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26172.457             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_262144                               N/A  sample         26172.457             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                    /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample    10   51016.158 ± 1422.679  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         49190.797             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         51204.063             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         52177.142             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         52210.696             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         52210.696             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         52210.696             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                               /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         52210.696             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf10/arrow_size_314572800_keys_524288                               N/A  sample         52210.696             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                         /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample    10   10296.177 ±  221.141  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10116.661             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10301.211             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10621.655             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10653.532             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10653.532             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10653.532             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                    /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10653.532             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_2                               N/A  sample         10653.532             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                        /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample    10   16767.150 ±  341.395  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16424.894             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16894.657             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16986.931             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16995.320             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16995.320             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                    /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16995.320             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16995.320             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                     /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_16                               N/A  sample         16995.320             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                      /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample    10   19629.343 ± 1000.685  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         19092.472             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         19461.571             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         21243.311             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         21407.728             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         21407.728             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                  /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         21407.728             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         21407.728             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                   /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_8192                               N/A  sample         21407.728             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                    /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample    10   51767.778 ± 4125.501  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         45902.463             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         51405.390             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         56297.626             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         56572.772             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         56572.772             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         56572.772             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         56572.772             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_262144                               N/A  sample         56572.772             ms/op
b.aggregation_query.VectorisedSimd.executeQuery                                                    /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample    10  102475.235 ± 1373.762  ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        101200.167             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        102542.344             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        103951.630             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        104018.739             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        104018.739             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        104018.739             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                               /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        104018.739             ms/op
b.aggregation_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                 /nvtmp/AethraTestData/aggregation_query_int_sf20/arrow_size_629145600_keys_524288                               N/A  sample        104018.739             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                      /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample  1273      77.859 ±    0.270  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            69.730             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            78.250             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            80.871             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            81.396             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            82.478             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                            /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            90.142             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                           /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            90.178             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            90.178             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                      /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample  1260      78.803 ±    0.225  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            71.303             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            79.561             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            81.134             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            81.527             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            82.575             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                            /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            91.511             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                           /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            92.537             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            92.537             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                      /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample  1249      79.417 ±    0.247  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            71.827             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            79.299             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            82.313             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            82.706             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            86.770             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                            /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            90.440             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                           /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            90.440             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                             /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            90.440             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                 /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample   140     742.227 ±    2.275  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           724.566             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           741.343             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           751.829             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           754.922             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           773.828             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                       /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           783.286             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                      /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           783.286             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           783.286             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                 /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample   140     741.688 ±    2.144  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           724.566             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           742.392             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           752.878             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           754.922             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           756.642             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                       /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           757.072             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                      /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           757.072             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           757.072             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                 /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample   140     746.436 ±    1.876  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           734.003             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           746.586             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           753.926             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           757.019             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           764.789             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                       /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           766.509             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                      /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           766.509             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                        /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           766.509             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                 /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample    76    1420.986 ±    5.443  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1388.315             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1421.869             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1438.646             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1438.961             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1449.132             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                       /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1449.132             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                      /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1449.132             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1449.132             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                 /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample    70    1553.630 ±  323.835  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1430.258             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1461.715             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1482.477             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1487.615             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          8053.064             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                       /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          8053.064             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                      /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          8053.064             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          8053.064             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery                                                 /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample    70    1489.248 ±    5.132  ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1463.812             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1488.978             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1503.658             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1514.144             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1528.824             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                       /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1528.824             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                      /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1528.824             ms/op
b.filter_query.NonVectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                        /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1528.824             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                         /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample  1249      79.480 ±    0.232  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            71.827             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            79.167             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            82.444             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            82.969             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            84.869             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                               /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           100.925             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                              /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           103.678             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           103.678             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                         /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample  1251      79.285 ±    0.226  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            72.221             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            79.299             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            82.182             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            82.759             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            84.410             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                               /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            91.578             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                              /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            92.668             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            92.668             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                         /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample  1254      79.161 ±    0.223  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            72.090             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            79.167             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            82.182             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            82.575             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            84.017             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                               /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            89.738             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                              /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            90.440             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample            90.440             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample   134     764.185 ±    3.424  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           724.566             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           765.460             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           774.898             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           776.995             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           779.407             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           780.141             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           780.141             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           780.141             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample   140     745.313 ±    5.320  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           708.837             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           751.829             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           767.558             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           768.554             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           780.036             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           784.335             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           784.335             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           784.335             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample   140     754.945 ±    2.972  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           719.323             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           758.120             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           764.412             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           767.505             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           772.748             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           774.898             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           774.898             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample           774.898             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample    70    1482.597 ±    8.023  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1421.869             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1484.784             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1503.448             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1507.852             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1518.338             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1518.338             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1518.338             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1518.338             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample    70    1465.759 ±    9.204  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1398.800             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1472.201             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1486.881             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1491.809             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1501.561             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1501.561             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1501.561             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1501.561             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample    70    1491.524 ±    7.015  ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1415.578             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1493.172             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1507.852             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1514.144             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1516.241             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1516.241             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1516.241             ms/op
b.filter_query.NonVectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1516.241             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                         /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample  1299      76.471 ±    0.236  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            69.075             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            76.677             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            79.430             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            79.954             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            80.871             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                               /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            89.561             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                              /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            90.702             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample            90.702             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                         /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample  1283      77.357 ±    0.255  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            70.517             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            77.726             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            80.740             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            81.396             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            83.708             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                               /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            90.723             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                              /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            91.095             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample            91.095             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                         /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample   925     107.680 ±    0.285  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           103.285             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           107.872             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           110.808             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           111.411             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           112.950             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                               /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           121.373             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                              /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           121.373             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                                /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           121.373             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample   146     711.883 ±    3.440  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           671.089             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           708.313             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           731.172             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           736.100             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           743.010             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           744.489             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           744.489             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample           744.489             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample   141     732.248 ±    4.371  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           698.352             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           735.052             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           751.619             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           752.878             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           759.232             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           762.315             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           762.315             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample           762.315             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample   100    1033.246 ±    1.591  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1010.827             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1033.896             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1038.090             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1040.083             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1048.534             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1048.576             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1048.576             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1048.576             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample    77    1394.089 ±   12.848  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1337.983             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1405.092             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1436.549             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1438.646             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1440.743             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1440.743             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1440.743             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          1440.743             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample    74    1424.646 ±   11.948  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1377.829             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1420.820             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1459.618             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1472.725             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1476.395             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1476.395             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1476.395             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          1476.395             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery                                                    /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample    51    2006.152 ±    4.838  ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          1975.517             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.50                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          2006.974             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.90                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          2015.363             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.95                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          2023.752             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.99                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          2023.752             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.999                          /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          2023.752             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p0.9999                         /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          2023.752             ms/op
b.filter_query.VectorisedNonSimd.executeFilterQuery:executeFilterQuery·p1.00                           /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          2023.752             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                            /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample   316     321.684 ±    0.425  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           315.097             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           320.864             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           325.059             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           326.107             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           327.156             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                                  /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           335.544             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                                 /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           335.544             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_002_col2_098_col3_098/                               N/A  sample           335.544             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                            /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample   313     322.054 ±    0.565  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           313.000             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           322.437             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           325.583             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           326.789             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           327.680             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                                  /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           328.729             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                                 /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           328.729             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_002_col3_098/                               N/A  sample           328.729             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                            /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample   316     320.574 ±    0.696  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           311.427             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           320.340             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           325.059             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           326.107             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           328.729             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                                  /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           332.399             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                                 /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           332.399             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                                   /nvtmp/AethraTestData/filter_query_int/arrow_col1_098_col2_098_col3_002/                               N/A  sample           332.399             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                       /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample    40    3168.902 ±   19.005  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3091.202             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3160.408             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3208.223             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3216.821             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3217.031             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                             /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3217.031             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                            /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3217.031             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_002_col2_098_col3_098/                               N/A  sample          3217.031             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                       /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample    40    3179.807 ±   14.839  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3133.145             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3191.865             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3212.417             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3220.806             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3229.614             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                             /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3229.614             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                            /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3229.614             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_002_col3_098/                               N/A  sample          3229.614             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                       /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample    35    3282.223 ±   58.859  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3166.700             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3204.448             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3403.258             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3406.614             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3409.969             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                             /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3409.969             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                            /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3409.969             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                              /nvtmp/AethraTestData/filter_query_int_sf10/arrow_col1_098_col2_098_col3_002/                               N/A  sample          3409.969             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                       /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample    20    6536.403 ±  200.823  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6299.845             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6501.171             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6786.384             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6786.384             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6786.384             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                             /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6786.384             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                            /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6786.384             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_002_col2_098_col3_098/                               N/A  sample          6786.384             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                       /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample    20    6387.506 ±   29.938  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6308.233             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6404.702             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6417.285             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6417.285             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6417.285             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                             /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6417.285             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                            /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6417.285             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_002_col3_098/                               N/A  sample          6417.285             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery                                                       /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample    20    6565.763 ±  190.393  ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.00                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6341.788             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.50                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6522.143             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.90                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6794.772             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.95                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6802.742             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.99                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6803.161             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.999                             /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6803.161             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p0.9999                            /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6803.161             ms/op
b.filter_query.VectorisedSimd.executeFilterQuery:executeFilterQuery·p1.00                              /nvtmp/AethraTestData/filter_query_int_sf20/arrow_col1_098_col2_098_col3_002/                               N/A  sample          6803.161             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery                                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    30    4742.360 ±   66.985  ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                 /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4588.569             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                 /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4747.952             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                 /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4888.881             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                 /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4923.274             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                 /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4932.502             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4932.502             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                               /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4932.502             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                 /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4932.502             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery                                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   54505.819 ±  689.457  ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                            /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         53687.091             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                            /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         54559.506             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                            /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55250.728             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                            /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55297.704             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                            /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55297.704             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                           /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55297.704             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                          /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55297.704             ms/op
b.join_query.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                            /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55297.704             ms/op
b.join_query.NonVectorisedSimd.executeQuery                                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    20    5321.733 ±  118.930  ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4982.833             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5335.155             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5507.121             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5583.038             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5586.813             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                                                   /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5586.813             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                                                  /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5586.813             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5586.813             ms/op
b.join_query.NonVectorisedSimd.executeQuery                                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   60954.981 ±  750.233  ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         60397.978             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         60800.631             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         61907.927             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         61941.481             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         61941.481             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                                              /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         61941.481             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                                             /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         61941.481             ms/op
b.join_query.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         61941.481             ms/op
b.join_query.VectorisedNonSimd.executeQuery                                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    27    4946.793 ±   88.442  ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4815.061             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4915.724             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5120.406             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5279.790             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5309.989             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                   /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5309.989             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                  /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5309.989             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5309.989             ms/op
b.join_query.VectorisedNonSimd.executeQuery                                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   56143.276 ±  765.551  ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55499.031             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         56035.901             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57270.705             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57378.079             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57378.079             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                              /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57378.079             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                             /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57378.079             ms/op
b.join_query.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57378.079             ms/op
b.join_query.VectorisedSimd.executeQuery                                                                                          /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    26    4987.673 ±   98.286  ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4806.672             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          4991.222             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5253.785             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5286.920             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5301.600             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                      /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5301.600             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                     /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5301.600             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          5301.600             ms/op
b.join_query.VectorisedSimd.executeQuery                                                                                     /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   56539.218 ±  807.788  ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         55700.357             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         56539.218             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57109.643             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57109.643             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57109.643             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                 /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57109.643             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57109.643             ms/op
b.join_query.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         57109.643             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery                                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    45    2485.824 ±   45.381  ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                      /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2399.142             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                      /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2411.725             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                      /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2579.497             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                      /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2583.691             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                      /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2621.440             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                     /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2621.440             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                    /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2621.440             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                      /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2621.440             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery                                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   31420.370 ±  347.537  ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                 /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31205.622             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                 /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31406.948             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                 /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31729.071             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                 /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31742.493             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                 /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31742.493             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31742.493             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                               /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31742.493             ms/op
b.join_query_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                 /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         31742.493             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery                                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    40    2700.817 ±   69.496  ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2512.388             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2747.269             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2860.515             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2860.515             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2864.710             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                                        /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2864.710             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2864.710             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2864.710             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery                                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   32802.813 ±  404.566  ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.00                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         32480.690             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.50                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         32715.571             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.90                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         33249.087             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.95                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         33252.442             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.99                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         33252.442             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.999                                                   /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         33252.442             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p0.9999                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         33252.442             ms/op
b.join_query_hard_coded.NonVectorisedSimd.executeQuery:executeQuery·p1.00                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         33252.442             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery                                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    50    2226.085 ±    4.063  ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2214.593             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2227.175             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2231.370             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2231.370             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2273.313             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                        /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2273.313             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                       /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2273.313             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                         /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2273.313             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery                                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   29742.649 ±  246.443  ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29561.455             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29746.004             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29896.999             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29896.999             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29896.999             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                   /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29896.999             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                  /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29896.999             ms/op
b.join_query_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                    /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29896.999             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery                                                                               /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample    50    2402.665 ±    8.793  ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2378.170             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2403.336             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2424.308             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2424.308             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2432.696             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                           /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2432.696             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                          /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2432.696             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                            /nvtmp/AethraTestData/join_query_int/A_B_0.6_C_0.8                               N/A  sample          2432.696             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery                                                                          /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample    10   29759.426 ±  332.613  ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29527.900             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         29762.781             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         30054.705             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         30064.771             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         30064.771             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                      /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         30064.771             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                     /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         30064.771             ms/op
b.join_query_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                       /nvtmp/AethraTestData/join_query_int_sf10/A_B_0.6_C_0.8                               N/A  sample         30064.771             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   191     337.836 ±    3.311  ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           324.534             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           331.874             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           355.992             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           361.968             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           390.112             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           390.595             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                             N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           390.595             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           390.595             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    10    4360.818 ±  431.170  ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4055.892             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4309.647             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4814.222             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4815.061             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4815.061             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4815.061             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                             N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4815.061             ms/op
b.tpch.q10_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4815.061             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   194     326.394 ±    3.529  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           300.941             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           324.272             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           341.311             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           355.729             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           383.386             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                 N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           395.837             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           395.837             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           395.837             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    10    3717.412 ±  195.861  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3577.741             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3711.959             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3870.923             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3871.343             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3871.343             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                 N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3871.343             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3871.343             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3871.343             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   190     321.849 ±    4.638  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           306.184             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           315.621             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           334.968             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           381.682             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           395.979             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                 N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           397.410             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           397.410             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           397.410             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    10    3798.781 ±  148.324  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3674.210             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3800.039             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3930.063             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3930.063             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3930.063             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                 N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3930.063             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3930.063             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3930.063             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery                                                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   160     435.133 ±    5.398  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           405.275             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           432.538             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           454.558             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           459.801             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           547.126             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                    N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           548.405             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           548.405             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           548.405             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery                                                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    10    4787.379 ±  135.681  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4563.403             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4798.284             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4913.208             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4924.113             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4924.113             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                    N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4924.113             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4924.113             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4924.113             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                          N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   157     459.053 ±    6.561  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           435.159             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           453.509             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           479.724             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           494.508             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           569.817             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           570.425             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           570.425             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           570.425             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                          N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    10    5176.610 ±  187.201  ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4907.336             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5205.131             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5334.316             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5343.543             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5343.543             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5343.543             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5343.543             ms/op
b.tpch.q10_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5343.543             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   359     279.632 ±    0.652  ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           274.203             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           278.921             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           284.164             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           286.261             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           294.650             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           299.368             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           299.368             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           299.368             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    40    2536.400 ±    9.824  ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2491.417             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2537.554             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2558.525             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2558.525             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2571.108             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2571.108             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2571.108             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2571.108             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   321     313.135 ±    1.972  ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           300.941             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.50                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           311.427             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.90                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           330.301             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.95                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           333.447             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.99                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           336.593             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.999                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           338.690             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.9999                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           338.690             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p1.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           338.690             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    40    2972.818 ±   14.541  ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2948.596             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.50                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2963.276             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.90                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3025.351             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.95                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3048.630             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.99                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3053.453             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.999                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3053.453             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.9999                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3053.453             ms/op
b.tpch.q1_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p1.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3053.453             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   222     463.279 ±    1.760  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           445.121             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           466.092             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           470.286             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           471.781             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           475.167             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           476.054             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                 N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           476.054             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           476.054             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    30    4427.507 ±    5.585  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4412.408             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4429.185             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4437.574             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4445.962             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4445.962             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4445.962             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                 N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4445.962             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4445.962             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   235     429.673 ±    2.242  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           405.275             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           433.062             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           441.450             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           444.596             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           448.266             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           450.888             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                 N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           450.888             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           450.888             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    30    4101.051 ±   20.641  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4009.755             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4106.224             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4135.164             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4149.635             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4156.555             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4156.555             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                 N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4156.555             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4156.555             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery                                                                                                                         N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   203     508.113 ±    2.810  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           490.734             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           513.278             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           521.667             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           523.764             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           529.887             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           530.055             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                    N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           530.055             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           530.055             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery                                                                                                                         N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    26    4947.988 ±   32.966  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4898.947             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4915.724             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5007.999             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5007.999             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5007.999             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5007.999             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                    N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5007.999             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5007.999             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   174     591.469 ±    2.325  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           579.863             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           588.251             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           603.980             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           605.028             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           612.631             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           613.417             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           613.417             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           613.417             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    20    5796.109 ±   23.689  ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5687.476             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5804.917             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5813.305             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5813.305             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5813.305             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5813.305             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5813.305             ms/op
b.tpch.q1_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          5813.305             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   343     275.660 ±    8.550  ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           246.678             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           263.455             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           275.566             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           450.259             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           467.958             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           470.811             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           470.811             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           470.811             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    10    2701.551 ±  268.859  ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2621.440             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2650.800             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3152.439             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3204.448             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3204.448             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3204.448             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3204.448             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3204.448             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   215     460.749 ±    2.293  ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           436.208             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.50                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           461.898             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.90                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           473.851             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.95                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           475.634             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.99                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           481.569             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.999                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           481.821             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.9999                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           481.821             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p1.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           481.821             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    20    4880.073 ±   23.020  ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4840.227             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.50                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4873.781             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.90                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4931.663             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.95                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4940.471             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.99                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4940.890             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.999                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4940.890             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.9999                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4940.890             ms/op
b.tpch.q3_no_sort_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p1.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          4940.890             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   351     263.313 ±    1.285  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           245.891             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           262.406             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           275.775             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           276.824             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           278.397             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           281.543             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                 N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           281.543             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           281.543             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    30    2724.061 ±   24.702  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2680.160             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2726.298             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2764.046             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2765.934             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2768.241             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2768.241             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                 N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2768.241             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2768.241             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   345     269.168 ±    1.466  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           245.629             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           268.435             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           279.655             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           284.164             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           289.690             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                  N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           292.553             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                 N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           292.553             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           292.553             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    30    2689.667 ±  103.232  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2487.222             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2772.435             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2897.845             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2973.971             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2994.733             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                  N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2994.733             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                 N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2994.733             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2994.733             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery                                                                                                                         N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   304     313.723 ±    6.577  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           279.970             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           301.990             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           398.197             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           406.585             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           416.599             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                     N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           419.430             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                    N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           419.430             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           419.430             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery                                                                                                                         N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    27    3316.607 ±   91.230  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3141.534             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3296.723             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3554.253             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3563.481             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3565.158             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                     N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3565.158             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                    N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3565.158             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3565.158             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   317     298.234 ±    4.077  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           272.630             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           292.028             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           313.000             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           328.938             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           406.428             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           422.052             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           422.052             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           422.052             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    24    3382.357 ±  167.474  ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3124.756             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3351.249             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3795.845             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3951.034             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3951.034             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3951.034             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3951.034             ms/op
b.tpch.q3_no_sort_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          3951.034             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   529     190.254 ±    0.619  ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           180.617             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           189.792             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           195.822             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           198.050             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           200.199             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                       N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           202.899             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                      N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           202.899             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                        N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           202.899             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery                                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    60    1837.804 ±   13.063  ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1795.162             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1833.959             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1889.953             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1893.728             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1895.825             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                       N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1895.825             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                      N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1895.825             ms/op
b.tpch.q6_hard_coded.NonVectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                        N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1895.825             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery                                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   524     191.704 ±    0.536  ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           182.452             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.50                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           191.627             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.90                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           196.084             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.95                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           196.608             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.99                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           202.375             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.999                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           206.307             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.9999                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           206.307             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p1.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           206.307             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery                                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    60    1828.507 ±   25.579  ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1782.579             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.50                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1827.668             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.90                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1862.061             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.95                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1864.368             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.99                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2206.204             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.999                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2206.204             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p0.9999                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2206.204             ms/op
b.tpch.q6_hard_coded.NonVectorisedSimdHandCrafted.executeQuery:executeQuery·p1.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2206.204             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   523     187.689 ±    0.669  ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           180.879             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           188.744             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           193.095             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           196.346             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           199.628             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                          N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           209.191             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                         N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           209.191             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           209.191             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery                                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    60    1803.551 ±   13.289  ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.00                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1761.608             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.50                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1796.211             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.90                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1843.187             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.95                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1855.980             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.99                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1858.077             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.999                                                                                                          N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1858.077             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p0.9999                                                                                                         N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1858.077             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimd.executeQuery:executeQuery·p1.00                                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1858.077             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   529     186.025 ±    0.574  ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           181.666             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           183.501             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           191.889             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           192.938             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           196.529             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                          N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           198.181             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                         N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           198.181             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                           N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           198.181             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    60    1824.837 ±   20.104  ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.00                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1776.288             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.50                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1839.202             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.90                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1855.560             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.95                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          1872.652             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.99                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2069.889             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.999                                                                                          N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2069.889             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p0.9999                                                                                         N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2069.889             ms/op
b.tpch.q6_hard_coded.VectorisedNonSimdReducedSelVecUse.executeQuery:executeQuery·p1.00                                                                                           N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2069.889             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery                                                                                                                                 N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   501     201.282 ±    1.070  ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           190.054             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           200.540             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           207.880             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           214.172             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           235.363             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                             N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           274.203             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                            N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           274.203             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           274.203             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery                                                                                                                                 N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    50    2086.960 ±   34.546  ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.00                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2021.655             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.50                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2078.278             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.90                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2125.673             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.95                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2292.187             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.99                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2399.142             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.999                                                                                                             N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2399.142             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p0.9999                                                                                                            N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2399.142             ms/op
b.tpch.q6_hard_coded.VectorisedSimd.executeQuery:executeQuery·p1.00                                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2399.142             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                                   N/A   /nvtmp/AethraTestData/tpch/sf-1  sample   389     258.133 ±    4.472  ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           224.920             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           244.318             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           288.883             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           291.504             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           294.702             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                               N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           296.223             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                              N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           296.223             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                                N/A   /nvtmp/AethraTestData/tpch/sf-1  sample           296.223             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery                                                                                                                   N/A  /nvtmp/AethraTestData/tpch/sf-10  sample    40    2628.361 ±    8.773  ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2592.080             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.50                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2629.829             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.90                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2650.381             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.95                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2654.785             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.99                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2654.994             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.999                                                                                               N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2654.994             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p0.9999                                                                                              N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2654.994             ms/op
b.tpch.q6_hard_coded.VectorisedSimdReducedMaskUse.executeQuery:executeQuery·p1.00                                                                                                N/A  /nvtmp/AethraTestData/tpch/sf-10  sample          2654.994             ms/op

Benchmark result is saved to jmh-result.csv
